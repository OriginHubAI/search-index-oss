// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/data_format/features.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fdata_5fformat_2ffeatures_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fdata_5fformat_2ffeatures_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "absl/strings/cord.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "scann/coscann/v2_restricts.pb.h"
#include "scann/proto/restricts.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_scann_2fdata_5fformat_2ffeatures_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fdata_5fformat_2ffeatures_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_scann_2fdata_5fformat_2ffeatures_2eproto;
namespace research_scann {
class GenericFeatureVector;
struct GenericFeatureVectorDefaultTypeInternal;
extern GenericFeatureVectorDefaultTypeInternal _GenericFeatureVector_default_instance_;
class GenericFeatureVector_Crowding;
struct GenericFeatureVector_CrowdingDefaultTypeInternal;
extern GenericFeatureVector_CrowdingDefaultTypeInternal _GenericFeatureVector_Crowding_default_instance_;
class GenericFeatureVector_FixedPointMetadata;
struct GenericFeatureVector_FixedPointMetadataDefaultTypeInternal;
extern GenericFeatureVector_FixedPointMetadataDefaultTypeInternal _GenericFeatureVector_FixedPointMetadata_default_instance_;
class GenericFeatureVector_RestrictTokens;
struct GenericFeatureVector_RestrictTokensDefaultTypeInternal;
extern GenericFeatureVector_RestrictTokensDefaultTypeInternal _GenericFeatureVector_RestrictTokens_default_instance_;
}  // namespace research_scann
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace research_scann {
enum GenericFeatureVector_FeatureType : int {
  GenericFeatureVector_FeatureType_UNKNOWN = 0,
  GenericFeatureVector_FeatureType_INT64 = 1,
  GenericFeatureVector_FeatureType_FLOAT = 2,
  GenericFeatureVector_FeatureType_DOUBLE = 3,
  GenericFeatureVector_FeatureType_STRING = 4,
  GenericFeatureVector_FeatureType_BINARY = 5,
};

bool GenericFeatureVector_FeatureType_IsValid(int value);
extern const uint32_t GenericFeatureVector_FeatureType_internal_data_[];
constexpr GenericFeatureVector_FeatureType GenericFeatureVector_FeatureType_FeatureType_MIN = static_cast<GenericFeatureVector_FeatureType>(0);
constexpr GenericFeatureVector_FeatureType GenericFeatureVector_FeatureType_FeatureType_MAX = static_cast<GenericFeatureVector_FeatureType>(5);
constexpr int GenericFeatureVector_FeatureType_FeatureType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
GenericFeatureVector_FeatureType_descriptor();
template <typename T>
const std::string& GenericFeatureVector_FeatureType_Name(T value) {
  static_assert(std::is_same<T, GenericFeatureVector_FeatureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FeatureType_Name().");
  return GenericFeatureVector_FeatureType_Name(static_cast<GenericFeatureVector_FeatureType>(value));
}
template <>
inline const std::string& GenericFeatureVector_FeatureType_Name(GenericFeatureVector_FeatureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GenericFeatureVector_FeatureType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool GenericFeatureVector_FeatureType_Parse(absl::string_view name, GenericFeatureVector_FeatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenericFeatureVector_FeatureType>(
      GenericFeatureVector_FeatureType_descriptor(), name, value);
}
enum GenericFeatureVector_FeatureNorm : int {
  GenericFeatureVector_FeatureNorm_NONE = 0,
  GenericFeatureVector_FeatureNorm_UNITL2NORM = 1,
  GenericFeatureVector_FeatureNorm_STDGAUSSNORM = 2,
  GenericFeatureVector_FeatureNorm_UNITL1NORM = 3,
};

bool GenericFeatureVector_FeatureNorm_IsValid(int value);
extern const uint32_t GenericFeatureVector_FeatureNorm_internal_data_[];
constexpr GenericFeatureVector_FeatureNorm GenericFeatureVector_FeatureNorm_FeatureNorm_MIN = static_cast<GenericFeatureVector_FeatureNorm>(0);
constexpr GenericFeatureVector_FeatureNorm GenericFeatureVector_FeatureNorm_FeatureNorm_MAX = static_cast<GenericFeatureVector_FeatureNorm>(3);
constexpr int GenericFeatureVector_FeatureNorm_FeatureNorm_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
GenericFeatureVector_FeatureNorm_descriptor();
template <typename T>
const std::string& GenericFeatureVector_FeatureNorm_Name(T value) {
  static_assert(std::is_same<T, GenericFeatureVector_FeatureNorm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FeatureNorm_Name().");
  return GenericFeatureVector_FeatureNorm_Name(static_cast<GenericFeatureVector_FeatureNorm>(value));
}
template <>
inline const std::string& GenericFeatureVector_FeatureNorm_Name(GenericFeatureVector_FeatureNorm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GenericFeatureVector_FeatureNorm_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool GenericFeatureVector_FeatureNorm_Parse(absl::string_view name, GenericFeatureVector_FeatureNorm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenericFeatureVector_FeatureNorm>(
      GenericFeatureVector_FeatureNorm_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class GenericFeatureVector_FixedPointMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.GenericFeatureVector.FixedPointMetadata) */ {
 public:
  inline GenericFeatureVector_FixedPointMetadata() : GenericFeatureVector_FixedPointMetadata(nullptr) {}
  ~GenericFeatureVector_FixedPointMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericFeatureVector_FixedPointMetadata(::google::protobuf::internal::ConstantInitialized);

  inline GenericFeatureVector_FixedPointMetadata(const GenericFeatureVector_FixedPointMetadata& from)
      : GenericFeatureVector_FixedPointMetadata(nullptr, from) {}
  GenericFeatureVector_FixedPointMetadata(GenericFeatureVector_FixedPointMetadata&& from) noexcept
    : GenericFeatureVector_FixedPointMetadata() {
    *this = ::std::move(from);
  }

  inline GenericFeatureVector_FixedPointMetadata& operator=(const GenericFeatureVector_FixedPointMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericFeatureVector_FixedPointMetadata& operator=(GenericFeatureVector_FixedPointMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericFeatureVector_FixedPointMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericFeatureVector_FixedPointMetadata* internal_default_instance() {
    return reinterpret_cast<const GenericFeatureVector_FixedPointMetadata*>(
               &_GenericFeatureVector_FixedPointMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GenericFeatureVector_FixedPointMetadata& a, GenericFeatureVector_FixedPointMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericFeatureVector_FixedPointMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericFeatureVector_FixedPointMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericFeatureVector_FixedPointMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericFeatureVector_FixedPointMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericFeatureVector_FixedPointMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericFeatureVector_FixedPointMetadata& from) {
    GenericFeatureVector_FixedPointMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericFeatureVector_FixedPointMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.GenericFeatureVector.FixedPointMetadata";
  }
  protected:
  explicit GenericFeatureVector_FixedPointMetadata(::google::protobuf::Arena* arena);
  GenericFeatureVector_FixedPointMetadata(::google::protobuf::Arena* arena, const GenericFeatureVector_FixedPointMetadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSquaredL2NormFieldNumber = 1,
  };
  // optional float squared_l2_norm = 1;
  bool has_squared_l2_norm() const;
  void clear_squared_l2_norm() ;
  float squared_l2_norm() const;
  void set_squared_l2_norm(float value);

  private:
  float _internal_squared_l2_norm() const;
  void _internal_set_squared_l2_norm(float value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.GenericFeatureVector.FixedPointMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float squared_l2_norm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fdata_5fformat_2ffeatures_2eproto;
};// -------------------------------------------------------------------

class GenericFeatureVector_Crowding final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.GenericFeatureVector.Crowding) */ {
 public:
  inline GenericFeatureVector_Crowding() : GenericFeatureVector_Crowding(nullptr) {}
  ~GenericFeatureVector_Crowding() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericFeatureVector_Crowding(::google::protobuf::internal::ConstantInitialized);

  inline GenericFeatureVector_Crowding(const GenericFeatureVector_Crowding& from)
      : GenericFeatureVector_Crowding(nullptr, from) {}
  GenericFeatureVector_Crowding(GenericFeatureVector_Crowding&& from) noexcept
    : GenericFeatureVector_Crowding() {
    *this = ::std::move(from);
  }

  inline GenericFeatureVector_Crowding& operator=(const GenericFeatureVector_Crowding& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericFeatureVector_Crowding& operator=(GenericFeatureVector_Crowding&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericFeatureVector_Crowding& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericFeatureVector_Crowding* internal_default_instance() {
    return reinterpret_cast<const GenericFeatureVector_Crowding*>(
               &_GenericFeatureVector_Crowding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenericFeatureVector_Crowding& a, GenericFeatureVector_Crowding& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericFeatureVector_Crowding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericFeatureVector_Crowding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericFeatureVector_Crowding* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericFeatureVector_Crowding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericFeatureVector_Crowding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericFeatureVector_Crowding& from) {
    GenericFeatureVector_Crowding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericFeatureVector_Crowding* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.GenericFeatureVector.Crowding";
  }
  protected:
  explicit GenericFeatureVector_Crowding(::google::protobuf::Arena* arena);
  GenericFeatureVector_Crowding(::google::protobuf::Arena* arena, const GenericFeatureVector_Crowding& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrowdingAttributeFieldNumber = 1,
  };
  // optional int64 crowding_attribute = 1;
  bool has_crowding_attribute() const;
  void clear_crowding_attribute() ;
  ::int64_t crowding_attribute() const;
  void set_crowding_attribute(::int64_t value);

  private:
  ::int64_t _internal_crowding_attribute() const;
  void _internal_set_crowding_attribute(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.GenericFeatureVector.Crowding)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t crowding_attribute_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fdata_5fformat_2ffeatures_2eproto;
};// -------------------------------------------------------------------

class GenericFeatureVector_RestrictTokens final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.GenericFeatureVector.RestrictTokens) */ {
 public:
  inline GenericFeatureVector_RestrictTokens() : GenericFeatureVector_RestrictTokens(nullptr) {}
  ~GenericFeatureVector_RestrictTokens() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericFeatureVector_RestrictTokens(::google::protobuf::internal::ConstantInitialized);

  inline GenericFeatureVector_RestrictTokens(const GenericFeatureVector_RestrictTokens& from)
      : GenericFeatureVector_RestrictTokens(nullptr, from) {}
  GenericFeatureVector_RestrictTokens(GenericFeatureVector_RestrictTokens&& from) noexcept
    : GenericFeatureVector_RestrictTokens() {
    *this = ::std::move(from);
  }

  inline GenericFeatureVector_RestrictTokens& operator=(const GenericFeatureVector_RestrictTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericFeatureVector_RestrictTokens& operator=(GenericFeatureVector_RestrictTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericFeatureVector_RestrictTokens& default_instance() {
    return *internal_default_instance();
  }
  enum V2RestrictsCase {
    kEasyDefinition = 6,
    kTokens = 5,
    kDefinition = 4,
    V2_RESTRICTS_NOT_SET = 0,
  };

  static inline const GenericFeatureVector_RestrictTokens* internal_default_instance() {
    return reinterpret_cast<const GenericFeatureVector_RestrictTokens*>(
               &_GenericFeatureVector_RestrictTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GenericFeatureVector_RestrictTokens& a, GenericFeatureVector_RestrictTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericFeatureVector_RestrictTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericFeatureVector_RestrictTokens* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericFeatureVector_RestrictTokens* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericFeatureVector_RestrictTokens>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericFeatureVector_RestrictTokens& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericFeatureVector_RestrictTokens& from) {
    GenericFeatureVector_RestrictTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericFeatureVector_RestrictTokens* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.GenericFeatureVector.RestrictTokens";
  }
  protected:
  explicit GenericFeatureVector_RestrictTokens(::google::protobuf::Arena* arena);
  GenericFeatureVector_RestrictTokens(::google::protobuf::Arena* arena, const GenericFeatureVector_RestrictTokens& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenMembershipFieldNumber = 1,
    kWhitelistTokenFieldNumber = 2,
    kBlacklistTokenFieldNumber = 3,
    kV3CompatibleNamespaceFieldNumber = 8,
    kV3FieldNumber = 7,
    kEasyDefinitionFieldNumber = 6,
    kTokensFieldNumber = 5,
    kDefinitionFieldNumber = 4,
  };
  // repeated int64 token_membership = 1 [packed = true];
  int token_membership_size() const;
  private:
  int _internal_token_membership_size() const;

  public:
  void clear_token_membership() ;
  ::int64_t token_membership(int index) const;
  void set_token_membership(int index, ::int64_t value);
  void add_token_membership(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& token_membership() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_token_membership();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_token_membership() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_token_membership();

  public:
  // repeated int64 whitelist_token = 2 [packed = true];
  int whitelist_token_size() const;
  private:
  int _internal_whitelist_token_size() const;

  public:
  void clear_whitelist_token() ;
  ::int64_t whitelist_token(int index) const;
  void set_whitelist_token(int index, ::int64_t value);
  void add_whitelist_token(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& whitelist_token() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_whitelist_token();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_whitelist_token() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_whitelist_token();

  public:
  // repeated int64 blacklist_token = 3 [packed = true];
  int blacklist_token_size() const;
  private:
  int _internal_blacklist_token_size() const;

  public:
  void clear_blacklist_token() ;
  ::int64_t blacklist_token(int index) const;
  void set_blacklist_token(int index, ::int64_t value);
  void add_blacklist_token(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& blacklist_token() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_blacklist_token();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_blacklist_token() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_blacklist_token();

  public:
  // optional string v3_compatible_namespace = 8;
  bool has_v3_compatible_namespace() const;
  void clear_v3_compatible_namespace() ;
  const std::string& v3_compatible_namespace() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_v3_compatible_namespace(Arg_&& arg, Args_... args);
  std::string* mutable_v3_compatible_namespace();
  PROTOBUF_NODISCARD std::string* release_v3_compatible_namespace();
  void set_allocated_v3_compatible_namespace(std::string* value);

  private:
  const std::string& _internal_v3_compatible_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v3_compatible_namespace(
      const std::string& value);
  std::string* _internal_mutable_v3_compatible_namespace();

  public:
  // optional .research_scann.V3Restrict v3 = 7;
  bool has_v3() const;
  void clear_v3() ;
  const ::research_scann::V3Restrict& v3() const;
  PROTOBUF_NODISCARD ::research_scann::V3Restrict* release_v3();
  ::research_scann::V3Restrict* mutable_v3();
  void set_allocated_v3(::research_scann::V3Restrict* value);
  void unsafe_arena_set_allocated_v3(::research_scann::V3Restrict* value);
  ::research_scann::V3Restrict* unsafe_arena_release_v3();

  private:
  const ::research_scann::V3Restrict& _internal_v3() const;
  ::research_scann::V3Restrict* _internal_mutable_v3();

  public:
  // .research_scann.coscann.EasyRestrictDefinition easy_definition = 6;
  bool has_easy_definition() const;
  private:
  bool _internal_has_easy_definition() const;

  public:
  void clear_easy_definition() ;
  const ::research_scann::coscann::EasyRestrictDefinition& easy_definition() const;
  PROTOBUF_NODISCARD ::research_scann::coscann::EasyRestrictDefinition* release_easy_definition();
  ::research_scann::coscann::EasyRestrictDefinition* mutable_easy_definition();
  void set_allocated_easy_definition(::research_scann::coscann::EasyRestrictDefinition* value);
  void unsafe_arena_set_allocated_easy_definition(::research_scann::coscann::EasyRestrictDefinition* value);
  ::research_scann::coscann::EasyRestrictDefinition* unsafe_arena_release_easy_definition();

  private:
  const ::research_scann::coscann::EasyRestrictDefinition& _internal_easy_definition() const;
  ::research_scann::coscann::EasyRestrictDefinition* _internal_mutable_easy_definition();

  public:
  // .research_scann.coscann.RestrictTokensV2 tokens = 5;
  bool has_tokens() const;
  private:
  bool _internal_has_tokens() const;

  public:
  void clear_tokens() ;
  const ::research_scann::coscann::RestrictTokensV2& tokens() const;
  PROTOBUF_NODISCARD ::research_scann::coscann::RestrictTokensV2* release_tokens();
  ::research_scann::coscann::RestrictTokensV2* mutable_tokens();
  void set_allocated_tokens(::research_scann::coscann::RestrictTokensV2* value);
  void unsafe_arena_set_allocated_tokens(::research_scann::coscann::RestrictTokensV2* value);
  ::research_scann::coscann::RestrictTokensV2* unsafe_arena_release_tokens();

  private:
  const ::research_scann::coscann::RestrictTokensV2& _internal_tokens() const;
  ::research_scann::coscann::RestrictTokensV2* _internal_mutable_tokens();

  public:
  // .research_scann.coscann.RestrictDefinition definition = 4;
  bool has_definition() const;
  private:
  bool _internal_has_definition() const;

  public:
  void clear_definition() ;
  const ::research_scann::coscann::RestrictDefinition& definition() const;
  PROTOBUF_NODISCARD ::research_scann::coscann::RestrictDefinition* release_definition();
  ::research_scann::coscann::RestrictDefinition* mutable_definition();
  void set_allocated_definition(::research_scann::coscann::RestrictDefinition* value);
  void unsafe_arena_set_allocated_definition(::research_scann::coscann::RestrictDefinition* value);
  ::research_scann::coscann::RestrictDefinition* unsafe_arena_release_definition();

  private:
  const ::research_scann::coscann::RestrictDefinition& _internal_definition() const;
  ::research_scann::coscann::RestrictDefinition* _internal_mutable_definition();

  public:
  void clear_v2_restricts();
  V2RestrictsCase v2_restricts_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.GenericFeatureVector.RestrictTokens)
 private:
  class _Internal;
  void set_has_easy_definition();
  void set_has_tokens();
  void set_has_definition();

  inline bool has_v2_restricts() const;
  inline void clear_has_v2_restricts();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 4,
      90, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> token_membership_;
    mutable ::google::protobuf::internal::CachedSize _token_membership_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> whitelist_token_;
    mutable ::google::protobuf::internal::CachedSize _whitelist_token_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> blacklist_token_;
    mutable ::google::protobuf::internal::CachedSize _blacklist_token_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr v3_compatible_namespace_;
    ::research_scann::V3Restrict* v3_;
    union V2RestrictsUnion {
      constexpr V2RestrictsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::research_scann::coscann::EasyRestrictDefinition* easy_definition_;
      ::research_scann::coscann::RestrictTokensV2* tokens_;
      ::research_scann::coscann::RestrictDefinition* definition_;
    } v2_restricts_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fdata_5fformat_2ffeatures_2eproto;
};// -------------------------------------------------------------------

class GenericFeatureVector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.GenericFeatureVector) */ {
 public:
  inline GenericFeatureVector() : GenericFeatureVector(nullptr) {}
  ~GenericFeatureVector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericFeatureVector(::google::protobuf::internal::ConstantInitialized);

  inline GenericFeatureVector(const GenericFeatureVector& from)
      : GenericFeatureVector(nullptr, from) {}
  GenericFeatureVector(GenericFeatureVector&& from) noexcept
    : GenericFeatureVector() {
    *this = ::std::move(from);
  }

  inline GenericFeatureVector& operator=(const GenericFeatureVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericFeatureVector& operator=(GenericFeatureVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericFeatureVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericFeatureVector* internal_default_instance() {
    return reinterpret_cast<const GenericFeatureVector*>(
               &_GenericFeatureVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GenericFeatureVector& a, GenericFeatureVector& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericFeatureVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericFeatureVector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericFeatureVector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericFeatureVector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericFeatureVector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericFeatureVector& from) {
    GenericFeatureVector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericFeatureVector* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.GenericFeatureVector";
  }
  protected:
  explicit GenericFeatureVector(::google::protobuf::Arena* arena);
  GenericFeatureVector(::google::protobuf::Arena* arena, const GenericFeatureVector& from);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Crowding = GenericFeatureVector_Crowding;
  using RestrictTokens = GenericFeatureVector_RestrictTokens;
  using FixedPointMetadata = GenericFeatureVector_FixedPointMetadata;

  using FeatureType = GenericFeatureVector_FeatureType;
  static constexpr FeatureType UNKNOWN = GenericFeatureVector_FeatureType_UNKNOWN;
  static constexpr FeatureType INT64 = GenericFeatureVector_FeatureType_INT64;
  static constexpr FeatureType FLOAT = GenericFeatureVector_FeatureType_FLOAT;
  static constexpr FeatureType DOUBLE = GenericFeatureVector_FeatureType_DOUBLE;
  static constexpr FeatureType STRING = GenericFeatureVector_FeatureType_STRING;
  static constexpr FeatureType BINARY = GenericFeatureVector_FeatureType_BINARY;
  static inline bool FeatureType_IsValid(int value) {
    return GenericFeatureVector_FeatureType_IsValid(value);
  }
  static constexpr FeatureType FeatureType_MIN = GenericFeatureVector_FeatureType_FeatureType_MIN;
  static constexpr FeatureType FeatureType_MAX = GenericFeatureVector_FeatureType_FeatureType_MAX;
  static constexpr int FeatureType_ARRAYSIZE = GenericFeatureVector_FeatureType_FeatureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FeatureType_descriptor() {
    return GenericFeatureVector_FeatureType_descriptor();
  }
  template <typename T>
  static inline const std::string& FeatureType_Name(T value) {
    return GenericFeatureVector_FeatureType_Name(value);
  }
  static inline bool FeatureType_Parse(absl::string_view name, FeatureType* value) {
    return GenericFeatureVector_FeatureType_Parse(name, value);
  }

  using FeatureNorm = GenericFeatureVector_FeatureNorm;
  static constexpr FeatureNorm NONE = GenericFeatureVector_FeatureNorm_NONE;
  static constexpr FeatureNorm UNITL2NORM = GenericFeatureVector_FeatureNorm_UNITL2NORM;
  static constexpr FeatureNorm STDGAUSSNORM = GenericFeatureVector_FeatureNorm_STDGAUSSNORM;
  static constexpr FeatureNorm UNITL1NORM = GenericFeatureVector_FeatureNorm_UNITL1NORM;
  static inline bool FeatureNorm_IsValid(int value) {
    return GenericFeatureVector_FeatureNorm_IsValid(value);
  }
  static constexpr FeatureNorm FeatureNorm_MIN = GenericFeatureVector_FeatureNorm_FeatureNorm_MIN;
  static constexpr FeatureNorm FeatureNorm_MAX = GenericFeatureVector_FeatureNorm_FeatureNorm_MAX;
  static constexpr int FeatureNorm_ARRAYSIZE = GenericFeatureVector_FeatureNorm_FeatureNorm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FeatureNorm_descriptor() {
    return GenericFeatureVector_FeatureNorm_descriptor();
  }
  template <typename T>
  static inline const std::string& FeatureNorm_Name(T value) {
    return GenericFeatureVector_FeatureNorm_Name(value);
  }
  static inline bool FeatureNorm_Parse(absl::string_view name, FeatureNorm* value) {
    return GenericFeatureVector_FeatureNorm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureValueInt64FieldNumber = 3,
    kFeatureValueFloatFieldNumber = 4,
    kFeatureValueDoubleFieldNumber = 5,
    kFeatureIndexFieldNumber = 6,
    kTokensFieldNumber = 14,
    kDataIdStrFieldNumber = 2,
    kFeatureValueStringFieldNumber = 13,
    kClassLabelFieldNumber = 16,
    kUserinfoFieldNumber = 17,
    kRestrictTokensFieldNumber = 15,
    kCrowdingFieldNumber = 18,
    kFixedPointMetadataFieldNumber = 19,
    kExpirationTimestampFieldNumber = 20,
    kFeatureTypeFieldNumber = 1,
    kWeightFieldNumber = 8,
    kNormTypeFieldNumber = 9,
    kFeatureDimFieldNumber = 10,
  };
  // repeated int64 feature_value_int64 = 3 [packed = true];
  int feature_value_int64_size() const;
  private:
  int _internal_feature_value_int64_size() const;

  public:
  void clear_feature_value_int64() ;
  ::int64_t feature_value_int64(int index) const;
  void set_feature_value_int64(int index, ::int64_t value);
  void add_feature_value_int64(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& feature_value_int64() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_feature_value_int64();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_feature_value_int64() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_feature_value_int64();

  public:
  // repeated float feature_value_float = 4 [packed = true];
  int feature_value_float_size() const;
  private:
  int _internal_feature_value_float_size() const;

  public:
  void clear_feature_value_float() ;
  float feature_value_float(int index) const;
  void set_feature_value_float(int index, float value);
  void add_feature_value_float(float value);
  const ::google::protobuf::RepeatedField<float>& feature_value_float() const;
  ::google::protobuf::RepeatedField<float>* mutable_feature_value_float();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_feature_value_float() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_feature_value_float();

  public:
  // repeated double feature_value_double = 5 [packed = true];
  int feature_value_double_size() const;
  private:
  int _internal_feature_value_double_size() const;

  public:
  void clear_feature_value_double() ;
  double feature_value_double(int index) const;
  void set_feature_value_double(int index, double value);
  void add_feature_value_double(double value);
  const ::google::protobuf::RepeatedField<double>& feature_value_double() const;
  ::google::protobuf::RepeatedField<double>* mutable_feature_value_double();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_feature_value_double() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_feature_value_double();

  public:
  // repeated uint64 feature_index = 6 [packed = true];
  int feature_index_size() const;
  private:
  int _internal_feature_index_size() const;

  public:
  void clear_feature_index() ;
  ::uint64_t feature_index(int index) const;
  void set_feature_index(int index, ::uint64_t value);
  void add_feature_index(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& feature_index() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_feature_index();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_feature_index() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_feature_index();

  public:
  // repeated int32 tokens = 14 [packed = true, deprecated = true];
  [[deprecated]]  int tokens_size() const;
  private:
  int _internal_tokens_size() const;

  public:
  [[deprecated]]  void clear_tokens() ;
  [[deprecated]] ::int32_t tokens(int index) const;
  [[deprecated]] void set_tokens(int index, ::int32_t value);
  [[deprecated]] void add_tokens(::int32_t value);
  [[deprecated]] const ::google::protobuf::RepeatedField<::int32_t>& tokens() const;
  [[deprecated]] ::google::protobuf::RepeatedField<::int32_t>* mutable_tokens();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_tokens() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_tokens();

  public:
  // optional bytes data_id_str = 2;
  bool has_data_id_str() const;
  void clear_data_id_str() ;
  const std::string& data_id_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_id_str(Arg_&& arg, Args_... args);
  std::string* mutable_data_id_str();
  PROTOBUF_NODISCARD std::string* release_data_id_str();
  void set_allocated_data_id_str(std::string* value);

  private:
  const std::string& _internal_data_id_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_id_str(
      const std::string& value);
  std::string* _internal_mutable_data_id_str();

  public:
  // optional bytes feature_value_string = 13;
  bool has_feature_value_string() const;
  void clear_feature_value_string() ;
  const std::string& feature_value_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feature_value_string(Arg_&& arg, Args_... args);
  std::string* mutable_feature_value_string();
  PROTOBUF_NODISCARD std::string* release_feature_value_string();
  void set_allocated_feature_value_string(std::string* value);

  private:
  const std::string& _internal_feature_value_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feature_value_string(
      const std::string& value);
  std::string* _internal_mutable_feature_value_string();

  public:
  // optional string class_label = 16;
  bool has_class_label() const;
  void clear_class_label() ;
  const std::string& class_label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_class_label(Arg_&& arg, Args_... args);
  std::string* mutable_class_label();
  PROTOBUF_NODISCARD std::string* release_class_label();
  void set_allocated_class_label(std::string* value);

  private:
  const std::string& _internal_class_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_label(
      const std::string& value);
  std::string* _internal_mutable_class_label();

  public:
  // optional bytes userinfo = 17 [ctype = CORD];
  bool has_userinfo() const;
  void clear_userinfo() ;
  const ::absl::Cord& userinfo() const;
  void set_userinfo(const ::absl::Cord& value);
  void set_userinfo(::absl::string_view value);
  private:
  const ::absl::Cord& _internal_userinfo() const;
  void _internal_set_userinfo(const ::absl::Cord& value);
  ::absl::Cord* _internal_mutable_userinfo();
  public:
  // optional .research_scann.GenericFeatureVector.RestrictTokens restrict_tokens = 15;
  bool has_restrict_tokens() const;
  void clear_restrict_tokens() ;
  const ::research_scann::GenericFeatureVector_RestrictTokens& restrict_tokens() const;
  PROTOBUF_NODISCARD ::research_scann::GenericFeatureVector_RestrictTokens* release_restrict_tokens();
  ::research_scann::GenericFeatureVector_RestrictTokens* mutable_restrict_tokens();
  void set_allocated_restrict_tokens(::research_scann::GenericFeatureVector_RestrictTokens* value);
  void unsafe_arena_set_allocated_restrict_tokens(::research_scann::GenericFeatureVector_RestrictTokens* value);
  ::research_scann::GenericFeatureVector_RestrictTokens* unsafe_arena_release_restrict_tokens();

  private:
  const ::research_scann::GenericFeatureVector_RestrictTokens& _internal_restrict_tokens() const;
  ::research_scann::GenericFeatureVector_RestrictTokens* _internal_mutable_restrict_tokens();

  public:
  // optional .research_scann.GenericFeatureVector.Crowding crowding = 18;
  bool has_crowding() const;
  void clear_crowding() ;
  const ::research_scann::GenericFeatureVector_Crowding& crowding() const;
  PROTOBUF_NODISCARD ::research_scann::GenericFeatureVector_Crowding* release_crowding();
  ::research_scann::GenericFeatureVector_Crowding* mutable_crowding();
  void set_allocated_crowding(::research_scann::GenericFeatureVector_Crowding* value);
  void unsafe_arena_set_allocated_crowding(::research_scann::GenericFeatureVector_Crowding* value);
  ::research_scann::GenericFeatureVector_Crowding* unsafe_arena_release_crowding();

  private:
  const ::research_scann::GenericFeatureVector_Crowding& _internal_crowding() const;
  ::research_scann::GenericFeatureVector_Crowding* _internal_mutable_crowding();

  public:
  // optional .research_scann.GenericFeatureVector.FixedPointMetadata fixed_point_metadata = 19;
  bool has_fixed_point_metadata() const;
  void clear_fixed_point_metadata() ;
  const ::research_scann::GenericFeatureVector_FixedPointMetadata& fixed_point_metadata() const;
  PROTOBUF_NODISCARD ::research_scann::GenericFeatureVector_FixedPointMetadata* release_fixed_point_metadata();
  ::research_scann::GenericFeatureVector_FixedPointMetadata* mutable_fixed_point_metadata();
  void set_allocated_fixed_point_metadata(::research_scann::GenericFeatureVector_FixedPointMetadata* value);
  void unsafe_arena_set_allocated_fixed_point_metadata(::research_scann::GenericFeatureVector_FixedPointMetadata* value);
  ::research_scann::GenericFeatureVector_FixedPointMetadata* unsafe_arena_release_fixed_point_metadata();

  private:
  const ::research_scann::GenericFeatureVector_FixedPointMetadata& _internal_fixed_point_metadata() const;
  ::research_scann::GenericFeatureVector_FixedPointMetadata* _internal_mutable_fixed_point_metadata();

  public:
  // optional .google.protobuf.Timestamp expiration_timestamp = 20;
  bool has_expiration_timestamp() const;
  void clear_expiration_timestamp() ;
  const ::google::protobuf::Timestamp& expiration_timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_expiration_timestamp();
  ::google::protobuf::Timestamp* mutable_expiration_timestamp();
  void set_allocated_expiration_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expiration_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expiration_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_expiration_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_expiration_timestamp();

  public:
  // required .research_scann.GenericFeatureVector.FeatureType feature_type = 1;
  bool has_feature_type() const;
  void clear_feature_type() ;
  ::research_scann::GenericFeatureVector_FeatureType feature_type() const;
  void set_feature_type(::research_scann::GenericFeatureVector_FeatureType value);

  private:
  ::research_scann::GenericFeatureVector_FeatureType _internal_feature_type() const;
  void _internal_set_feature_type(::research_scann::GenericFeatureVector_FeatureType value);

  public:
  // optional float weight = 8 [deprecated = true];
  [[deprecated]]  bool has_weight() const;
  [[deprecated]]  void clear_weight() ;
  [[deprecated]] float weight() const;
  [[deprecated]] void set_weight(float value);

  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);

  public:
  // optional .research_scann.GenericFeatureVector.FeatureNorm norm_type = 9 [default = NONE];
  bool has_norm_type() const;
  void clear_norm_type() ;
  ::research_scann::GenericFeatureVector_FeatureNorm norm_type() const;
  void set_norm_type(::research_scann::GenericFeatureVector_FeatureNorm value);

  private:
  ::research_scann::GenericFeatureVector_FeatureNorm _internal_norm_type() const;
  void _internal_set_norm_type(::research_scann::GenericFeatureVector_FeatureNorm value);

  public:
  // optional uint64 feature_dim = 10 [default = 18446744073709551615, deprecated = true];
  [[deprecated]]  bool has_feature_dim() const;
  [[deprecated]]  void clear_feature_dim() ;
  [[deprecated]] ::uint64_t feature_dim() const;
  [[deprecated]] void set_feature_dim(::uint64_t value);

  private:
  ::uint64_t _internal_feature_dim() const;
  void _internal_set_feature_dim(::uint64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<GenericFeatureVector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:research_scann.GenericFeatureVector)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 17, 6,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ExtensionSet _extensions_;

    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> feature_value_int64_;
    mutable ::google::protobuf::internal::CachedSize _feature_value_int64_cached_byte_size_;
    ::google::protobuf::RepeatedField<float> feature_value_float_;
    ::google::protobuf::RepeatedField<double> feature_value_double_;
    ::google::protobuf::RepeatedField<::uint64_t> feature_index_;
    mutable ::google::protobuf::internal::CachedSize _feature_index_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> tokens_;
    mutable ::google::protobuf::internal::CachedSize _tokens_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr data_id_str_;
    ::google::protobuf::internal::ArenaStringPtr feature_value_string_;
    ::google::protobuf::internal::ArenaStringPtr class_label_;
    ::absl::Cord userinfo_;
    ::research_scann::GenericFeatureVector_RestrictTokens* restrict_tokens_;
    ::research_scann::GenericFeatureVector_Crowding* crowding_;
    ::research_scann::GenericFeatureVector_FixedPointMetadata* fixed_point_metadata_;
    ::google::protobuf::Timestamp* expiration_timestamp_;
    int feature_type_;
    float weight_;
    int norm_type_;
    ::uint64_t feature_dim_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fdata_5fformat_2ffeatures_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GenericFeatureVector_Crowding

// optional int64 crowding_attribute = 1;
inline bool GenericFeatureVector_Crowding::has_crowding_attribute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericFeatureVector_Crowding::clear_crowding_attribute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crowding_attribute_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t GenericFeatureVector_Crowding::crowding_attribute() const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.Crowding.crowding_attribute)
  return _internal_crowding_attribute();
}
inline void GenericFeatureVector_Crowding::set_crowding_attribute(::int64_t value) {
  _internal_set_crowding_attribute(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.Crowding.crowding_attribute)
}
inline ::int64_t GenericFeatureVector_Crowding::_internal_crowding_attribute() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crowding_attribute_;
}
inline void GenericFeatureVector_Crowding::_internal_set_crowding_attribute(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.crowding_attribute_ = value;
}

// -------------------------------------------------------------------

// GenericFeatureVector_RestrictTokens

// optional .research_scann.V3Restrict v3 = 7;
inline bool GenericFeatureVector_RestrictTokens::has_v3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v3_ != nullptr);
  return value;
}
inline const ::research_scann::V3Restrict& GenericFeatureVector_RestrictTokens::_internal_v3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::V3Restrict* p = _impl_.v3_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::V3Restrict&>(::research_scann::_V3Restrict_default_instance_);
}
inline const ::research_scann::V3Restrict& GenericFeatureVector_RestrictTokens::v3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.v3)
  return _internal_v3();
}
inline void GenericFeatureVector_RestrictTokens::unsafe_arena_set_allocated_v3(::research_scann::V3Restrict* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v3_);
  }
  _impl_.v3_ = reinterpret_cast<::research_scann::V3Restrict*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.RestrictTokens.v3)
}
inline ::research_scann::V3Restrict* GenericFeatureVector_RestrictTokens::release_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::research_scann::V3Restrict* released = _impl_.v3_;
  _impl_.v3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::V3Restrict* GenericFeatureVector_RestrictTokens::unsafe_arena_release_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.RestrictTokens.v3)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::research_scann::V3Restrict* temp = _impl_.v3_;
  _impl_.v3_ = nullptr;
  return temp;
}
inline ::research_scann::V3Restrict* GenericFeatureVector_RestrictTokens::_internal_mutable_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.v3_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::V3Restrict>(GetArena());
    _impl_.v3_ = reinterpret_cast<::research_scann::V3Restrict*>(p);
  }
  return _impl_.v3_;
}
inline ::research_scann::V3Restrict* GenericFeatureVector_RestrictTokens::mutable_v3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::V3Restrict* _msg = _internal_mutable_v3();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.RestrictTokens.v3)
  return _msg;
}
inline void GenericFeatureVector_RestrictTokens::set_allocated_v3(::research_scann::V3Restrict* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.v3_ = reinterpret_cast<::research_scann::V3Restrict*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.RestrictTokens.v3)
}

// repeated int64 token_membership = 1 [packed = true];
inline int GenericFeatureVector_RestrictTokens::_internal_token_membership_size() const {
  return _internal_token_membership().size();
}
inline int GenericFeatureVector_RestrictTokens::token_membership_size() const {
  return _internal_token_membership_size();
}
inline void GenericFeatureVector_RestrictTokens::clear_token_membership() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_membership_.Clear();
}
inline ::int64_t GenericFeatureVector_RestrictTokens::token_membership(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.token_membership)
  return _internal_token_membership().Get(index);
}
inline void GenericFeatureVector_RestrictTokens::set_token_membership(int index, ::int64_t value) {
  _internal_mutable_token_membership()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.RestrictTokens.token_membership)
}
inline void GenericFeatureVector_RestrictTokens::add_token_membership(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_token_membership()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.RestrictTokens.token_membership)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector_RestrictTokens::token_membership() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.RestrictTokens.token_membership)
  return _internal_token_membership();
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector_RestrictTokens::mutable_token_membership()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.RestrictTokens.token_membership)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_token_membership();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector_RestrictTokens::_internal_token_membership()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_membership_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector_RestrictTokens::_internal_mutable_token_membership() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.token_membership_;
}

// repeated int64 whitelist_token = 2 [packed = true];
inline int GenericFeatureVector_RestrictTokens::_internal_whitelist_token_size() const {
  return _internal_whitelist_token().size();
}
inline int GenericFeatureVector_RestrictTokens::whitelist_token_size() const {
  return _internal_whitelist_token_size();
}
inline void GenericFeatureVector_RestrictTokens::clear_whitelist_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.whitelist_token_.Clear();
}
inline ::int64_t GenericFeatureVector_RestrictTokens::whitelist_token(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.whitelist_token)
  return _internal_whitelist_token().Get(index);
}
inline void GenericFeatureVector_RestrictTokens::set_whitelist_token(int index, ::int64_t value) {
  _internal_mutable_whitelist_token()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.RestrictTokens.whitelist_token)
}
inline void GenericFeatureVector_RestrictTokens::add_whitelist_token(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_whitelist_token()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.RestrictTokens.whitelist_token)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector_RestrictTokens::whitelist_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.RestrictTokens.whitelist_token)
  return _internal_whitelist_token();
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector_RestrictTokens::mutable_whitelist_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.RestrictTokens.whitelist_token)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_whitelist_token();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector_RestrictTokens::_internal_whitelist_token()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.whitelist_token_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector_RestrictTokens::_internal_mutable_whitelist_token() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.whitelist_token_;
}

// repeated int64 blacklist_token = 3 [packed = true];
inline int GenericFeatureVector_RestrictTokens::_internal_blacklist_token_size() const {
  return _internal_blacklist_token().size();
}
inline int GenericFeatureVector_RestrictTokens::blacklist_token_size() const {
  return _internal_blacklist_token_size();
}
inline void GenericFeatureVector_RestrictTokens::clear_blacklist_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blacklist_token_.Clear();
}
inline ::int64_t GenericFeatureVector_RestrictTokens::blacklist_token(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.blacklist_token)
  return _internal_blacklist_token().Get(index);
}
inline void GenericFeatureVector_RestrictTokens::set_blacklist_token(int index, ::int64_t value) {
  _internal_mutable_blacklist_token()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.RestrictTokens.blacklist_token)
}
inline void GenericFeatureVector_RestrictTokens::add_blacklist_token(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_blacklist_token()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.RestrictTokens.blacklist_token)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector_RestrictTokens::blacklist_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.RestrictTokens.blacklist_token)
  return _internal_blacklist_token();
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector_RestrictTokens::mutable_blacklist_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.RestrictTokens.blacklist_token)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_blacklist_token();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector_RestrictTokens::_internal_blacklist_token()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blacklist_token_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector_RestrictTokens::_internal_mutable_blacklist_token() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.blacklist_token_;
}

// .research_scann.coscann.EasyRestrictDefinition easy_definition = 6;
inline bool GenericFeatureVector_RestrictTokens::has_easy_definition() const {
  return v2_restricts_case() == kEasyDefinition;
}
inline bool GenericFeatureVector_RestrictTokens::_internal_has_easy_definition() const {
  return v2_restricts_case() == kEasyDefinition;
}
inline void GenericFeatureVector_RestrictTokens::set_has_easy_definition() {
  _impl_._oneof_case_[0] = kEasyDefinition;
}
inline ::research_scann::coscann::EasyRestrictDefinition* GenericFeatureVector_RestrictTokens::release_easy_definition() {
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.RestrictTokens.easy_definition)
  if (v2_restricts_case() == kEasyDefinition) {
    clear_has_v2_restricts();
    auto* temp = _impl_.v2_restricts_.easy_definition_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.v2_restricts_.easy_definition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::research_scann::coscann::EasyRestrictDefinition& GenericFeatureVector_RestrictTokens::_internal_easy_definition() const {
  return v2_restricts_case() == kEasyDefinition ? *_impl_.v2_restricts_.easy_definition_ : reinterpret_cast<::research_scann::coscann::EasyRestrictDefinition&>(::research_scann::coscann::_EasyRestrictDefinition_default_instance_);
}
inline const ::research_scann::coscann::EasyRestrictDefinition& GenericFeatureVector_RestrictTokens::easy_definition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.easy_definition)
  return _internal_easy_definition();
}
inline ::research_scann::coscann::EasyRestrictDefinition* GenericFeatureVector_RestrictTokens::unsafe_arena_release_easy_definition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:research_scann.GenericFeatureVector.RestrictTokens.easy_definition)
  if (v2_restricts_case() == kEasyDefinition) {
    clear_has_v2_restricts();
    auto* temp = _impl_.v2_restricts_.easy_definition_;
    _impl_.v2_restricts_.easy_definition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericFeatureVector_RestrictTokens::unsafe_arena_set_allocated_easy_definition(::research_scann::coscann::EasyRestrictDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_v2_restricts();
  if (value) {
    set_has_easy_definition();
    _impl_.v2_restricts_.easy_definition_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.RestrictTokens.easy_definition)
}
inline ::research_scann::coscann::EasyRestrictDefinition* GenericFeatureVector_RestrictTokens::_internal_mutable_easy_definition() {
  if (v2_restricts_case() != kEasyDefinition) {
    clear_v2_restricts();
    set_has_easy_definition();
    _impl_.v2_restricts_.easy_definition_ = CreateMaybeMessage<::research_scann::coscann::EasyRestrictDefinition>(GetArena());
  }
  return _impl_.v2_restricts_.easy_definition_;
}
inline ::research_scann::coscann::EasyRestrictDefinition* GenericFeatureVector_RestrictTokens::mutable_easy_definition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::coscann::EasyRestrictDefinition* _msg = _internal_mutable_easy_definition();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.RestrictTokens.easy_definition)
  return _msg;
}

// .research_scann.coscann.RestrictTokensV2 tokens = 5;
inline bool GenericFeatureVector_RestrictTokens::has_tokens() const {
  return v2_restricts_case() == kTokens;
}
inline bool GenericFeatureVector_RestrictTokens::_internal_has_tokens() const {
  return v2_restricts_case() == kTokens;
}
inline void GenericFeatureVector_RestrictTokens::set_has_tokens() {
  _impl_._oneof_case_[0] = kTokens;
}
inline ::research_scann::coscann::RestrictTokensV2* GenericFeatureVector_RestrictTokens::release_tokens() {
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.RestrictTokens.tokens)
  if (v2_restricts_case() == kTokens) {
    clear_has_v2_restricts();
    auto* temp = _impl_.v2_restricts_.tokens_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.v2_restricts_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::research_scann::coscann::RestrictTokensV2& GenericFeatureVector_RestrictTokens::_internal_tokens() const {
  return v2_restricts_case() == kTokens ? *_impl_.v2_restricts_.tokens_ : reinterpret_cast<::research_scann::coscann::RestrictTokensV2&>(::research_scann::coscann::_RestrictTokensV2_default_instance_);
}
inline const ::research_scann::coscann::RestrictTokensV2& GenericFeatureVector_RestrictTokens::tokens() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.tokens)
  return _internal_tokens();
}
inline ::research_scann::coscann::RestrictTokensV2* GenericFeatureVector_RestrictTokens::unsafe_arena_release_tokens() {
  // @@protoc_insertion_point(field_unsafe_arena_release:research_scann.GenericFeatureVector.RestrictTokens.tokens)
  if (v2_restricts_case() == kTokens) {
    clear_has_v2_restricts();
    auto* temp = _impl_.v2_restricts_.tokens_;
    _impl_.v2_restricts_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericFeatureVector_RestrictTokens::unsafe_arena_set_allocated_tokens(::research_scann::coscann::RestrictTokensV2* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_v2_restricts();
  if (value) {
    set_has_tokens();
    _impl_.v2_restricts_.tokens_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.RestrictTokens.tokens)
}
inline ::research_scann::coscann::RestrictTokensV2* GenericFeatureVector_RestrictTokens::_internal_mutable_tokens() {
  if (v2_restricts_case() != kTokens) {
    clear_v2_restricts();
    set_has_tokens();
    _impl_.v2_restricts_.tokens_ = CreateMaybeMessage<::research_scann::coscann::RestrictTokensV2>(GetArena());
  }
  return _impl_.v2_restricts_.tokens_;
}
inline ::research_scann::coscann::RestrictTokensV2* GenericFeatureVector_RestrictTokens::mutable_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::coscann::RestrictTokensV2* _msg = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.RestrictTokens.tokens)
  return _msg;
}

// .research_scann.coscann.RestrictDefinition definition = 4;
inline bool GenericFeatureVector_RestrictTokens::has_definition() const {
  return v2_restricts_case() == kDefinition;
}
inline bool GenericFeatureVector_RestrictTokens::_internal_has_definition() const {
  return v2_restricts_case() == kDefinition;
}
inline void GenericFeatureVector_RestrictTokens::set_has_definition() {
  _impl_._oneof_case_[0] = kDefinition;
}
inline ::research_scann::coscann::RestrictDefinition* GenericFeatureVector_RestrictTokens::release_definition() {
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.RestrictTokens.definition)
  if (v2_restricts_case() == kDefinition) {
    clear_has_v2_restricts();
    auto* temp = _impl_.v2_restricts_.definition_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.v2_restricts_.definition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::research_scann::coscann::RestrictDefinition& GenericFeatureVector_RestrictTokens::_internal_definition() const {
  return v2_restricts_case() == kDefinition ? *_impl_.v2_restricts_.definition_ : reinterpret_cast<::research_scann::coscann::RestrictDefinition&>(::research_scann::coscann::_RestrictDefinition_default_instance_);
}
inline const ::research_scann::coscann::RestrictDefinition& GenericFeatureVector_RestrictTokens::definition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.definition)
  return _internal_definition();
}
inline ::research_scann::coscann::RestrictDefinition* GenericFeatureVector_RestrictTokens::unsafe_arena_release_definition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:research_scann.GenericFeatureVector.RestrictTokens.definition)
  if (v2_restricts_case() == kDefinition) {
    clear_has_v2_restricts();
    auto* temp = _impl_.v2_restricts_.definition_;
    _impl_.v2_restricts_.definition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericFeatureVector_RestrictTokens::unsafe_arena_set_allocated_definition(::research_scann::coscann::RestrictDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_v2_restricts();
  if (value) {
    set_has_definition();
    _impl_.v2_restricts_.definition_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.RestrictTokens.definition)
}
inline ::research_scann::coscann::RestrictDefinition* GenericFeatureVector_RestrictTokens::_internal_mutable_definition() {
  if (v2_restricts_case() != kDefinition) {
    clear_v2_restricts();
    set_has_definition();
    _impl_.v2_restricts_.definition_ = CreateMaybeMessage<::research_scann::coscann::RestrictDefinition>(GetArena());
  }
  return _impl_.v2_restricts_.definition_;
}
inline ::research_scann::coscann::RestrictDefinition* GenericFeatureVector_RestrictTokens::mutable_definition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::coscann::RestrictDefinition* _msg = _internal_mutable_definition();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.RestrictTokens.definition)
  return _msg;
}

// optional string v3_compatible_namespace = 8;
inline bool GenericFeatureVector_RestrictTokens::has_v3_compatible_namespace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericFeatureVector_RestrictTokens::clear_v3_compatible_namespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.v3_compatible_namespace_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericFeatureVector_RestrictTokens::v3_compatible_namespace() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.RestrictTokens.v3_compatible_namespace)
  return _internal_v3_compatible_namespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericFeatureVector_RestrictTokens::set_v3_compatible_namespace(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.v3_compatible_namespace_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.RestrictTokens.v3_compatible_namespace)
}
inline std::string* GenericFeatureVector_RestrictTokens::mutable_v3_compatible_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_v3_compatible_namespace();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.RestrictTokens.v3_compatible_namespace)
  return _s;
}
inline const std::string& GenericFeatureVector_RestrictTokens::_internal_v3_compatible_namespace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.v3_compatible_namespace_.Get();
}
inline void GenericFeatureVector_RestrictTokens::_internal_set_v3_compatible_namespace(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.v3_compatible_namespace_.Set(value, GetArena());
}
inline std::string* GenericFeatureVector_RestrictTokens::_internal_mutable_v3_compatible_namespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.v3_compatible_namespace_.Mutable( GetArena());
}
inline std::string* GenericFeatureVector_RestrictTokens::release_v3_compatible_namespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.RestrictTokens.v3_compatible_namespace)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.v3_compatible_namespace_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.v3_compatible_namespace_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericFeatureVector_RestrictTokens::set_allocated_v3_compatible_namespace(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.v3_compatible_namespace_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.v3_compatible_namespace_.IsDefault()) {
          _impl_.v3_compatible_namespace_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.RestrictTokens.v3_compatible_namespace)
}

inline bool GenericFeatureVector_RestrictTokens::has_v2_restricts() const {
  return v2_restricts_case() != V2_RESTRICTS_NOT_SET;
}
inline void GenericFeatureVector_RestrictTokens::clear_has_v2_restricts() {
  _impl_._oneof_case_[0] = V2_RESTRICTS_NOT_SET;
}
inline GenericFeatureVector_RestrictTokens::V2RestrictsCase GenericFeatureVector_RestrictTokens::v2_restricts_case() const {
  return GenericFeatureVector_RestrictTokens::V2RestrictsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GenericFeatureVector_FixedPointMetadata

// optional float squared_l2_norm = 1;
inline bool GenericFeatureVector_FixedPointMetadata::has_squared_l2_norm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericFeatureVector_FixedPointMetadata::clear_squared_l2_norm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.squared_l2_norm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float GenericFeatureVector_FixedPointMetadata::squared_l2_norm() const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.FixedPointMetadata.squared_l2_norm)
  return _internal_squared_l2_norm();
}
inline void GenericFeatureVector_FixedPointMetadata::set_squared_l2_norm(float value) {
  _internal_set_squared_l2_norm(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.FixedPointMetadata.squared_l2_norm)
}
inline float GenericFeatureVector_FixedPointMetadata::_internal_squared_l2_norm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.squared_l2_norm_;
}
inline void GenericFeatureVector_FixedPointMetadata::_internal_set_squared_l2_norm(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.squared_l2_norm_ = value;
}

// -------------------------------------------------------------------

// GenericFeatureVector

// required .research_scann.GenericFeatureVector.FeatureType feature_type = 1;
inline bool GenericFeatureVector::has_feature_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_feature_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::research_scann::GenericFeatureVector_FeatureType GenericFeatureVector::feature_type() const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_type)
  return _internal_feature_type();
}
inline void GenericFeatureVector::set_feature_type(::research_scann::GenericFeatureVector_FeatureType value) {
  _internal_set_feature_type(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_type)
}
inline ::research_scann::GenericFeatureVector_FeatureType GenericFeatureVector::_internal_feature_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::GenericFeatureVector_FeatureType>(_impl_.feature_type_);
}
inline void GenericFeatureVector::_internal_set_feature_type(::research_scann::GenericFeatureVector_FeatureType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::GenericFeatureVector_FeatureType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.feature_type_ = value;
}

// optional bytes data_id_str = 2;
inline bool GenericFeatureVector::has_data_id_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_data_id_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_id_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericFeatureVector::data_id_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.data_id_str)
  return _internal_data_id_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericFeatureVector::set_data_id_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_id_str_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.data_id_str)
}
inline std::string* GenericFeatureVector::mutable_data_id_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_id_str();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.data_id_str)
  return _s;
}
inline const std::string& GenericFeatureVector::_internal_data_id_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_id_str_.Get();
}
inline void GenericFeatureVector::_internal_set_data_id_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_id_str_.Set(value, GetArena());
}
inline std::string* GenericFeatureVector::_internal_mutable_data_id_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_id_str_.Mutable( GetArena());
}
inline std::string* GenericFeatureVector::release_data_id_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.data_id_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_id_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_id_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericFeatureVector::set_allocated_data_id_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_id_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_id_str_.IsDefault()) {
          _impl_.data_id_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.data_id_str)
}

// repeated float feature_value_float = 4 [packed = true];
inline int GenericFeatureVector::_internal_feature_value_float_size() const {
  return _internal_feature_value_float().size();
}
inline int GenericFeatureVector::feature_value_float_size() const {
  return _internal_feature_value_float_size();
}
inline void GenericFeatureVector::clear_feature_value_float() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_value_float_.Clear();
}
inline float GenericFeatureVector::feature_value_float(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_value_float)
  return _internal_feature_value_float().Get(index);
}
inline void GenericFeatureVector::set_feature_value_float(int index, float value) {
  _internal_mutable_feature_value_float()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_value_float)
}
inline void GenericFeatureVector::add_feature_value_float(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_feature_value_float()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.feature_value_float)
}
inline const ::google::protobuf::RepeatedField<float>& GenericFeatureVector::feature_value_float() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.feature_value_float)
  return _internal_feature_value_float();
}
inline ::google::protobuf::RepeatedField<float>* GenericFeatureVector::mutable_feature_value_float()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.feature_value_float)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_feature_value_float();
}
inline const ::google::protobuf::RepeatedField<float>& GenericFeatureVector::_internal_feature_value_float()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feature_value_float_;
}
inline ::google::protobuf::RepeatedField<float>* GenericFeatureVector::_internal_mutable_feature_value_float() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.feature_value_float_;
}

// repeated double feature_value_double = 5 [packed = true];
inline int GenericFeatureVector::_internal_feature_value_double_size() const {
  return _internal_feature_value_double().size();
}
inline int GenericFeatureVector::feature_value_double_size() const {
  return _internal_feature_value_double_size();
}
inline void GenericFeatureVector::clear_feature_value_double() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_value_double_.Clear();
}
inline double GenericFeatureVector::feature_value_double(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_value_double)
  return _internal_feature_value_double().Get(index);
}
inline void GenericFeatureVector::set_feature_value_double(int index, double value) {
  _internal_mutable_feature_value_double()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_value_double)
}
inline void GenericFeatureVector::add_feature_value_double(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_feature_value_double()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.feature_value_double)
}
inline const ::google::protobuf::RepeatedField<double>& GenericFeatureVector::feature_value_double() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.feature_value_double)
  return _internal_feature_value_double();
}
inline ::google::protobuf::RepeatedField<double>* GenericFeatureVector::mutable_feature_value_double()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.feature_value_double)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_feature_value_double();
}
inline const ::google::protobuf::RepeatedField<double>& GenericFeatureVector::_internal_feature_value_double()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feature_value_double_;
}
inline ::google::protobuf::RepeatedField<double>* GenericFeatureVector::_internal_mutable_feature_value_double() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.feature_value_double_;
}

// repeated int64 feature_value_int64 = 3 [packed = true];
inline int GenericFeatureVector::_internal_feature_value_int64_size() const {
  return _internal_feature_value_int64().size();
}
inline int GenericFeatureVector::feature_value_int64_size() const {
  return _internal_feature_value_int64_size();
}
inline void GenericFeatureVector::clear_feature_value_int64() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_value_int64_.Clear();
}
inline ::int64_t GenericFeatureVector::feature_value_int64(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_value_int64)
  return _internal_feature_value_int64().Get(index);
}
inline void GenericFeatureVector::set_feature_value_int64(int index, ::int64_t value) {
  _internal_mutable_feature_value_int64()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_value_int64)
}
inline void GenericFeatureVector::add_feature_value_int64(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_feature_value_int64()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.feature_value_int64)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector::feature_value_int64() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.feature_value_int64)
  return _internal_feature_value_int64();
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector::mutable_feature_value_int64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.feature_value_int64)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_feature_value_int64();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& GenericFeatureVector::_internal_feature_value_int64()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feature_value_int64_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* GenericFeatureVector::_internal_mutable_feature_value_int64() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.feature_value_int64_;
}

// optional bytes feature_value_string = 13;
inline bool GenericFeatureVector::has_feature_value_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_feature_value_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_value_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericFeatureVector::feature_value_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_value_string)
  return _internal_feature_value_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericFeatureVector::set_feature_value_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.feature_value_string_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_value_string)
}
inline std::string* GenericFeatureVector::mutable_feature_value_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_feature_value_string();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.feature_value_string)
  return _s;
}
inline const std::string& GenericFeatureVector::_internal_feature_value_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feature_value_string_.Get();
}
inline void GenericFeatureVector::_internal_set_feature_value_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.feature_value_string_.Set(value, GetArena());
}
inline std::string* GenericFeatureVector::_internal_mutable_feature_value_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.feature_value_string_.Mutable( GetArena());
}
inline std::string* GenericFeatureVector::release_feature_value_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.feature_value_string)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.feature_value_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.feature_value_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericFeatureVector::set_allocated_feature_value_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.feature_value_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feature_value_string_.IsDefault()) {
          _impl_.feature_value_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.feature_value_string)
}

// repeated uint64 feature_index = 6 [packed = true];
inline int GenericFeatureVector::_internal_feature_index_size() const {
  return _internal_feature_index().size();
}
inline int GenericFeatureVector::feature_index_size() const {
  return _internal_feature_index_size();
}
inline void GenericFeatureVector::clear_feature_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_index_.Clear();
}
inline ::uint64_t GenericFeatureVector::feature_index(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_index)
  return _internal_feature_index().Get(index);
}
inline void GenericFeatureVector::set_feature_index(int index, ::uint64_t value) {
  _internal_mutable_feature_index()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_index)
}
inline void GenericFeatureVector::add_feature_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_feature_index()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.feature_index)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GenericFeatureVector::feature_index() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.feature_index)
  return _internal_feature_index();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GenericFeatureVector::mutable_feature_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.feature_index)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_feature_index();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GenericFeatureVector::_internal_feature_index()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feature_index_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GenericFeatureVector::_internal_mutable_feature_index() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.feature_index_;
}

// optional .research_scann.GenericFeatureVector.FeatureNorm norm_type = 9 [default = NONE];
inline bool GenericFeatureVector::has_norm_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_norm_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norm_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::research_scann::GenericFeatureVector_FeatureNorm GenericFeatureVector::norm_type() const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.norm_type)
  return _internal_norm_type();
}
inline void GenericFeatureVector::set_norm_type(::research_scann::GenericFeatureVector_FeatureNorm value) {
  _internal_set_norm_type(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.norm_type)
}
inline ::research_scann::GenericFeatureVector_FeatureNorm GenericFeatureVector::_internal_norm_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::GenericFeatureVector_FeatureNorm>(_impl_.norm_type_);
}
inline void GenericFeatureVector::_internal_set_norm_type(::research_scann::GenericFeatureVector_FeatureNorm value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::GenericFeatureVector_FeatureNorm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.norm_type_ = value;
}

// optional string class_label = 16;
inline bool GenericFeatureVector::has_class_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_class_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericFeatureVector::class_label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.class_label)
  return _internal_class_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericFeatureVector::set_class_label(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.class_label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.class_label)
}
inline std::string* GenericFeatureVector::mutable_class_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_class_label();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.class_label)
  return _s;
}
inline const std::string& GenericFeatureVector::_internal_class_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.class_label_.Get();
}
inline void GenericFeatureVector::_internal_set_class_label(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.class_label_.Set(value, GetArena());
}
inline std::string* GenericFeatureVector::_internal_mutable_class_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.class_label_.Mutable( GetArena());
}
inline std::string* GenericFeatureVector::release_class_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.class_label)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.class_label_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.class_label_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericFeatureVector::set_allocated_class_label(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.class_label_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_label_.IsDefault()) {
          _impl_.class_label_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.class_label)
}

// optional .research_scann.GenericFeatureVector.Crowding crowding = 18;
inline bool GenericFeatureVector::has_crowding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crowding_ != nullptr);
  return value;
}
inline void GenericFeatureVector::clear_crowding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.crowding_ != nullptr) _impl_.crowding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::research_scann::GenericFeatureVector_Crowding& GenericFeatureVector::_internal_crowding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::GenericFeatureVector_Crowding* p = _impl_.crowding_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::GenericFeatureVector_Crowding&>(::research_scann::_GenericFeatureVector_Crowding_default_instance_);
}
inline const ::research_scann::GenericFeatureVector_Crowding& GenericFeatureVector::crowding() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.crowding)
  return _internal_crowding();
}
inline void GenericFeatureVector::unsafe_arena_set_allocated_crowding(::research_scann::GenericFeatureVector_Crowding* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.crowding_);
  }
  _impl_.crowding_ = reinterpret_cast<::research_scann::GenericFeatureVector_Crowding*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.crowding)
}
inline ::research_scann::GenericFeatureVector_Crowding* GenericFeatureVector::release_crowding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::GenericFeatureVector_Crowding* released = _impl_.crowding_;
  _impl_.crowding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::GenericFeatureVector_Crowding* GenericFeatureVector::unsafe_arena_release_crowding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.crowding)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::GenericFeatureVector_Crowding* temp = _impl_.crowding_;
  _impl_.crowding_ = nullptr;
  return temp;
}
inline ::research_scann::GenericFeatureVector_Crowding* GenericFeatureVector::_internal_mutable_crowding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.crowding_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::GenericFeatureVector_Crowding>(GetArena());
    _impl_.crowding_ = reinterpret_cast<::research_scann::GenericFeatureVector_Crowding*>(p);
  }
  return _impl_.crowding_;
}
inline ::research_scann::GenericFeatureVector_Crowding* GenericFeatureVector::mutable_crowding() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::GenericFeatureVector_Crowding* _msg = _internal_mutable_crowding();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.crowding)
  return _msg;
}
inline void GenericFeatureVector::set_allocated_crowding(::research_scann::GenericFeatureVector_Crowding* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::GenericFeatureVector_Crowding*>(_impl_.crowding_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::GenericFeatureVector_Crowding*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.crowding_ = reinterpret_cast<::research_scann::GenericFeatureVector_Crowding*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.crowding)
}

// optional .research_scann.GenericFeatureVector.RestrictTokens restrict_tokens = 15;
inline bool GenericFeatureVector::has_restrict_tokens() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.restrict_tokens_ != nullptr);
  return value;
}
inline void GenericFeatureVector::clear_restrict_tokens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.restrict_tokens_ != nullptr) _impl_.restrict_tokens_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::research_scann::GenericFeatureVector_RestrictTokens& GenericFeatureVector::_internal_restrict_tokens() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::GenericFeatureVector_RestrictTokens* p = _impl_.restrict_tokens_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::GenericFeatureVector_RestrictTokens&>(::research_scann::_GenericFeatureVector_RestrictTokens_default_instance_);
}
inline const ::research_scann::GenericFeatureVector_RestrictTokens& GenericFeatureVector::restrict_tokens() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.restrict_tokens)
  return _internal_restrict_tokens();
}
inline void GenericFeatureVector::unsafe_arena_set_allocated_restrict_tokens(::research_scann::GenericFeatureVector_RestrictTokens* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.restrict_tokens_);
  }
  _impl_.restrict_tokens_ = reinterpret_cast<::research_scann::GenericFeatureVector_RestrictTokens*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.restrict_tokens)
}
inline ::research_scann::GenericFeatureVector_RestrictTokens* GenericFeatureVector::release_restrict_tokens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::research_scann::GenericFeatureVector_RestrictTokens* released = _impl_.restrict_tokens_;
  _impl_.restrict_tokens_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::GenericFeatureVector_RestrictTokens* GenericFeatureVector::unsafe_arena_release_restrict_tokens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.restrict_tokens)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::research_scann::GenericFeatureVector_RestrictTokens* temp = _impl_.restrict_tokens_;
  _impl_.restrict_tokens_ = nullptr;
  return temp;
}
inline ::research_scann::GenericFeatureVector_RestrictTokens* GenericFeatureVector::_internal_mutable_restrict_tokens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.restrict_tokens_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::GenericFeatureVector_RestrictTokens>(GetArena());
    _impl_.restrict_tokens_ = reinterpret_cast<::research_scann::GenericFeatureVector_RestrictTokens*>(p);
  }
  return _impl_.restrict_tokens_;
}
inline ::research_scann::GenericFeatureVector_RestrictTokens* GenericFeatureVector::mutable_restrict_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::GenericFeatureVector_RestrictTokens* _msg = _internal_mutable_restrict_tokens();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.restrict_tokens)
  return _msg;
}
inline void GenericFeatureVector::set_allocated_restrict_tokens(::research_scann::GenericFeatureVector_RestrictTokens* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::GenericFeatureVector_RestrictTokens*>(_impl_.restrict_tokens_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::GenericFeatureVector_RestrictTokens*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.restrict_tokens_ = reinterpret_cast<::research_scann::GenericFeatureVector_RestrictTokens*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.restrict_tokens)
}

// optional .research_scann.GenericFeatureVector.FixedPointMetadata fixed_point_metadata = 19;
inline bool GenericFeatureVector::has_fixed_point_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fixed_point_metadata_ != nullptr);
  return value;
}
inline void GenericFeatureVector::clear_fixed_point_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fixed_point_metadata_ != nullptr) _impl_.fixed_point_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::research_scann::GenericFeatureVector_FixedPointMetadata& GenericFeatureVector::_internal_fixed_point_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::GenericFeatureVector_FixedPointMetadata* p = _impl_.fixed_point_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::GenericFeatureVector_FixedPointMetadata&>(::research_scann::_GenericFeatureVector_FixedPointMetadata_default_instance_);
}
inline const ::research_scann::GenericFeatureVector_FixedPointMetadata& GenericFeatureVector::fixed_point_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.fixed_point_metadata)
  return _internal_fixed_point_metadata();
}
inline void GenericFeatureVector::unsafe_arena_set_allocated_fixed_point_metadata(::research_scann::GenericFeatureVector_FixedPointMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fixed_point_metadata_);
  }
  _impl_.fixed_point_metadata_ = reinterpret_cast<::research_scann::GenericFeatureVector_FixedPointMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.fixed_point_metadata)
}
inline ::research_scann::GenericFeatureVector_FixedPointMetadata* GenericFeatureVector::release_fixed_point_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::GenericFeatureVector_FixedPointMetadata* released = _impl_.fixed_point_metadata_;
  _impl_.fixed_point_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::GenericFeatureVector_FixedPointMetadata* GenericFeatureVector::unsafe_arena_release_fixed_point_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.fixed_point_metadata)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::GenericFeatureVector_FixedPointMetadata* temp = _impl_.fixed_point_metadata_;
  _impl_.fixed_point_metadata_ = nullptr;
  return temp;
}
inline ::research_scann::GenericFeatureVector_FixedPointMetadata* GenericFeatureVector::_internal_mutable_fixed_point_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.fixed_point_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::GenericFeatureVector_FixedPointMetadata>(GetArena());
    _impl_.fixed_point_metadata_ = reinterpret_cast<::research_scann::GenericFeatureVector_FixedPointMetadata*>(p);
  }
  return _impl_.fixed_point_metadata_;
}
inline ::research_scann::GenericFeatureVector_FixedPointMetadata* GenericFeatureVector::mutable_fixed_point_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::GenericFeatureVector_FixedPointMetadata* _msg = _internal_mutable_fixed_point_metadata();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.fixed_point_metadata)
  return _msg;
}
inline void GenericFeatureVector::set_allocated_fixed_point_metadata(::research_scann::GenericFeatureVector_FixedPointMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::GenericFeatureVector_FixedPointMetadata*>(_impl_.fixed_point_metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::GenericFeatureVector_FixedPointMetadata*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.fixed_point_metadata_ = reinterpret_cast<::research_scann::GenericFeatureVector_FixedPointMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.fixed_point_metadata)
}

// optional bytes userinfo = 17 [ctype = CORD];
inline bool GenericFeatureVector::has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_userinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userinfo_.Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::absl::Cord& GenericFeatureVector::_internal_userinfo() const {
  return _impl_.userinfo_;
}
inline const ::absl::Cord& GenericFeatureVector::userinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.userinfo)
  return _internal_userinfo();
}
inline void GenericFeatureVector::_internal_set_userinfo(const ::absl::Cord& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.userinfo_ = value;
}
inline void GenericFeatureVector::set_userinfo(const ::absl::Cord& value) {
   _internal_set_userinfo(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.userinfo)
}
inline void GenericFeatureVector::set_userinfo(::absl::string_view value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.userinfo_ = value;
  // @@protoc_insertion_point(field_set_string_piece:research_scann.GenericFeatureVector.userinfo)
}
inline ::absl::Cord* GenericFeatureVector::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return &_impl_.userinfo_;
}

// optional .google.protobuf.Timestamp expiration_timestamp = 20;
inline bool GenericFeatureVector::has_expiration_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiration_timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GenericFeatureVector::_internal_expiration_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.expiration_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GenericFeatureVector::expiration_timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void GenericFeatureVector::unsafe_arena_set_allocated_expiration_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_timestamp_);
  }
  _impl_.expiration_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.GenericFeatureVector.expiration_timestamp)
}
inline ::google::protobuf::Timestamp* GenericFeatureVector::release_expiration_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::google::protobuf::Timestamp* released = _impl_.expiration_timestamp_;
  _impl_.expiration_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* GenericFeatureVector::unsafe_arena_release_expiration_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.GenericFeatureVector.expiration_timestamp)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::google::protobuf::Timestamp* temp = _impl_.expiration_timestamp_;
  _impl_.expiration_timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GenericFeatureVector::_internal_mutable_expiration_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.expiration_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.expiration_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expiration_timestamp_;
}
inline ::google::protobuf::Timestamp* GenericFeatureVector::mutable_expiration_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expiration_timestamp();
  // @@protoc_insertion_point(field_mutable:research_scann.GenericFeatureVector.expiration_timestamp)
  return _msg;
}
inline void GenericFeatureVector::set_allocated_expiration_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.expiration_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.GenericFeatureVector.expiration_timestamp)
}

// optional uint64 feature_dim = 10 [default = 18446744073709551615, deprecated = true];
inline bool GenericFeatureVector::has_feature_dim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_feature_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feature_dim_ = ::uint64_t{18446744073709551615u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint64_t GenericFeatureVector::feature_dim() const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.feature_dim)
  return _internal_feature_dim();
}
inline void GenericFeatureVector::set_feature_dim(::uint64_t value) {
  _internal_set_feature_dim(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.feature_dim)
}
inline ::uint64_t GenericFeatureVector::_internal_feature_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feature_dim_;
}
inline void GenericFeatureVector::_internal_set_feature_dim(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.feature_dim_ = value;
}

// optional float weight = 8 [deprecated = true];
inline bool GenericFeatureVector::has_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void GenericFeatureVector::clear_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float GenericFeatureVector::weight() const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.weight)
  return _internal_weight();
}
inline void GenericFeatureVector::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.weight)
}
inline float GenericFeatureVector::_internal_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_;
}
inline void GenericFeatureVector::_internal_set_weight(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.weight_ = value;
}

// repeated int32 tokens = 14 [packed = true, deprecated = true];
inline int GenericFeatureVector::_internal_tokens_size() const {
  return _internal_tokens().size();
}
inline int GenericFeatureVector::tokens_size() const {
  return _internal_tokens_size();
}
inline void GenericFeatureVector::clear_tokens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tokens_.Clear();
}
inline ::int32_t GenericFeatureVector::tokens(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.GenericFeatureVector.tokens)
  return _internal_tokens().Get(index);
}
inline void GenericFeatureVector::set_tokens(int index, ::int32_t value) {
  _internal_mutable_tokens()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.GenericFeatureVector.tokens)
}
inline void GenericFeatureVector::add_tokens(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tokens()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.GenericFeatureVector.tokens)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GenericFeatureVector::tokens() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.GenericFeatureVector.tokens)
  return _internal_tokens();
}
inline ::google::protobuf::RepeatedField<::int32_t>* GenericFeatureVector::mutable_tokens()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.GenericFeatureVector.tokens)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tokens();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GenericFeatureVector::_internal_tokens()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tokens_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* GenericFeatureVector::_internal_mutable_tokens() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tokens_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace research_scann


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::research_scann::GenericFeatureVector_FeatureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::GenericFeatureVector_FeatureType>() {
  return ::research_scann::GenericFeatureVector_FeatureType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::GenericFeatureVector_FeatureNorm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::GenericFeatureVector_FeatureNorm>() {
  return ::research_scann::GenericFeatureVector_FeatureNorm_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_scann_2fdata_5fformat_2ffeatures_2eproto_2epb_2eh
