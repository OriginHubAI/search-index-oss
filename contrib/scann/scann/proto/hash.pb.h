// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/hash.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fhash_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fhash_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "scann/proto/distance_measure.pb.h"
#include "scann/proto/projection.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2fhash_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_scann_2fproto_2fhash_2eproto;
namespace research_scann {
class AsymmetricHasherConfig;
struct AsymmetricHasherConfigDefaultTypeInternal;
extern AsymmetricHasherConfigDefaultTypeInternal _AsymmetricHasherConfig_default_instance_;
class AsymmetricHasherConfig_FixedPointLUTConversionOptions;
struct AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal;
extern AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal _AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_;
class BitSamplingHasherConfig;
struct BitSamplingHasherConfigDefaultTypeInternal;
extern BitSamplingHasherConfigDefaultTypeInternal _BitSamplingHasherConfig_default_instance_;
class BncHasherConfig;
struct BncHasherConfigDefaultTypeInternal;
extern BncHasherConfigDefaultTypeInternal _BncHasherConfig_default_instance_;
class HashConfig;
struct HashConfigDefaultTypeInternal;
extern HashConfigDefaultTypeInternal _HashConfig_default_instance_;
class MinHasherConfig;
struct MinHasherConfigDefaultTypeInternal;
extern MinHasherConfigDefaultTypeInternal _MinHasherConfig_default_instance_;
class PcaHasherConfig;
struct PcaHasherConfigDefaultTypeInternal;
extern PcaHasherConfigDefaultTypeInternal _PcaHasherConfig_default_instance_;
class StackedQuantizersConfig;
struct StackedQuantizersConfigDefaultTypeInternal;
extern StackedQuantizersConfigDefaultTypeInternal _StackedQuantizersConfig_default_instance_;
}  // namespace research_scann
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace research_scann {
enum HashConfig_ThresholdType : int {
  HashConfig_ThresholdType_UNKNOWN = 0,
  HashConfig_ThresholdType_SIGN = 1,
  HashConfig_ThresholdType_MEAN = 2,
  HashConfig_ThresholdType_MEDIAN = 3,
  HashConfig_ThresholdType_SINUSOIDAL = 4,
};

bool HashConfig_ThresholdType_IsValid(int value);
extern const uint32_t HashConfig_ThresholdType_internal_data_[];
constexpr HashConfig_ThresholdType HashConfig_ThresholdType_ThresholdType_MIN = static_cast<HashConfig_ThresholdType>(0);
constexpr HashConfig_ThresholdType HashConfig_ThresholdType_ThresholdType_MAX = static_cast<HashConfig_ThresholdType>(4);
constexpr int HashConfig_ThresholdType_ThresholdType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
HashConfig_ThresholdType_descriptor();
template <typename T>
const std::string& HashConfig_ThresholdType_Name(T value) {
  static_assert(std::is_same<T, HashConfig_ThresholdType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ThresholdType_Name().");
  return HashConfig_ThresholdType_Name(static_cast<HashConfig_ThresholdType>(value));
}
template <>
inline const std::string& HashConfig_ThresholdType_Name(HashConfig_ThresholdType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HashConfig_ThresholdType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool HashConfig_ThresholdType_Parse(absl::string_view name, HashConfig_ThresholdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HashConfig_ThresholdType>(
      HashConfig_ThresholdType_descriptor(), name, value);
}
enum AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod : int {
  AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_TRUNCATE = 0,
  AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_ROUND = 1,
};

bool AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(int value);
extern const uint32_t AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_internal_data_[];
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MIN = static_cast<AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(0);
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MAX = static_cast<AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(1);
constexpr int AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor();
template <typename T>
const std::string& AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name(T value) {
  static_assert(std::is_same<T, AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FloatToIntConversionMethod_Name().");
  return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name(static_cast<AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(value));
}
template <>
inline const std::string& AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name(AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Parse(absl::string_view name, AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(
      AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor(), name, value);
}
enum AsymmetricHasherConfig_LookupType : int {
  AsymmetricHasherConfig_LookupType_FLOAT = 0,
  AsymmetricHasherConfig_LookupType_INT8 = 1,
  AsymmetricHasherConfig_LookupType_INT16 = 2,
  AsymmetricHasherConfig_LookupType_INT8_LUT16 = 3,
};

bool AsymmetricHasherConfig_LookupType_IsValid(int value);
extern const uint32_t AsymmetricHasherConfig_LookupType_internal_data_[];
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig_LookupType_LookupType_MIN = static_cast<AsymmetricHasherConfig_LookupType>(0);
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig_LookupType_LookupType_MAX = static_cast<AsymmetricHasherConfig_LookupType>(3);
constexpr int AsymmetricHasherConfig_LookupType_LookupType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AsymmetricHasherConfig_LookupType_descriptor();
template <typename T>
const std::string& AsymmetricHasherConfig_LookupType_Name(T value) {
  static_assert(std::is_same<T, AsymmetricHasherConfig_LookupType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LookupType_Name().");
  return AsymmetricHasherConfig_LookupType_Name(static_cast<AsymmetricHasherConfig_LookupType>(value));
}
template <>
inline const std::string& AsymmetricHasherConfig_LookupType_Name(AsymmetricHasherConfig_LookupType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AsymmetricHasherConfig_LookupType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AsymmetricHasherConfig_LookupType_Parse(absl::string_view name, AsymmetricHasherConfig_LookupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsymmetricHasherConfig_LookupType>(
      AsymmetricHasherConfig_LookupType_descriptor(), name, value);
}
enum AsymmetricHasherConfig_QuantizationScheme : int {
  AsymmetricHasherConfig_QuantizationScheme_PRODUCT = 0,
  AsymmetricHasherConfig_QuantizationScheme_STACKED = 1,
  AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_BIAS = 2,
  AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_PACK = 3,
};

bool AsymmetricHasherConfig_QuantizationScheme_IsValid(int value);
extern const uint32_t AsymmetricHasherConfig_QuantizationScheme_internal_data_[];
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MIN = static_cast<AsymmetricHasherConfig_QuantizationScheme>(0);
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MAX = static_cast<AsymmetricHasherConfig_QuantizationScheme>(3);
constexpr int AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AsymmetricHasherConfig_QuantizationScheme_descriptor();
template <typename T>
const std::string& AsymmetricHasherConfig_QuantizationScheme_Name(T value) {
  static_assert(std::is_same<T, AsymmetricHasherConfig_QuantizationScheme>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QuantizationScheme_Name().");
  return AsymmetricHasherConfig_QuantizationScheme_Name(static_cast<AsymmetricHasherConfig_QuantizationScheme>(value));
}
template <>
inline const std::string& AsymmetricHasherConfig_QuantizationScheme_Name(AsymmetricHasherConfig_QuantizationScheme value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AsymmetricHasherConfig_QuantizationScheme_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AsymmetricHasherConfig_QuantizationScheme_Parse(absl::string_view name, AsymmetricHasherConfig_QuantizationScheme* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsymmetricHasherConfig_QuantizationScheme>(
      AsymmetricHasherConfig_QuantizationScheme_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class StackedQuantizersConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.StackedQuantizersConfig) */ {
 public:
  inline StackedQuantizersConfig() : StackedQuantizersConfig(nullptr) {}
  ~StackedQuantizersConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StackedQuantizersConfig(::google::protobuf::internal::ConstantInitialized);

  inline StackedQuantizersConfig(const StackedQuantizersConfig& from)
      : StackedQuantizersConfig(nullptr, from) {}
  StackedQuantizersConfig(StackedQuantizersConfig&& from) noexcept
    : StackedQuantizersConfig() {
    *this = ::std::move(from);
  }

  inline StackedQuantizersConfig& operator=(const StackedQuantizersConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackedQuantizersConfig& operator=(StackedQuantizersConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackedQuantizersConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackedQuantizersConfig* internal_default_instance() {
    return reinterpret_cast<const StackedQuantizersConfig*>(
               &_StackedQuantizersConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StackedQuantizersConfig& a, StackedQuantizersConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StackedQuantizersConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackedQuantizersConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackedQuantizersConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StackedQuantizersConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StackedQuantizersConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StackedQuantizersConfig& from) {
    StackedQuantizersConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StackedQuantizersConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.StackedQuantizersConfig";
  }
  protected:
  explicit StackedQuantizersConfig(::google::protobuf::Arena* arena);
  StackedQuantizersConfig(::google::protobuf::Arena* arena, const StackedQuantizersConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativeImprovementThresholdFieldNumber = 3,
    kMinNumIterationsFieldNumber = 1,
    kMaxNumIterationsFieldNumber = 2,
  };
  // optional float relative_improvement_threshold = 3 [default = 0.001];
  bool has_relative_improvement_threshold() const;
  void clear_relative_improvement_threshold() ;
  float relative_improvement_threshold() const;
  void set_relative_improvement_threshold(float value);

  private:
  float _internal_relative_improvement_threshold() const;
  void _internal_set_relative_improvement_threshold(float value);

  public:
  // optional int32 min_num_iterations = 1 [default = 3];
  bool has_min_num_iterations() const;
  void clear_min_num_iterations() ;
  ::int32_t min_num_iterations() const;
  void set_min_num_iterations(::int32_t value);

  private:
  ::int32_t _internal_min_num_iterations() const;
  void _internal_set_min_num_iterations(::int32_t value);

  public:
  // optional int32 max_num_iterations = 2 [default = 10];
  bool has_max_num_iterations() const;
  void clear_max_num_iterations() ;
  ::int32_t max_num_iterations() const;
  void set_max_num_iterations(::int32_t value);

  private:
  ::int32_t _internal_max_num_iterations() const;
  void _internal_set_max_num_iterations(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.StackedQuantizersConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float relative_improvement_threshold_;
    ::int32_t min_num_iterations_;
    ::int32_t max_num_iterations_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class PcaHasherConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.PcaHasherConfig) */ {
 public:
  inline PcaHasherConfig() : PcaHasherConfig(nullptr) {}
  ~PcaHasherConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PcaHasherConfig(::google::protobuf::internal::ConstantInitialized);

  inline PcaHasherConfig(const PcaHasherConfig& from)
      : PcaHasherConfig(nullptr, from) {}
  PcaHasherConfig(PcaHasherConfig&& from) noexcept
    : PcaHasherConfig() {
    *this = ::std::move(from);
  }

  inline PcaHasherConfig& operator=(const PcaHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PcaHasherConfig& operator=(PcaHasherConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PcaHasherConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PcaHasherConfig* internal_default_instance() {
    return reinterpret_cast<const PcaHasherConfig*>(
               &_PcaHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PcaHasherConfig& a, PcaHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PcaHasherConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PcaHasherConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PcaHasherConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PcaHasherConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PcaHasherConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PcaHasherConfig& from) {
    PcaHasherConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PcaHasherConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.PcaHasherConfig";
  }
  protected:
  explicit PcaHasherConfig(::google::protobuf::Arena* arena);
  PcaHasherConfig(::google::protobuf::Arena* arena, const PcaHasherConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotateProjectionsFieldNumber = 1,
    kLearnProjectionsFieldNumber = 5,
    kMaxSampleSizeFieldNumber = 4,
    kSamplingFractionFieldNumber = 2,
    kSamplingSeedFieldNumber = 3,
    kMaxNumIterationFieldNumber = 6,
    kIterationToleranceFieldNumber = 7,
  };
  // optional bool rotate_projections = 1 [default = false];
  bool has_rotate_projections() const;
  void clear_rotate_projections() ;
  bool rotate_projections() const;
  void set_rotate_projections(bool value);

  private:
  bool _internal_rotate_projections() const;
  void _internal_set_rotate_projections(bool value);

  public:
  // optional bool learn_projections = 5 [default = false];
  bool has_learn_projections() const;
  void clear_learn_projections() ;
  bool learn_projections() const;
  void set_learn_projections(bool value);

  private:
  bool _internal_learn_projections() const;
  void _internal_set_learn_projections(bool value);

  public:
  // optional int32 max_sample_size = 4;
  bool has_max_sample_size() const;
  void clear_max_sample_size() ;
  ::int32_t max_sample_size() const;
  void set_max_sample_size(::int32_t value);

  private:
  ::int32_t _internal_max_sample_size() const;
  void _internal_set_max_sample_size(::int32_t value);

  public:
  // optional float sampling_fraction = 2 [default = 1];
  bool has_sampling_fraction() const;
  void clear_sampling_fraction() ;
  float sampling_fraction() const;
  void set_sampling_fraction(float value);

  private:
  float _internal_sampling_fraction() const;
  void _internal_set_sampling_fraction(float value);

  public:
  // optional int32 sampling_seed = 3 [default = 1];
  bool has_sampling_seed() const;
  void clear_sampling_seed() ;
  ::int32_t sampling_seed() const;
  void set_sampling_seed(::int32_t value);

  private:
  ::int32_t _internal_sampling_seed() const;
  void _internal_set_sampling_seed(::int32_t value);

  public:
  // optional int32 max_num_iteration = 6 [default = 40];
  bool has_max_num_iteration() const;
  void clear_max_num_iteration() ;
  ::int32_t max_num_iteration() const;
  void set_max_num_iteration(::int32_t value);

  private:
  ::int32_t _internal_max_num_iteration() const;
  void _internal_set_max_num_iteration(::int32_t value);

  public:
  // optional float iteration_tolerance = 7 [default = 1e-05];
  bool has_iteration_tolerance() const;
  void clear_iteration_tolerance() ;
  float iteration_tolerance() const;
  void set_iteration_tolerance(float value);

  private:
  float _internal_iteration_tolerance() const;
  void _internal_set_iteration_tolerance(float value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.PcaHasherConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool rotate_projections_;
    bool learn_projections_;
    ::int32_t max_sample_size_;
    float sampling_fraction_;
    ::int32_t sampling_seed_;
    ::int32_t max_num_iteration_;
    float iteration_tolerance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class MinHasherConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.MinHasherConfig) */ {
 public:
  inline MinHasherConfig() : MinHasherConfig(nullptr) {}
  ~MinHasherConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MinHasherConfig(::google::protobuf::internal::ConstantInitialized);

  inline MinHasherConfig(const MinHasherConfig& from)
      : MinHasherConfig(nullptr, from) {}
  MinHasherConfig(MinHasherConfig&& from) noexcept
    : MinHasherConfig() {
    *this = ::std::move(from);
  }

  inline MinHasherConfig& operator=(const MinHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinHasherConfig& operator=(MinHasherConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinHasherConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinHasherConfig* internal_default_instance() {
    return reinterpret_cast<const MinHasherConfig*>(
               &_MinHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MinHasherConfig& a, MinHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MinHasherConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinHasherConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinHasherConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinHasherConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MinHasherConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MinHasherConfig& from) {
    MinHasherConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MinHasherConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.MinHasherConfig";
  }
  protected:
  explicit MinHasherConfig(::google::protobuf::Arena* arena);
  MinHasherConfig(::google::protobuf::Arena* arena, const MinHasherConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedsFieldNumber = 4,
    kConfigIdFieldNumber = 1,
    kNumSketchesFieldNumber = 2,
    kNumHashesFieldNumber = 3,
    kNumBitsPerHashFieldNumber = 5,
  };
  // repeated int64 seeds = 4;
  int seeds_size() const;
  private:
  int _internal_seeds_size() const;

  public:
  void clear_seeds() ;
  ::int64_t seeds(int index) const;
  void set_seeds(int index, ::int64_t value);
  void add_seeds(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& seeds() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_seeds();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_seeds() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_seeds();

  public:
  // optional int32 config_id = 1;
  bool has_config_id() const;
  void clear_config_id() ;
  ::int32_t config_id() const;
  void set_config_id(::int32_t value);

  private:
  ::int32_t _internal_config_id() const;
  void _internal_set_config_id(::int32_t value);

  public:
  // optional int32 num_sketches = 2;
  bool has_num_sketches() const;
  void clear_num_sketches() ;
  ::int32_t num_sketches() const;
  void set_num_sketches(::int32_t value);

  private:
  ::int32_t _internal_num_sketches() const;
  void _internal_set_num_sketches(::int32_t value);

  public:
  // optional int32 num_hashes = 3;
  bool has_num_hashes() const;
  void clear_num_hashes() ;
  ::int32_t num_hashes() const;
  void set_num_hashes(::int32_t value);

  private:
  ::int32_t _internal_num_hashes() const;
  void _internal_set_num_hashes(::int32_t value);

  public:
  // optional int32 num_bits_per_hash = 5;
  bool has_num_bits_per_hash() const;
  void clear_num_bits_per_hash() ;
  ::int32_t num_bits_per_hash() const;
  void set_num_bits_per_hash(::int32_t value);

  private:
  ::int32_t _internal_num_bits_per_hash() const;
  void _internal_set_num_bits_per_hash(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.MinHasherConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> seeds_;
    ::int32_t config_id_;
    ::int32_t num_sketches_;
    ::int32_t num_hashes_;
    ::int32_t num_bits_per_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class BncHasherConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.BncHasherConfig) */ {
 public:
  inline BncHasherConfig() : BncHasherConfig(nullptr) {}
  ~BncHasherConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BncHasherConfig(::google::protobuf::internal::ConstantInitialized);

  inline BncHasherConfig(const BncHasherConfig& from)
      : BncHasherConfig(nullptr, from) {}
  BncHasherConfig(BncHasherConfig&& from) noexcept
    : BncHasherConfig() {
    *this = ::std::move(from);
  }

  inline BncHasherConfig& operator=(const BncHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BncHasherConfig& operator=(BncHasherConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BncHasherConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BncHasherConfig* internal_default_instance() {
    return reinterpret_cast<const BncHasherConfig*>(
               &_BncHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BncHasherConfig& a, BncHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BncHasherConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BncHasherConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BncHasherConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BncHasherConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BncHasherConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BncHasherConfig& from) {
    BncHasherConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BncHasherConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.BncHasherConfig";
  }
  protected:
  explicit BncHasherConfig(::google::protobuf::Arena* arena);
  BncHasherConfig(::google::protobuf::Arena* arena, const BncHasherConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressionRatioFieldNumber = 1,
    kNumCpusFieldNumber = 8,
    kGammaFieldNumber = 2,
    kLearningRateFieldNumber = 3,
    kBatchSizeFieldNumber = 4,
    kNumPhase1IterationsFieldNumber = 5,
    kNumPhase2IterationsFieldNumber = 6,
    kSamplingSeedFieldNumber = 7,
  };
  // optional float compression_ratio = 1 [default = 0];
  bool has_compression_ratio() const;
  void clear_compression_ratio() ;
  float compression_ratio() const;
  void set_compression_ratio(float value);

  private:
  float _internal_compression_ratio() const;
  void _internal_set_compression_ratio(float value);

  public:
  // optional int32 num_cpus = 8 [default = 1];
  bool has_num_cpus() const;
  void clear_num_cpus() ;
  ::int32_t num_cpus() const;
  void set_num_cpus(::int32_t value);

  private:
  ::int32_t _internal_num_cpus() const;
  void _internal_set_num_cpus(::int32_t value);

  public:
  // optional float gamma = 2 [default = 10];
  bool has_gamma() const;
  void clear_gamma() ;
  float gamma() const;
  void set_gamma(float value);

  private:
  float _internal_gamma() const;
  void _internal_set_gamma(float value);

  public:
  // optional float learning_rate = 3 [default = 0.1];
  bool has_learning_rate() const;
  void clear_learning_rate() ;
  float learning_rate() const;
  void set_learning_rate(float value);

  private:
  float _internal_learning_rate() const;
  void _internal_set_learning_rate(float value);

  public:
  // optional int32 batch_size = 4 [default = 128];
  bool has_batch_size() const;
  void clear_batch_size() ;
  ::int32_t batch_size() const;
  void set_batch_size(::int32_t value);

  private:
  ::int32_t _internal_batch_size() const;
  void _internal_set_batch_size(::int32_t value);

  public:
  // optional int32 num_phase1_iterations = 5 [default = 50];
  bool has_num_phase1_iterations() const;
  void clear_num_phase1_iterations() ;
  ::int32_t num_phase1_iterations() const;
  void set_num_phase1_iterations(::int32_t value);

  private:
  ::int32_t _internal_num_phase1_iterations() const;
  void _internal_set_num_phase1_iterations(::int32_t value);

  public:
  // optional int32 num_phase2_iterations = 6 [default = 100];
  bool has_num_phase2_iterations() const;
  void clear_num_phase2_iterations() ;
  ::int32_t num_phase2_iterations() const;
  void set_num_phase2_iterations(::int32_t value);

  private:
  ::int32_t _internal_num_phase2_iterations() const;
  void _internal_set_num_phase2_iterations(::int32_t value);

  public:
  // optional int32 sampling_seed = 7 [default = 1];
  bool has_sampling_seed() const;
  void clear_sampling_seed() ;
  ::int32_t sampling_seed() const;
  void set_sampling_seed(::int32_t value);

  private:
  ::int32_t _internal_sampling_seed() const;
  void _internal_set_sampling_seed(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.BncHasherConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float compression_ratio_;
    ::int32_t num_cpus_;
    float gamma_;
    float learning_rate_;
    ::int32_t batch_size_;
    ::int32_t num_phase1_iterations_;
    ::int32_t num_phase2_iterations_;
    ::int32_t sampling_seed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class BitSamplingHasherConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.BitSamplingHasherConfig) */ {
 public:
  inline BitSamplingHasherConfig() : BitSamplingHasherConfig(nullptr) {}
  ~BitSamplingHasherConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BitSamplingHasherConfig(::google::protobuf::internal::ConstantInitialized);

  inline BitSamplingHasherConfig(const BitSamplingHasherConfig& from)
      : BitSamplingHasherConfig(nullptr, from) {}
  BitSamplingHasherConfig(BitSamplingHasherConfig&& from) noexcept
    : BitSamplingHasherConfig() {
    *this = ::std::move(from);
  }

  inline BitSamplingHasherConfig& operator=(const BitSamplingHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitSamplingHasherConfig& operator=(BitSamplingHasherConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitSamplingHasherConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitSamplingHasherConfig* internal_default_instance() {
    return reinterpret_cast<const BitSamplingHasherConfig*>(
               &_BitSamplingHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BitSamplingHasherConfig& a, BitSamplingHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BitSamplingHasherConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitSamplingHasherConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitSamplingHasherConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitSamplingHasherConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BitSamplingHasherConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BitSamplingHasherConfig& from) {
    BitSamplingHasherConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BitSamplingHasherConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.BitSamplingHasherConfig";
  }
  protected:
  explicit BitSamplingHasherConfig(::google::protobuf::Arena* arena);
  BitSamplingHasherConfig(::google::protobuf::Arena* arena, const BitSamplingHasherConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseEntropyFieldNumber = 2,
    kNumBitsFieldNumber = 1,
  };
  // optional bool use_entropy = 2 [default = false];
  bool has_use_entropy() const;
  void clear_use_entropy() ;
  bool use_entropy() const;
  void set_use_entropy(bool value);

  private:
  bool _internal_use_entropy() const;
  void _internal_set_use_entropy(bool value);

  public:
  // optional int32 num_bits = 1 [default = 3];
  bool has_num_bits() const;
  void clear_num_bits() ;
  ::int32_t num_bits() const;
  void set_num_bits(::int32_t value);

  private:
  ::int32_t _internal_num_bits() const;
  void _internal_set_num_bits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.BitSamplingHasherConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool use_entropy_;
    ::int32_t num_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class AsymmetricHasherConfig_FixedPointLUTConversionOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions) */ {
 public:
  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions() : AsymmetricHasherConfig_FixedPointLUTConversionOptions(nullptr) {}
  ~AsymmetricHasherConfig_FixedPointLUTConversionOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AsymmetricHasherConfig_FixedPointLUTConversionOptions(::google::protobuf::internal::ConstantInitialized);

  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from)
      : AsymmetricHasherConfig_FixedPointLUTConversionOptions(nullptr, from) {}
  AsymmetricHasherConfig_FixedPointLUTConversionOptions(AsymmetricHasherConfig_FixedPointLUTConversionOptions&& from) noexcept
    : AsymmetricHasherConfig_FixedPointLUTConversionOptions() {
    *this = ::std::move(from);
  }

  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions& operator=(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions& operator=(AsymmetricHasherConfig_FixedPointLUTConversionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymmetricHasherConfig_FixedPointLUTConversionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsymmetricHasherConfig_FixedPointLUTConversionOptions* internal_default_instance() {
    return reinterpret_cast<const AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(
               &_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AsymmetricHasherConfig_FixedPointLUTConversionOptions& a, AsymmetricHasherConfig_FixedPointLUTConversionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AsymmetricHasherConfig_FixedPointLUTConversionOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AsymmetricHasherConfig_FixedPointLUTConversionOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
    AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions";
  }
  protected:
  explicit AsymmetricHasherConfig_FixedPointLUTConversionOptions(::google::protobuf::Arena* arena);
  AsymmetricHasherConfig_FixedPointLUTConversionOptions(::google::protobuf::Arena* arena, const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FloatToIntConversionMethod = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod;
  static constexpr FloatToIntConversionMethod TRUNCATE = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_TRUNCATE;
  static constexpr FloatToIntConversionMethod ROUND = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_ROUND;
  static inline bool FloatToIntConversionMethod_IsValid(int value) {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(value);
  }
  static constexpr FloatToIntConversionMethod FloatToIntConversionMethod_MIN = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MIN;
  static constexpr FloatToIntConversionMethod FloatToIntConversionMethod_MAX = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MAX;
  static constexpr int FloatToIntConversionMethod_ARRAYSIZE = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FloatToIntConversionMethod_descriptor() {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor();
  }
  template <typename T>
  static inline const std::string& FloatToIntConversionMethod_Name(T value) {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name(value);
  }
  static inline bool FloatToIntConversionMethod_Parse(absl::string_view name, FloatToIntConversionMethod* value) {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFloatToIntConversionMethodFieldNumber = 1,
    kMultiplierQuantileFieldNumber = 2,
  };
  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
  bool has_float_to_int_conversion_method() const;
  void clear_float_to_int_conversion_method() ;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod float_to_int_conversion_method() const;
  void set_float_to_int_conversion_method(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value);

  private:
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod _internal_float_to_int_conversion_method() const;
  void _internal_set_float_to_int_conversion_method(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value);

  public:
  // optional float multiplier_quantile = 2 [default = 1];
  bool has_multiplier_quantile() const;
  void clear_multiplier_quantile() ;
  float multiplier_quantile() const;
  void set_multiplier_quantile(float value);

  private:
  float _internal_multiplier_quantile() const;
  void _internal_set_multiplier_quantile(float value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int float_to_int_conversion_method_;
    float multiplier_quantile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class AsymmetricHasherConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.AsymmetricHasherConfig) */ {
 public:
  inline AsymmetricHasherConfig() : AsymmetricHasherConfig(nullptr) {}
  ~AsymmetricHasherConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AsymmetricHasherConfig(::google::protobuf::internal::ConstantInitialized);

  inline AsymmetricHasherConfig(const AsymmetricHasherConfig& from)
      : AsymmetricHasherConfig(nullptr, from) {}
  AsymmetricHasherConfig(AsymmetricHasherConfig&& from) noexcept
    : AsymmetricHasherConfig() {
    *this = ::std::move(from);
  }

  inline AsymmetricHasherConfig& operator=(const AsymmetricHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymmetricHasherConfig& operator=(AsymmetricHasherConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymmetricHasherConfig& default_instance() {
    return *internal_default_instance();
  }
  enum SamplingFractionOrExpectedSizeCase {
    kSamplingFraction = 10,
    kExpectedSampleSize = 29,
    SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET = 0,
  };

  static inline const AsymmetricHasherConfig* internal_default_instance() {
    return reinterpret_cast<const AsymmetricHasherConfig*>(
               &_AsymmetricHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AsymmetricHasherConfig& a, AsymmetricHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymmetricHasherConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymmetricHasherConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AsymmetricHasherConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AsymmetricHasherConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AsymmetricHasherConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AsymmetricHasherConfig& from) {
    AsymmetricHasherConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AsymmetricHasherConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.AsymmetricHasherConfig";
  }
  protected:
  explicit AsymmetricHasherConfig(::google::protobuf::Arena* arena);
  AsymmetricHasherConfig(::google::protobuf::Arena* arena, const AsymmetricHasherConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FixedPointLUTConversionOptions = AsymmetricHasherConfig_FixedPointLUTConversionOptions;

  using LookupType = AsymmetricHasherConfig_LookupType;
  static constexpr LookupType FLOAT = AsymmetricHasherConfig_LookupType_FLOAT;
  static constexpr LookupType INT8 = AsymmetricHasherConfig_LookupType_INT8;
  static constexpr LookupType INT16 = AsymmetricHasherConfig_LookupType_INT16;
  static constexpr LookupType INT8_LUT16 = AsymmetricHasherConfig_LookupType_INT8_LUT16;
  static inline bool LookupType_IsValid(int value) {
    return AsymmetricHasherConfig_LookupType_IsValid(value);
  }
  static constexpr LookupType LookupType_MIN = AsymmetricHasherConfig_LookupType_LookupType_MIN;
  static constexpr LookupType LookupType_MAX = AsymmetricHasherConfig_LookupType_LookupType_MAX;
  static constexpr int LookupType_ARRAYSIZE = AsymmetricHasherConfig_LookupType_LookupType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LookupType_descriptor() {
    return AsymmetricHasherConfig_LookupType_descriptor();
  }
  template <typename T>
  static inline const std::string& LookupType_Name(T value) {
    return AsymmetricHasherConfig_LookupType_Name(value);
  }
  static inline bool LookupType_Parse(absl::string_view name, LookupType* value) {
    return AsymmetricHasherConfig_LookupType_Parse(name, value);
  }

  using QuantizationScheme = AsymmetricHasherConfig_QuantizationScheme;
  static constexpr QuantizationScheme PRODUCT = AsymmetricHasherConfig_QuantizationScheme_PRODUCT;
  static constexpr QuantizationScheme STACKED = AsymmetricHasherConfig_QuantizationScheme_STACKED;
  static constexpr QuantizationScheme PRODUCT_AND_BIAS = AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_BIAS;
  static constexpr QuantizationScheme PRODUCT_AND_PACK = AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_PACK;
  static inline bool QuantizationScheme_IsValid(int value) {
    return AsymmetricHasherConfig_QuantizationScheme_IsValid(value);
  }
  static constexpr QuantizationScheme QuantizationScheme_MIN = AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MIN;
  static constexpr QuantizationScheme QuantizationScheme_MAX = AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MAX;
  static constexpr int QuantizationScheme_ARRAYSIZE = AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* QuantizationScheme_descriptor() {
    return AsymmetricHasherConfig_QuantizationScheme_descriptor();
  }
  template <typename T>
  static inline const std::string& QuantizationScheme_Name(T value) {
    return AsymmetricHasherConfig_QuantizationScheme_Name(value);
  }
  static inline bool QuantizationScheme_Parse(absl::string_view name, QuantizationScheme* value) {
    return AsymmetricHasherConfig_QuantizationScheme_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCentersFilenameFieldNumber = 6,
    kMrJobnamePrefixFieldNumber = 12,
    kCellFieldNumber = 13,
    kProjectionFieldNumber = 1,
    kQuantizationDistanceFieldNumber = 18,
    kStackedQuantizersConfigFieldNumber = 24,
    kFixedPointLutConversionOptionsFieldNumber = 25,
    kMinNumberMachinesFieldNumber = 7,
    kUsePerLeafPartitionTrainingFieldNumber = 17,
    kUseNoiseShapedTrainingFieldNumber = 30,
    kUseSingleMachineTrainerFieldNumber = 8,
    kLookupTypeFieldNumber = 20,
    kQuantizationSchemeFieldNumber = 23,
    kPartitionLevelConfidenceIntervalStdevsFieldNumber = 26,
    kNumMachinesFieldNumber = 27,
    kUseResidualQuantizationFieldNumber = 22,
    kUseNormalizedResidualQuantizationFieldNumber = 32,
    kUseNormBiasingCorrectionFieldNumber = 31,
    kUseGlobalTopnFieldNumber = 33,
    kMinClusterSizeFieldNumber = 19,
    kNumClustersPerBlockFieldNumber = 2,
    kMaxSampleSizeFieldNumber = 3,
    kMaxClusteringIterationsFieldNumber = 4,
    kClusteringConvergenceToleranceFieldNumber = 5,
    kClusteringSeedFieldNumber = 9,
    kSamplingSeedFieldNumber = 11,
    kRamGbFieldNumber = 14,
    kNumCpusFieldNumber = 15,
    kNoiseShapingThresholdFieldNumber = 28,
    kSamplingFractionFieldNumber = 10,
    kExpectedSampleSizeFieldNumber = 29,
  };
  // optional string centers_filename = 6;
  bool has_centers_filename() const;
  void clear_centers_filename() ;
  const std::string& centers_filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_centers_filename(Arg_&& arg, Args_... args);
  std::string* mutable_centers_filename();
  PROTOBUF_NODISCARD std::string* release_centers_filename();
  void set_allocated_centers_filename(std::string* value);

  private:
  const std::string& _internal_centers_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_centers_filename(
      const std::string& value);
  std::string* _internal_mutable_centers_filename();

  public:
  // optional string mr_jobname_prefix = 12;
  bool has_mr_jobname_prefix() const;
  void clear_mr_jobname_prefix() ;
  const std::string& mr_jobname_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mr_jobname_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_mr_jobname_prefix();
  PROTOBUF_NODISCARD std::string* release_mr_jobname_prefix();
  void set_allocated_mr_jobname_prefix(std::string* value);

  private:
  const std::string& _internal_mr_jobname_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mr_jobname_prefix(
      const std::string& value);
  std::string* _internal_mutable_mr_jobname_prefix();

  public:
  // optional string cell = 13;
  bool has_cell() const;
  void clear_cell() ;
  const std::string& cell() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cell(Arg_&& arg, Args_... args);
  std::string* mutable_cell();
  PROTOBUF_NODISCARD std::string* release_cell();
  void set_allocated_cell(std::string* value);

  private:
  const std::string& _internal_cell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cell(
      const std::string& value);
  std::string* _internal_mutable_cell();

  public:
  // optional .research_scann.ProjectionConfig projection = 1;
  bool has_projection() const;
  void clear_projection() ;
  const ::research_scann::ProjectionConfig& projection() const;
  PROTOBUF_NODISCARD ::research_scann::ProjectionConfig* release_projection();
  ::research_scann::ProjectionConfig* mutable_projection();
  void set_allocated_projection(::research_scann::ProjectionConfig* value);
  void unsafe_arena_set_allocated_projection(::research_scann::ProjectionConfig* value);
  ::research_scann::ProjectionConfig* unsafe_arena_release_projection();

  private:
  const ::research_scann::ProjectionConfig& _internal_projection() const;
  ::research_scann::ProjectionConfig* _internal_mutable_projection();

  public:
  // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
  bool has_quantization_distance() const;
  void clear_quantization_distance() ;
  const ::research_scann::DistanceMeasureConfig& quantization_distance() const;
  PROTOBUF_NODISCARD ::research_scann::DistanceMeasureConfig* release_quantization_distance();
  ::research_scann::DistanceMeasureConfig* mutable_quantization_distance();
  void set_allocated_quantization_distance(::research_scann::DistanceMeasureConfig* value);
  void unsafe_arena_set_allocated_quantization_distance(::research_scann::DistanceMeasureConfig* value);
  ::research_scann::DistanceMeasureConfig* unsafe_arena_release_quantization_distance();

  private:
  const ::research_scann::DistanceMeasureConfig& _internal_quantization_distance() const;
  ::research_scann::DistanceMeasureConfig* _internal_mutable_quantization_distance();

  public:
  // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
  bool has_stacked_quantizers_config() const;
  void clear_stacked_quantizers_config() ;
  const ::research_scann::StackedQuantizersConfig& stacked_quantizers_config() const;
  PROTOBUF_NODISCARD ::research_scann::StackedQuantizersConfig* release_stacked_quantizers_config();
  ::research_scann::StackedQuantizersConfig* mutable_stacked_quantizers_config();
  void set_allocated_stacked_quantizers_config(::research_scann::StackedQuantizersConfig* value);
  void unsafe_arena_set_allocated_stacked_quantizers_config(::research_scann::StackedQuantizersConfig* value);
  ::research_scann::StackedQuantizersConfig* unsafe_arena_release_stacked_quantizers_config();

  private:
  const ::research_scann::StackedQuantizersConfig& _internal_stacked_quantizers_config() const;
  ::research_scann::StackedQuantizersConfig* _internal_mutable_stacked_quantizers_config();

  public:
  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
  bool has_fixed_point_lut_conversion_options() const;
  void clear_fixed_point_lut_conversion_options() ;
  const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& fixed_point_lut_conversion_options() const;
  PROTOBUF_NODISCARD ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* release_fixed_point_lut_conversion_options();
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* mutable_fixed_point_lut_conversion_options();
  void set_allocated_fixed_point_lut_conversion_options(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* value);
  void unsafe_arena_set_allocated_fixed_point_lut_conversion_options(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* value);
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* unsafe_arena_release_fixed_point_lut_conversion_options();

  private:
  const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& _internal_fixed_point_lut_conversion_options() const;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* _internal_mutable_fixed_point_lut_conversion_options();

  public:
  // optional int32 min_number_machines = 7 [deprecated = true];
  [[deprecated]]  bool has_min_number_machines() const;
  [[deprecated]]  void clear_min_number_machines() ;
  [[deprecated]] ::int32_t min_number_machines() const;
  [[deprecated]] void set_min_number_machines(::int32_t value);

  private:
  ::int32_t _internal_min_number_machines() const;
  void _internal_set_min_number_machines(::int32_t value);

  public:
  // optional bool use_per_leaf_partition_training = 17 [default = false];
  bool has_use_per_leaf_partition_training() const;
  void clear_use_per_leaf_partition_training() ;
  bool use_per_leaf_partition_training() const;
  void set_use_per_leaf_partition_training(bool value);

  private:
  bool _internal_use_per_leaf_partition_training() const;
  void _internal_set_use_per_leaf_partition_training(bool value);

  public:
  // optional bool use_noise_shaped_training = 30 [default = false, deprecated = true];
  [[deprecated]]  bool has_use_noise_shaped_training() const;
  [[deprecated]]  void clear_use_noise_shaped_training() ;
  [[deprecated]] bool use_noise_shaped_training() const;
  [[deprecated]] void set_use_noise_shaped_training(bool value);

  private:
  bool _internal_use_noise_shaped_training() const;
  void _internal_set_use_noise_shaped_training(bool value);

  public:
  // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
  [[deprecated]]  bool has_use_single_machine_trainer() const;
  [[deprecated]]  void clear_use_single_machine_trainer() ;
  [[deprecated]] bool use_single_machine_trainer() const;
  [[deprecated]] void set_use_single_machine_trainer(bool value);

  private:
  bool _internal_use_single_machine_trainer() const;
  void _internal_set_use_single_machine_trainer(bool value);

  public:
  // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
  bool has_lookup_type() const;
  void clear_lookup_type() ;
  ::research_scann::AsymmetricHasherConfig_LookupType lookup_type() const;
  void set_lookup_type(::research_scann::AsymmetricHasherConfig_LookupType value);

  private:
  ::research_scann::AsymmetricHasherConfig_LookupType _internal_lookup_type() const;
  void _internal_set_lookup_type(::research_scann::AsymmetricHasherConfig_LookupType value);

  public:
  // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
  bool has_quantization_scheme() const;
  void clear_quantization_scheme() ;
  ::research_scann::AsymmetricHasherConfig_QuantizationScheme quantization_scheme() const;
  void set_quantization_scheme(::research_scann::AsymmetricHasherConfig_QuantizationScheme value);

  private:
  ::research_scann::AsymmetricHasherConfig_QuantizationScheme _internal_quantization_scheme() const;
  void _internal_set_quantization_scheme(::research_scann::AsymmetricHasherConfig_QuantizationScheme value);

  public:
  // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
  [[deprecated]]  bool has_partition_level_confidence_interval_stdevs() const;
  [[deprecated]]  void clear_partition_level_confidence_interval_stdevs() ;
  [[deprecated]] float partition_level_confidence_interval_stdevs() const;
  [[deprecated]] void set_partition_level_confidence_interval_stdevs(float value);

  private:
  float _internal_partition_level_confidence_interval_stdevs() const;
  void _internal_set_partition_level_confidence_interval_stdevs(float value);

  public:
  // optional int32 num_machines = 27;
  bool has_num_machines() const;
  void clear_num_machines() ;
  ::int32_t num_machines() const;
  void set_num_machines(::int32_t value);

  private:
  ::int32_t _internal_num_machines() const;
  void _internal_set_num_machines(::int32_t value);

  public:
  // optional bool use_residual_quantization = 22 [default = false];
  bool has_use_residual_quantization() const;
  void clear_use_residual_quantization() ;
  bool use_residual_quantization() const;
  void set_use_residual_quantization(bool value);

  private:
  bool _internal_use_residual_quantization() const;
  void _internal_set_use_residual_quantization(bool value);

  public:
  // optional bool use_normalized_residual_quantization = 32 [default = false];
  bool has_use_normalized_residual_quantization() const;
  void clear_use_normalized_residual_quantization() ;
  bool use_normalized_residual_quantization() const;
  void set_use_normalized_residual_quantization(bool value);

  private:
  bool _internal_use_normalized_residual_quantization() const;
  void _internal_set_use_normalized_residual_quantization(bool value);

  public:
  // optional bool use_norm_biasing_correction = 31 [default = false];
  bool has_use_norm_biasing_correction() const;
  void clear_use_norm_biasing_correction() ;
  bool use_norm_biasing_correction() const;
  void set_use_norm_biasing_correction(bool value);

  private:
  bool _internal_use_norm_biasing_correction() const;
  void _internal_set_use_norm_biasing_correction(bool value);

  public:
  // optional bool use_global_topn = 33 [default = false];
  bool has_use_global_topn() const;
  void clear_use_global_topn() ;
  bool use_global_topn() const;
  void set_use_global_topn(bool value);

  private:
  bool _internal_use_global_topn() const;
  void _internal_set_use_global_topn(bool value);

  public:
  // optional float min_cluster_size = 19 [default = 1, deprecated = true];
  [[deprecated]]  bool has_min_cluster_size() const;
  [[deprecated]]  void clear_min_cluster_size() ;
  [[deprecated]] float min_cluster_size() const;
  [[deprecated]] void set_min_cluster_size(float value);

  private:
  float _internal_min_cluster_size() const;
  void _internal_set_min_cluster_size(float value);

  public:
  // optional int32 num_clusters_per_block = 2 [default = 256];
  bool has_num_clusters_per_block() const;
  void clear_num_clusters_per_block() ;
  ::int32_t num_clusters_per_block() const;
  void set_num_clusters_per_block(::int32_t value);

  private:
  ::int32_t _internal_num_clusters_per_block() const;
  void _internal_set_num_clusters_per_block(::int32_t value);

  public:
  // optional int32 max_sample_size = 3 [default = 2147483647];
  bool has_max_sample_size() const;
  void clear_max_sample_size() ;
  ::int32_t max_sample_size() const;
  void set_max_sample_size(::int32_t value);

  private:
  ::int32_t _internal_max_sample_size() const;
  void _internal_set_max_sample_size(::int32_t value);

  public:
  // optional int32 max_clustering_iterations = 4 [default = 10];
  bool has_max_clustering_iterations() const;
  void clear_max_clustering_iterations() ;
  ::int32_t max_clustering_iterations() const;
  void set_max_clustering_iterations(::int32_t value);

  private:
  ::int32_t _internal_max_clustering_iterations() const;
  void _internal_set_max_clustering_iterations(::int32_t value);

  public:
  // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
  bool has_clustering_convergence_tolerance() const;
  void clear_clustering_convergence_tolerance() ;
  float clustering_convergence_tolerance() const;
  void set_clustering_convergence_tolerance(float value);

  private:
  float _internal_clustering_convergence_tolerance() const;
  void _internal_set_clustering_convergence_tolerance(float value);

  public:
  // optional int32 clustering_seed = 9 [default = 1];
  bool has_clustering_seed() const;
  void clear_clustering_seed() ;
  ::int32_t clustering_seed() const;
  void set_clustering_seed(::int32_t value);

  private:
  ::int32_t _internal_clustering_seed() const;
  void _internal_set_clustering_seed(::int32_t value);

  public:
  // optional int32 sampling_seed = 11 [default = 1];
  bool has_sampling_seed() const;
  void clear_sampling_seed() ;
  ::int32_t sampling_seed() const;
  void set_sampling_seed(::int32_t value);

  private:
  ::int32_t _internal_sampling_seed() const;
  void _internal_set_sampling_seed(::int32_t value);

  public:
  // optional int32 ram_gb = 14 [default = 4];
  bool has_ram_gb() const;
  void clear_ram_gb() ;
  ::int32_t ram_gb() const;
  void set_ram_gb(::int32_t value);

  private:
  ::int32_t _internal_ram_gb() const;
  void _internal_set_ram_gb(::int32_t value);

  public:
  // optional int32 num_cpus = 15 [default = 1];
  bool has_num_cpus() const;
  void clear_num_cpus() ;
  ::int32_t num_cpus() const;
  void set_num_cpus(::int32_t value);

  private:
  ::int32_t _internal_num_cpus() const;
  void _internal_set_num_cpus(::int32_t value);

  public:
  // optional double noise_shaping_threshold = 28 [default = nan];
  bool has_noise_shaping_threshold() const;
  void clear_noise_shaping_threshold() ;
  double noise_shaping_threshold() const;
  void set_noise_shaping_threshold(double value);

  private:
  double _internal_noise_shaping_threshold() const;
  void _internal_set_noise_shaping_threshold(double value);

  public:
  // float sampling_fraction = 10 [default = 1];
  bool has_sampling_fraction() const;
  void clear_sampling_fraction() ;
  float sampling_fraction() const;
  void set_sampling_fraction(float value);

  private:
  float _internal_sampling_fraction() const;
  void _internal_set_sampling_fraction(float value);

  public:
  // int32 expected_sample_size = 29;
  bool has_expected_sample_size() const;
  void clear_expected_sample_size() ;
  ::int32_t expected_sample_size() const;
  void set_expected_sample_size(::int32_t value);

  private:
  ::int32_t _internal_expected_sample_size() const;
  void _internal_set_expected_sample_size(::int32_t value);

  public:
  void clear_SamplingFractionOrExpectedSize();
  SamplingFractionOrExpectedSizeCase SamplingFractionOrExpectedSize_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.AsymmetricHasherConfig)
 private:
  class _Internal;
  void set_has_sampling_fraction();
  void set_has_expected_sample_size();

  inline bool has_SamplingFractionOrExpectedSize() const;
  inline void clear_has_SamplingFractionOrExpectedSize();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 31, 6,
      107, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr centers_filename_;
    ::google::protobuf::internal::ArenaStringPtr mr_jobname_prefix_;
    ::google::protobuf::internal::ArenaStringPtr cell_;
    ::research_scann::ProjectionConfig* projection_;
    ::research_scann::DistanceMeasureConfig* quantization_distance_;
    ::research_scann::StackedQuantizersConfig* stacked_quantizers_config_;
    ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* fixed_point_lut_conversion_options_;
    ::int32_t min_number_machines_;
    bool use_per_leaf_partition_training_;
    bool use_noise_shaped_training_;
    bool use_single_machine_trainer_;
    int lookup_type_;
    int quantization_scheme_;
    float partition_level_confidence_interval_stdevs_;
    ::int32_t num_machines_;
    bool use_residual_quantization_;
    bool use_normalized_residual_quantization_;
    bool use_norm_biasing_correction_;
    bool use_global_topn_;
    float min_cluster_size_;
    ::int32_t num_clusters_per_block_;
    ::int32_t max_sample_size_;
    ::int32_t max_clustering_iterations_;
    float clustering_convergence_tolerance_;
    ::int32_t clustering_seed_;
    ::int32_t sampling_seed_;
    ::int32_t ram_gb_;
    ::int32_t num_cpus_;
    double noise_shaping_threshold_;
    union SamplingFractionOrExpectedSizeUnion {
      constexpr SamplingFractionOrExpectedSizeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float sampling_fraction_;
      ::int32_t expected_sample_size_;
    } SamplingFractionOrExpectedSize_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};// -------------------------------------------------------------------

class HashConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.HashConfig) */ {
 public:
  inline HashConfig() : HashConfig(nullptr) {}
  ~HashConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HashConfig(::google::protobuf::internal::ConstantInitialized);

  inline HashConfig(const HashConfig& from)
      : HashConfig(nullptr, from) {}
  HashConfig(HashConfig&& from) noexcept
    : HashConfig() {
    *this = ::std::move(from);
  }

  inline HashConfig& operator=(const HashConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashConfig& operator=(HashConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashConfig* internal_default_instance() {
    return reinterpret_cast<const HashConfig*>(
               &_HashConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HashConfig& a, HashConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HashConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HashConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HashConfig& from) {
    HashConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HashConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.HashConfig";
  }
  protected:
  explicit HashConfig(::google::protobuf::Arena* arena);
  HashConfig(::google::protobuf::Arena* arena, const HashConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ThresholdType = HashConfig_ThresholdType;
  static constexpr ThresholdType UNKNOWN = HashConfig_ThresholdType_UNKNOWN;
  static constexpr ThresholdType SIGN = HashConfig_ThresholdType_SIGN;
  static constexpr ThresholdType MEAN = HashConfig_ThresholdType_MEAN;
  static constexpr ThresholdType MEDIAN = HashConfig_ThresholdType_MEDIAN;
  static constexpr ThresholdType SINUSOIDAL = HashConfig_ThresholdType_SINUSOIDAL;
  static inline bool ThresholdType_IsValid(int value) {
    return HashConfig_ThresholdType_IsValid(value);
  }
  static constexpr ThresholdType ThresholdType_MIN = HashConfig_ThresholdType_ThresholdType_MIN;
  static constexpr ThresholdType ThresholdType_MAX = HashConfig_ThresholdType_ThresholdType_MAX;
  static constexpr int ThresholdType_ARRAYSIZE = HashConfig_ThresholdType_ThresholdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ThresholdType_descriptor() {
    return HashConfig_ThresholdType_descriptor();
  }
  template <typename T>
  static inline const std::string& ThresholdType_Name(T value) {
    return HashConfig_ThresholdType_Name(value);
  }
  static inline bool ThresholdType_Parse(absl::string_view name, ThresholdType* value) {
    return HashConfig_ThresholdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFilenameFieldNumber = 4,
    kProjectionFieldNumber = 2,
    kAsymmetricHashFieldNumber = 5,
    kMinHashFieldNumber = 6,
    kPcaHashFieldNumber = 7,
    kBitSamplingHashFieldNumber = 9,
    kBncHashFieldNumber = 10,
    kNumBitsFieldNumber = 1,
    kThresholdTypeFieldNumber = 3,
  };
  // optional string parameters_filename = 4;
  bool has_parameters_filename() const;
  void clear_parameters_filename() ;
  const std::string& parameters_filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parameters_filename(Arg_&& arg, Args_... args);
  std::string* mutable_parameters_filename();
  PROTOBUF_NODISCARD std::string* release_parameters_filename();
  void set_allocated_parameters_filename(std::string* value);

  private:
  const std::string& _internal_parameters_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameters_filename(
      const std::string& value);
  std::string* _internal_mutable_parameters_filename();

  public:
  // optional .research_scann.ProjectionConfig projection = 2;
  bool has_projection() const;
  void clear_projection() ;
  const ::research_scann::ProjectionConfig& projection() const;
  PROTOBUF_NODISCARD ::research_scann::ProjectionConfig* release_projection();
  ::research_scann::ProjectionConfig* mutable_projection();
  void set_allocated_projection(::research_scann::ProjectionConfig* value);
  void unsafe_arena_set_allocated_projection(::research_scann::ProjectionConfig* value);
  ::research_scann::ProjectionConfig* unsafe_arena_release_projection();

  private:
  const ::research_scann::ProjectionConfig& _internal_projection() const;
  ::research_scann::ProjectionConfig* _internal_mutable_projection();

  public:
  // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
  bool has_asymmetric_hash() const;
  void clear_asymmetric_hash() ;
  const ::research_scann::AsymmetricHasherConfig& asymmetric_hash() const;
  PROTOBUF_NODISCARD ::research_scann::AsymmetricHasherConfig* release_asymmetric_hash();
  ::research_scann::AsymmetricHasherConfig* mutable_asymmetric_hash();
  void set_allocated_asymmetric_hash(::research_scann::AsymmetricHasherConfig* value);
  void unsafe_arena_set_allocated_asymmetric_hash(::research_scann::AsymmetricHasherConfig* value);
  ::research_scann::AsymmetricHasherConfig* unsafe_arena_release_asymmetric_hash();

  private:
  const ::research_scann::AsymmetricHasherConfig& _internal_asymmetric_hash() const;
  ::research_scann::AsymmetricHasherConfig* _internal_mutable_asymmetric_hash();

  public:
  // optional .research_scann.MinHasherConfig min_hash = 6;
  bool has_min_hash() const;
  void clear_min_hash() ;
  const ::research_scann::MinHasherConfig& min_hash() const;
  PROTOBUF_NODISCARD ::research_scann::MinHasherConfig* release_min_hash();
  ::research_scann::MinHasherConfig* mutable_min_hash();
  void set_allocated_min_hash(::research_scann::MinHasherConfig* value);
  void unsafe_arena_set_allocated_min_hash(::research_scann::MinHasherConfig* value);
  ::research_scann::MinHasherConfig* unsafe_arena_release_min_hash();

  private:
  const ::research_scann::MinHasherConfig& _internal_min_hash() const;
  ::research_scann::MinHasherConfig* _internal_mutable_min_hash();

  public:
  // optional .research_scann.PcaHasherConfig pca_hash = 7;
  bool has_pca_hash() const;
  void clear_pca_hash() ;
  const ::research_scann::PcaHasherConfig& pca_hash() const;
  PROTOBUF_NODISCARD ::research_scann::PcaHasherConfig* release_pca_hash();
  ::research_scann::PcaHasherConfig* mutable_pca_hash();
  void set_allocated_pca_hash(::research_scann::PcaHasherConfig* value);
  void unsafe_arena_set_allocated_pca_hash(::research_scann::PcaHasherConfig* value);
  ::research_scann::PcaHasherConfig* unsafe_arena_release_pca_hash();

  private:
  const ::research_scann::PcaHasherConfig& _internal_pca_hash() const;
  ::research_scann::PcaHasherConfig* _internal_mutable_pca_hash();

  public:
  // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
  bool has_bit_sampling_hash() const;
  void clear_bit_sampling_hash() ;
  const ::research_scann::BitSamplingHasherConfig& bit_sampling_hash() const;
  PROTOBUF_NODISCARD ::research_scann::BitSamplingHasherConfig* release_bit_sampling_hash();
  ::research_scann::BitSamplingHasherConfig* mutable_bit_sampling_hash();
  void set_allocated_bit_sampling_hash(::research_scann::BitSamplingHasherConfig* value);
  void unsafe_arena_set_allocated_bit_sampling_hash(::research_scann::BitSamplingHasherConfig* value);
  ::research_scann::BitSamplingHasherConfig* unsafe_arena_release_bit_sampling_hash();

  private:
  const ::research_scann::BitSamplingHasherConfig& _internal_bit_sampling_hash() const;
  ::research_scann::BitSamplingHasherConfig* _internal_mutable_bit_sampling_hash();

  public:
  // optional .research_scann.BncHasherConfig bnc_hash = 10;
  bool has_bnc_hash() const;
  void clear_bnc_hash() ;
  const ::research_scann::BncHasherConfig& bnc_hash() const;
  PROTOBUF_NODISCARD ::research_scann::BncHasherConfig* release_bnc_hash();
  ::research_scann::BncHasherConfig* mutable_bnc_hash();
  void set_allocated_bnc_hash(::research_scann::BncHasherConfig* value);
  void unsafe_arena_set_allocated_bnc_hash(::research_scann::BncHasherConfig* value);
  ::research_scann::BncHasherConfig* unsafe_arena_release_bnc_hash();

  private:
  const ::research_scann::BncHasherConfig& _internal_bnc_hash() const;
  ::research_scann::BncHasherConfig* _internal_mutable_bnc_hash();

  public:
  // optional int32 num_bits = 1;
  bool has_num_bits() const;
  void clear_num_bits() ;
  ::int32_t num_bits() const;
  void set_num_bits(::int32_t value);

  private:
  ::int32_t _internal_num_bits() const;
  void _internal_set_num_bits(::int32_t value);

  public:
  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  bool has_threshold_type() const;
  void clear_threshold_type() ;
  ::research_scann::HashConfig_ThresholdType threshold_type() const;
  void set_threshold_type(::research_scann::HashConfig_ThresholdType value);

  private:
  ::research_scann::HashConfig_ThresholdType _internal_threshold_type() const;
  void _internal_set_threshold_type(::research_scann::HashConfig_ThresholdType value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.HashConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 7,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr parameters_filename_;
    ::research_scann::ProjectionConfig* projection_;
    ::research_scann::AsymmetricHasherConfig* asymmetric_hash_;
    ::research_scann::MinHasherConfig* min_hash_;
    ::research_scann::PcaHasherConfig* pca_hash_;
    ::research_scann::BitSamplingHasherConfig* bit_sampling_hash_;
    ::research_scann::BncHasherConfig* bnc_hash_;
    ::int32_t num_bits_;
    int threshold_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HashConfig

// optional int32 num_bits = 1;
inline bool HashConfig::has_num_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void HashConfig::clear_num_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_bits_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t HashConfig::num_bits() const {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.num_bits)
  return _internal_num_bits();
}
inline void HashConfig::set_num_bits(::int32_t value) {
  _internal_set_num_bits(value);
  // @@protoc_insertion_point(field_set:research_scann.HashConfig.num_bits)
}
inline ::int32_t HashConfig::_internal_num_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_bits_;
}
inline void HashConfig::_internal_set_num_bits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.num_bits_ = value;
}

// optional .research_scann.ProjectionConfig projection = 2;
inline bool HashConfig::has_projection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.projection_ != nullptr);
  return value;
}
inline const ::research_scann::ProjectionConfig& HashConfig::_internal_projection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::ProjectionConfig* p = _impl_.projection_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::ProjectionConfig&>(::research_scann::_ProjectionConfig_default_instance_);
}
inline const ::research_scann::ProjectionConfig& HashConfig::projection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.projection)
  return _internal_projection();
}
inline void HashConfig::unsafe_arena_set_allocated_projection(::research_scann::ProjectionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }
  _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HashConfig.projection)
}
inline ::research_scann::ProjectionConfig* HashConfig::release_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::research_scann::ProjectionConfig* released = _impl_.projection_;
  _impl_.projection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::ProjectionConfig* HashConfig::unsafe_arena_release_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.projection)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::research_scann::ProjectionConfig* temp = _impl_.projection_;
  _impl_.projection_ = nullptr;
  return temp;
}
inline ::research_scann::ProjectionConfig* HashConfig::_internal_mutable_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.projection_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ProjectionConfig>(GetArena());
    _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(p);
  }
  return _impl_.projection_;
}
inline ::research_scann::ProjectionConfig* HashConfig::mutable_projection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::ProjectionConfig* _msg = _internal_mutable_projection();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.projection)
  return _msg;
}
inline void HashConfig::set_allocated_projection(::research_scann::ProjectionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.projection)
}

// optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
inline bool HashConfig::has_threshold_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void HashConfig::clear_threshold_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.threshold_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::research_scann::HashConfig_ThresholdType HashConfig::threshold_type() const {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.threshold_type)
  return _internal_threshold_type();
}
inline void HashConfig::set_threshold_type(::research_scann::HashConfig_ThresholdType value) {
  _internal_set_threshold_type(value);
  // @@protoc_insertion_point(field_set:research_scann.HashConfig.threshold_type)
}
inline ::research_scann::HashConfig_ThresholdType HashConfig::_internal_threshold_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::HashConfig_ThresholdType>(_impl_.threshold_type_);
}
inline void HashConfig::_internal_set_threshold_type(::research_scann::HashConfig_ThresholdType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::HashConfig_ThresholdType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.threshold_type_ = value;
}

// optional string parameters_filename = 4;
inline bool HashConfig::has_parameters_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HashConfig::clear_parameters_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HashConfig::parameters_filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.parameters_filename)
  return _internal_parameters_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashConfig::set_parameters_filename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parameters_filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.HashConfig.parameters_filename)
}
inline std::string* HashConfig::mutable_parameters_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parameters_filename();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.parameters_filename)
  return _s;
}
inline const std::string& HashConfig::_internal_parameters_filename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_filename_.Get();
}
inline void HashConfig::_internal_set_parameters_filename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parameters_filename_.Set(value, GetArena());
}
inline std::string* HashConfig::_internal_mutable_parameters_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parameters_filename_.Mutable( GetArena());
}
inline std::string* HashConfig::release_parameters_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.parameters_filename)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.parameters_filename_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parameters_filename_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void HashConfig::set_allocated_parameters_filename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parameters_filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parameters_filename_.IsDefault()) {
          _impl_.parameters_filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.parameters_filename)
}

// optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
inline bool HashConfig::has_asymmetric_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.asymmetric_hash_ != nullptr);
  return value;
}
inline void HashConfig::clear_asymmetric_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.asymmetric_hash_ != nullptr) _impl_.asymmetric_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::research_scann::AsymmetricHasherConfig& HashConfig::_internal_asymmetric_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::AsymmetricHasherConfig* p = _impl_.asymmetric_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::AsymmetricHasherConfig&>(::research_scann::_AsymmetricHasherConfig_default_instance_);
}
inline const ::research_scann::AsymmetricHasherConfig& HashConfig::asymmetric_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.asymmetric_hash)
  return _internal_asymmetric_hash();
}
inline void HashConfig::unsafe_arena_set_allocated_asymmetric_hash(::research_scann::AsymmetricHasherConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.asymmetric_hash_);
  }
  _impl_.asymmetric_hash_ = reinterpret_cast<::research_scann::AsymmetricHasherConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HashConfig.asymmetric_hash)
}
inline ::research_scann::AsymmetricHasherConfig* HashConfig::release_asymmetric_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::research_scann::AsymmetricHasherConfig* released = _impl_.asymmetric_hash_;
  _impl_.asymmetric_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::AsymmetricHasherConfig* HashConfig::unsafe_arena_release_asymmetric_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.asymmetric_hash)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::research_scann::AsymmetricHasherConfig* temp = _impl_.asymmetric_hash_;
  _impl_.asymmetric_hash_ = nullptr;
  return temp;
}
inline ::research_scann::AsymmetricHasherConfig* HashConfig::_internal_mutable_asymmetric_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.asymmetric_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::AsymmetricHasherConfig>(GetArena());
    _impl_.asymmetric_hash_ = reinterpret_cast<::research_scann::AsymmetricHasherConfig*>(p);
  }
  return _impl_.asymmetric_hash_;
}
inline ::research_scann::AsymmetricHasherConfig* HashConfig::mutable_asymmetric_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::AsymmetricHasherConfig* _msg = _internal_mutable_asymmetric_hash();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.asymmetric_hash)
  return _msg;
}
inline void HashConfig::set_allocated_asymmetric_hash(::research_scann::AsymmetricHasherConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::AsymmetricHasherConfig*>(_impl_.asymmetric_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::AsymmetricHasherConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.asymmetric_hash_ = reinterpret_cast<::research_scann::AsymmetricHasherConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.asymmetric_hash)
}

// optional .research_scann.MinHasherConfig min_hash = 6;
inline bool HashConfig::has_min_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_hash_ != nullptr);
  return value;
}
inline void HashConfig::clear_min_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_hash_ != nullptr) _impl_.min_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::research_scann::MinHasherConfig& HashConfig::_internal_min_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::MinHasherConfig* p = _impl_.min_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::MinHasherConfig&>(::research_scann::_MinHasherConfig_default_instance_);
}
inline const ::research_scann::MinHasherConfig& HashConfig::min_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.min_hash)
  return _internal_min_hash();
}
inline void HashConfig::unsafe_arena_set_allocated_min_hash(::research_scann::MinHasherConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_hash_);
  }
  _impl_.min_hash_ = reinterpret_cast<::research_scann::MinHasherConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HashConfig.min_hash)
}
inline ::research_scann::MinHasherConfig* HashConfig::release_min_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::research_scann::MinHasherConfig* released = _impl_.min_hash_;
  _impl_.min_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::MinHasherConfig* HashConfig::unsafe_arena_release_min_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.min_hash)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::research_scann::MinHasherConfig* temp = _impl_.min_hash_;
  _impl_.min_hash_ = nullptr;
  return temp;
}
inline ::research_scann::MinHasherConfig* HashConfig::_internal_mutable_min_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.min_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::MinHasherConfig>(GetArena());
    _impl_.min_hash_ = reinterpret_cast<::research_scann::MinHasherConfig*>(p);
  }
  return _impl_.min_hash_;
}
inline ::research_scann::MinHasherConfig* HashConfig::mutable_min_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::MinHasherConfig* _msg = _internal_mutable_min_hash();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.min_hash)
  return _msg;
}
inline void HashConfig::set_allocated_min_hash(::research_scann::MinHasherConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::MinHasherConfig*>(_impl_.min_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::MinHasherConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.min_hash_ = reinterpret_cast<::research_scann::MinHasherConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.min_hash)
}

// optional .research_scann.PcaHasherConfig pca_hash = 7;
inline bool HashConfig::has_pca_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pca_hash_ != nullptr);
  return value;
}
inline void HashConfig::clear_pca_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pca_hash_ != nullptr) _impl_.pca_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::research_scann::PcaHasherConfig& HashConfig::_internal_pca_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::PcaHasherConfig* p = _impl_.pca_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::PcaHasherConfig&>(::research_scann::_PcaHasherConfig_default_instance_);
}
inline const ::research_scann::PcaHasherConfig& HashConfig::pca_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.pca_hash)
  return _internal_pca_hash();
}
inline void HashConfig::unsafe_arena_set_allocated_pca_hash(::research_scann::PcaHasherConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pca_hash_);
  }
  _impl_.pca_hash_ = reinterpret_cast<::research_scann::PcaHasherConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HashConfig.pca_hash)
}
inline ::research_scann::PcaHasherConfig* HashConfig::release_pca_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::research_scann::PcaHasherConfig* released = _impl_.pca_hash_;
  _impl_.pca_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::PcaHasherConfig* HashConfig::unsafe_arena_release_pca_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.pca_hash)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::research_scann::PcaHasherConfig* temp = _impl_.pca_hash_;
  _impl_.pca_hash_ = nullptr;
  return temp;
}
inline ::research_scann::PcaHasherConfig* HashConfig::_internal_mutable_pca_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.pca_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::PcaHasherConfig>(GetArena());
    _impl_.pca_hash_ = reinterpret_cast<::research_scann::PcaHasherConfig*>(p);
  }
  return _impl_.pca_hash_;
}
inline ::research_scann::PcaHasherConfig* HashConfig::mutable_pca_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::PcaHasherConfig* _msg = _internal_mutable_pca_hash();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.pca_hash)
  return _msg;
}
inline void HashConfig::set_allocated_pca_hash(::research_scann::PcaHasherConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::PcaHasherConfig*>(_impl_.pca_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::PcaHasherConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.pca_hash_ = reinterpret_cast<::research_scann::PcaHasherConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.pca_hash)
}

// optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
inline bool HashConfig::has_bit_sampling_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bit_sampling_hash_ != nullptr);
  return value;
}
inline void HashConfig::clear_bit_sampling_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bit_sampling_hash_ != nullptr) _impl_.bit_sampling_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::research_scann::BitSamplingHasherConfig& HashConfig::_internal_bit_sampling_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::BitSamplingHasherConfig* p = _impl_.bit_sampling_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::BitSamplingHasherConfig&>(::research_scann::_BitSamplingHasherConfig_default_instance_);
}
inline const ::research_scann::BitSamplingHasherConfig& HashConfig::bit_sampling_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.bit_sampling_hash)
  return _internal_bit_sampling_hash();
}
inline void HashConfig::unsafe_arena_set_allocated_bit_sampling_hash(::research_scann::BitSamplingHasherConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bit_sampling_hash_);
  }
  _impl_.bit_sampling_hash_ = reinterpret_cast<::research_scann::BitSamplingHasherConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HashConfig.bit_sampling_hash)
}
inline ::research_scann::BitSamplingHasherConfig* HashConfig::release_bit_sampling_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::BitSamplingHasherConfig* released = _impl_.bit_sampling_hash_;
  _impl_.bit_sampling_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::BitSamplingHasherConfig* HashConfig::unsafe_arena_release_bit_sampling_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.bit_sampling_hash)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::BitSamplingHasherConfig* temp = _impl_.bit_sampling_hash_;
  _impl_.bit_sampling_hash_ = nullptr;
  return temp;
}
inline ::research_scann::BitSamplingHasherConfig* HashConfig::_internal_mutable_bit_sampling_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.bit_sampling_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::BitSamplingHasherConfig>(GetArena());
    _impl_.bit_sampling_hash_ = reinterpret_cast<::research_scann::BitSamplingHasherConfig*>(p);
  }
  return _impl_.bit_sampling_hash_;
}
inline ::research_scann::BitSamplingHasherConfig* HashConfig::mutable_bit_sampling_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::BitSamplingHasherConfig* _msg = _internal_mutable_bit_sampling_hash();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.bit_sampling_hash)
  return _msg;
}
inline void HashConfig::set_allocated_bit_sampling_hash(::research_scann::BitSamplingHasherConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::BitSamplingHasherConfig*>(_impl_.bit_sampling_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::BitSamplingHasherConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.bit_sampling_hash_ = reinterpret_cast<::research_scann::BitSamplingHasherConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.bit_sampling_hash)
}

// optional .research_scann.BncHasherConfig bnc_hash = 10;
inline bool HashConfig::has_bnc_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bnc_hash_ != nullptr);
  return value;
}
inline void HashConfig::clear_bnc_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bnc_hash_ != nullptr) _impl_.bnc_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::research_scann::BncHasherConfig& HashConfig::_internal_bnc_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::BncHasherConfig* p = _impl_.bnc_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::BncHasherConfig&>(::research_scann::_BncHasherConfig_default_instance_);
}
inline const ::research_scann::BncHasherConfig& HashConfig::bnc_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.bnc_hash)
  return _internal_bnc_hash();
}
inline void HashConfig::unsafe_arena_set_allocated_bnc_hash(::research_scann::BncHasherConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bnc_hash_);
  }
  _impl_.bnc_hash_ = reinterpret_cast<::research_scann::BncHasherConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HashConfig.bnc_hash)
}
inline ::research_scann::BncHasherConfig* HashConfig::release_bnc_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::BncHasherConfig* released = _impl_.bnc_hash_;
  _impl_.bnc_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::BncHasherConfig* HashConfig::unsafe_arena_release_bnc_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.bnc_hash)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::BncHasherConfig* temp = _impl_.bnc_hash_;
  _impl_.bnc_hash_ = nullptr;
  return temp;
}
inline ::research_scann::BncHasherConfig* HashConfig::_internal_mutable_bnc_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.bnc_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::BncHasherConfig>(GetArena());
    _impl_.bnc_hash_ = reinterpret_cast<::research_scann::BncHasherConfig*>(p);
  }
  return _impl_.bnc_hash_;
}
inline ::research_scann::BncHasherConfig* HashConfig::mutable_bnc_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::BncHasherConfig* _msg = _internal_mutable_bnc_hash();
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.bnc_hash)
  return _msg;
}
inline void HashConfig::set_allocated_bnc_hash(::research_scann::BncHasherConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::BncHasherConfig*>(_impl_.bnc_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::BncHasherConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.bnc_hash_ = reinterpret_cast<::research_scann::BncHasherConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.bnc_hash)
}

// -------------------------------------------------------------------

// AsymmetricHasherConfig_FixedPointLUTConversionOptions

// optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
inline bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::has_float_to_int_conversion_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::clear_float_to_int_conversion_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.float_to_int_conversion_method_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::float_to_int_conversion_method() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.float_to_int_conversion_method)
  return _internal_float_to_int_conversion_method();
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::set_float_to_int_conversion_method(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value) {
  _internal_set_float_to_int_conversion_method(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.float_to_int_conversion_method)
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::_internal_float_to_int_conversion_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(_impl_.float_to_int_conversion_method_);
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::_internal_set_float_to_int_conversion_method(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.float_to_int_conversion_method_ = value;
}

// optional float multiplier_quantile = 2 [default = 1];
inline bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::has_multiplier_quantile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::clear_multiplier_quantile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multiplier_quantile_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float AsymmetricHasherConfig_FixedPointLUTConversionOptions::multiplier_quantile() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.multiplier_quantile)
  return _internal_multiplier_quantile();
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::set_multiplier_quantile(float value) {
  _internal_set_multiplier_quantile(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.multiplier_quantile)
}
inline float AsymmetricHasherConfig_FixedPointLUTConversionOptions::_internal_multiplier_quantile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multiplier_quantile_;
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::_internal_set_multiplier_quantile(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.multiplier_quantile_ = value;
}

// -------------------------------------------------------------------

// AsymmetricHasherConfig

// optional .research_scann.ProjectionConfig projection = 1;
inline bool AsymmetricHasherConfig::has_projection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.projection_ != nullptr);
  return value;
}
inline const ::research_scann::ProjectionConfig& AsymmetricHasherConfig::_internal_projection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::ProjectionConfig* p = _impl_.projection_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::ProjectionConfig&>(::research_scann::_ProjectionConfig_default_instance_);
}
inline const ::research_scann::ProjectionConfig& AsymmetricHasherConfig::projection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.projection)
  return _internal_projection();
}
inline void AsymmetricHasherConfig::unsafe_arena_set_allocated_projection(::research_scann::ProjectionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }
  _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.AsymmetricHasherConfig.projection)
}
inline ::research_scann::ProjectionConfig* AsymmetricHasherConfig::release_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::research_scann::ProjectionConfig* released = _impl_.projection_;
  _impl_.projection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::ProjectionConfig* AsymmetricHasherConfig::unsafe_arena_release_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.projection)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::research_scann::ProjectionConfig* temp = _impl_.projection_;
  _impl_.projection_ = nullptr;
  return temp;
}
inline ::research_scann::ProjectionConfig* AsymmetricHasherConfig::_internal_mutable_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.projection_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ProjectionConfig>(GetArena());
    _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(p);
  }
  return _impl_.projection_;
}
inline ::research_scann::ProjectionConfig* AsymmetricHasherConfig::mutable_projection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::ProjectionConfig* _msg = _internal_mutable_projection();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.projection)
  return _msg;
}
inline void AsymmetricHasherConfig::set_allocated_projection(::research_scann::ProjectionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.projection)
}

// optional int32 num_clusters_per_block = 2 [default = 256];
inline bool AsymmetricHasherConfig::has_num_clusters_per_block() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_num_clusters_per_block() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_clusters_per_block_ = 256;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::int32_t AsymmetricHasherConfig::num_clusters_per_block() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.num_clusters_per_block)
  return _internal_num_clusters_per_block();
}
inline void AsymmetricHasherConfig::set_num_clusters_per_block(::int32_t value) {
  _internal_set_num_clusters_per_block(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.num_clusters_per_block)
}
inline ::int32_t AsymmetricHasherConfig::_internal_num_clusters_per_block() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_clusters_per_block_;
}
inline void AsymmetricHasherConfig::_internal_set_num_clusters_per_block(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.num_clusters_per_block_ = value;
}

// optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
inline bool AsymmetricHasherConfig::has_lookup_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_lookup_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lookup_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::research_scann::AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::lookup_type() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.lookup_type)
  return _internal_lookup_type();
}
inline void AsymmetricHasherConfig::set_lookup_type(::research_scann::AsymmetricHasherConfig_LookupType value) {
  _internal_set_lookup_type(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.lookup_type)
}
inline ::research_scann::AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::_internal_lookup_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::AsymmetricHasherConfig_LookupType>(_impl_.lookup_type_);
}
inline void AsymmetricHasherConfig::_internal_set_lookup_type(::research_scann::AsymmetricHasherConfig_LookupType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::AsymmetricHasherConfig_LookupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.lookup_type_ = value;
}

// optional int32 clustering_seed = 9 [default = 1];
inline bool AsymmetricHasherConfig::has_clustering_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_clustering_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clustering_seed_ = 1;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::int32_t AsymmetricHasherConfig::clustering_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.clustering_seed)
  return _internal_clustering_seed();
}
inline void AsymmetricHasherConfig::set_clustering_seed(::int32_t value) {
  _internal_set_clustering_seed(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.clustering_seed)
}
inline ::int32_t AsymmetricHasherConfig::_internal_clustering_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clustering_seed_;
}
inline void AsymmetricHasherConfig::_internal_set_clustering_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.clustering_seed_ = value;
}

// optional bool use_residual_quantization = 22 [default = false];
inline bool AsymmetricHasherConfig::has_use_residual_quantization() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_residual_quantization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_residual_quantization_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool AsymmetricHasherConfig::use_residual_quantization() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_residual_quantization)
  return _internal_use_residual_quantization();
}
inline void AsymmetricHasherConfig::set_use_residual_quantization(bool value) {
  _internal_set_use_residual_quantization(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_residual_quantization)
}
inline bool AsymmetricHasherConfig::_internal_use_residual_quantization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_residual_quantization_;
}
inline void AsymmetricHasherConfig::_internal_set_use_residual_quantization(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.use_residual_quantization_ = value;
}

// optional bool use_normalized_residual_quantization = 32 [default = false];
inline bool AsymmetricHasherConfig::has_use_normalized_residual_quantization() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_normalized_residual_quantization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_normalized_residual_quantization_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool AsymmetricHasherConfig::use_normalized_residual_quantization() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_normalized_residual_quantization)
  return _internal_use_normalized_residual_quantization();
}
inline void AsymmetricHasherConfig::set_use_normalized_residual_quantization(bool value) {
  _internal_set_use_normalized_residual_quantization(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_normalized_residual_quantization)
}
inline bool AsymmetricHasherConfig::_internal_use_normalized_residual_quantization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_normalized_residual_quantization_;
}
inline void AsymmetricHasherConfig::_internal_set_use_normalized_residual_quantization(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.use_normalized_residual_quantization_ = value;
}

// optional double noise_shaping_threshold = 28 [default = nan];
inline bool AsymmetricHasherConfig::has_noise_shaping_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_noise_shaping_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noise_shaping_threshold_ = std::numeric_limits<double>::quiet_NaN();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline double AsymmetricHasherConfig::noise_shaping_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.noise_shaping_threshold)
  return _internal_noise_shaping_threshold();
}
inline void AsymmetricHasherConfig::set_noise_shaping_threshold(double value) {
  _internal_set_noise_shaping_threshold(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.noise_shaping_threshold)
}
inline double AsymmetricHasherConfig::_internal_noise_shaping_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noise_shaping_threshold_;
}
inline void AsymmetricHasherConfig::_internal_set_noise_shaping_threshold(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.noise_shaping_threshold_ = value;
}

// optional bool use_norm_biasing_correction = 31 [default = false];
inline bool AsymmetricHasherConfig::has_use_norm_biasing_correction() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_norm_biasing_correction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_norm_biasing_correction_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool AsymmetricHasherConfig::use_norm_biasing_correction() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_norm_biasing_correction)
  return _internal_use_norm_biasing_correction();
}
inline void AsymmetricHasherConfig::set_use_norm_biasing_correction(bool value) {
  _internal_set_use_norm_biasing_correction(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_norm_biasing_correction)
}
inline bool AsymmetricHasherConfig::_internal_use_norm_biasing_correction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_norm_biasing_correction_;
}
inline void AsymmetricHasherConfig::_internal_set_use_norm_biasing_correction(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.use_norm_biasing_correction_ = value;
}

// optional bool use_global_topn = 33 [default = false];
inline bool AsymmetricHasherConfig::has_use_global_topn() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_global_topn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_global_topn_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool AsymmetricHasherConfig::use_global_topn() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_global_topn)
  return _internal_use_global_topn();
}
inline void AsymmetricHasherConfig::set_use_global_topn(bool value) {
  _internal_set_use_global_topn(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_global_topn)
}
inline bool AsymmetricHasherConfig::_internal_use_global_topn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_global_topn_;
}
inline void AsymmetricHasherConfig::_internal_set_use_global_topn(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.use_global_topn_ = value;
}

// optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
inline bool AsymmetricHasherConfig::has_fixed_point_lut_conversion_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fixed_point_lut_conversion_options_ != nullptr);
  return value;
}
inline void AsymmetricHasherConfig::clear_fixed_point_lut_conversion_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fixed_point_lut_conversion_options_ != nullptr) _impl_.fixed_point_lut_conversion_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& AsymmetricHasherConfig::_internal_fixed_point_lut_conversion_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* p = _impl_.fixed_point_lut_conversion_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions&>(::research_scann::_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_);
}
inline const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& AsymmetricHasherConfig::fixed_point_lut_conversion_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
  return _internal_fixed_point_lut_conversion_options();
}
inline void AsymmetricHasherConfig::unsafe_arena_set_allocated_fixed_point_lut_conversion_options(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fixed_point_lut_conversion_options_);
  }
  _impl_.fixed_point_lut_conversion_options_ = reinterpret_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* AsymmetricHasherConfig::release_fixed_point_lut_conversion_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* released = _impl_.fixed_point_lut_conversion_options_;
  _impl_.fixed_point_lut_conversion_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* AsymmetricHasherConfig::unsafe_arena_release_fixed_point_lut_conversion_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* temp = _impl_.fixed_point_lut_conversion_options_;
  _impl_.fixed_point_lut_conversion_options_ = nullptr;
  return temp;
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* AsymmetricHasherConfig::_internal_mutable_fixed_point_lut_conversion_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.fixed_point_lut_conversion_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions>(GetArena());
    _impl_.fixed_point_lut_conversion_options_ = reinterpret_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(p);
  }
  return _impl_.fixed_point_lut_conversion_options_;
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* AsymmetricHasherConfig::mutable_fixed_point_lut_conversion_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* _msg = _internal_mutable_fixed_point_lut_conversion_options();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
  return _msg;
}
inline void AsymmetricHasherConfig::set_allocated_fixed_point_lut_conversion_options(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(_impl_.fixed_point_lut_conversion_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.fixed_point_lut_conversion_options_ = reinterpret_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
}

// float sampling_fraction = 10 [default = 1];
inline bool AsymmetricHasherConfig::has_sampling_fraction() const {
  return SamplingFractionOrExpectedSize_case() == kSamplingFraction;
}
inline void AsymmetricHasherConfig::set_has_sampling_fraction() {
  _impl_._oneof_case_[0] = kSamplingFraction;
}
inline void AsymmetricHasherConfig::clear_sampling_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (SamplingFractionOrExpectedSize_case() == kSamplingFraction) {
    _impl_.SamplingFractionOrExpectedSize_.sampling_fraction_ = 1;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline float AsymmetricHasherConfig::sampling_fraction() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.sampling_fraction)
  return _internal_sampling_fraction();
}
inline void AsymmetricHasherConfig::set_sampling_fraction(float value) {
  _internal_set_sampling_fraction(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.sampling_fraction)
}
inline float AsymmetricHasherConfig::_internal_sampling_fraction() const {
  if (SamplingFractionOrExpectedSize_case() == kSamplingFraction) {
    return _impl_.SamplingFractionOrExpectedSize_.sampling_fraction_;
  }
  return 1;
}
inline void AsymmetricHasherConfig::_internal_set_sampling_fraction(float value) {
  if (SamplingFractionOrExpectedSize_case() != kSamplingFraction) {
    clear_SamplingFractionOrExpectedSize();
    set_has_sampling_fraction();
  }
  _impl_.SamplingFractionOrExpectedSize_.sampling_fraction_ = value;
}

// int32 expected_sample_size = 29;
inline bool AsymmetricHasherConfig::has_expected_sample_size() const {
  return SamplingFractionOrExpectedSize_case() == kExpectedSampleSize;
}
inline void AsymmetricHasherConfig::set_has_expected_sample_size() {
  _impl_._oneof_case_[0] = kExpectedSampleSize;
}
inline void AsymmetricHasherConfig::clear_expected_sample_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (SamplingFractionOrExpectedSize_case() == kExpectedSampleSize) {
    _impl_.SamplingFractionOrExpectedSize_.expected_sample_size_ = 0;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline ::int32_t AsymmetricHasherConfig::expected_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.expected_sample_size)
  return _internal_expected_sample_size();
}
inline void AsymmetricHasherConfig::set_expected_sample_size(::int32_t value) {
  _internal_set_expected_sample_size(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.expected_sample_size)
}
inline ::int32_t AsymmetricHasherConfig::_internal_expected_sample_size() const {
  if (SamplingFractionOrExpectedSize_case() == kExpectedSampleSize) {
    return _impl_.SamplingFractionOrExpectedSize_.expected_sample_size_;
  }
  return 0;
}
inline void AsymmetricHasherConfig::_internal_set_expected_sample_size(::int32_t value) {
  if (SamplingFractionOrExpectedSize_case() != kExpectedSampleSize) {
    clear_SamplingFractionOrExpectedSize();
    set_has_expected_sample_size();
  }
  _impl_.SamplingFractionOrExpectedSize_.expected_sample_size_ = value;
}

// optional int32 sampling_seed = 11 [default = 1];
inline bool AsymmetricHasherConfig::has_sampling_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_sampling_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampling_seed_ = 1;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::int32_t AsymmetricHasherConfig::sampling_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.sampling_seed)
  return _internal_sampling_seed();
}
inline void AsymmetricHasherConfig::set_sampling_seed(::int32_t value) {
  _internal_set_sampling_seed(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.sampling_seed)
}
inline ::int32_t AsymmetricHasherConfig::_internal_sampling_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampling_seed_;
}
inline void AsymmetricHasherConfig::_internal_set_sampling_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.sampling_seed_ = value;
}

// optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
inline bool AsymmetricHasherConfig::has_quantization_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quantization_distance_ != nullptr);
  return value;
}
inline const ::research_scann::DistanceMeasureConfig& AsymmetricHasherConfig::_internal_quantization_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::DistanceMeasureConfig* p = _impl_.quantization_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::DistanceMeasureConfig&>(::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline const ::research_scann::DistanceMeasureConfig& AsymmetricHasherConfig::quantization_distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.quantization_distance)
  return _internal_quantization_distance();
}
inline void AsymmetricHasherConfig::unsafe_arena_set_allocated_quantization_distance(::research_scann::DistanceMeasureConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_distance_);
  }
  _impl_.quantization_distance_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.AsymmetricHasherConfig.quantization_distance)
}
inline ::research_scann::DistanceMeasureConfig* AsymmetricHasherConfig::release_quantization_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::research_scann::DistanceMeasureConfig* released = _impl_.quantization_distance_;
  _impl_.quantization_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::DistanceMeasureConfig* AsymmetricHasherConfig::unsafe_arena_release_quantization_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.quantization_distance)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::research_scann::DistanceMeasureConfig* temp = _impl_.quantization_distance_;
  _impl_.quantization_distance_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* AsymmetricHasherConfig::_internal_mutable_quantization_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.quantization_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArena());
    _impl_.quantization_distance_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(p);
  }
  return _impl_.quantization_distance_;
}
inline ::research_scann::DistanceMeasureConfig* AsymmetricHasherConfig::mutable_quantization_distance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::DistanceMeasureConfig* _msg = _internal_mutable_quantization_distance();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.quantization_distance)
  return _msg;
}
inline void AsymmetricHasherConfig::set_allocated_quantization_distance(::research_scann::DistanceMeasureConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_distance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.quantization_distance_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.quantization_distance)
}

// optional int32 max_clustering_iterations = 4 [default = 10];
inline bool AsymmetricHasherConfig::has_max_clustering_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_max_clustering_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_clustering_iterations_ = 10;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::int32_t AsymmetricHasherConfig::max_clustering_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.max_clustering_iterations)
  return _internal_max_clustering_iterations();
}
inline void AsymmetricHasherConfig::set_max_clustering_iterations(::int32_t value) {
  _internal_set_max_clustering_iterations(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.max_clustering_iterations)
}
inline ::int32_t AsymmetricHasherConfig::_internal_max_clustering_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_clustering_iterations_;
}
inline void AsymmetricHasherConfig::_internal_set_max_clustering_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.max_clustering_iterations_ = value;
}

// optional float clustering_convergence_tolerance = 5 [default = 1e-05];
inline bool AsymmetricHasherConfig::has_clustering_convergence_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_clustering_convergence_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clustering_convergence_tolerance_ = 1e-05f;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline float AsymmetricHasherConfig::clustering_convergence_tolerance() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.clustering_convergence_tolerance)
  return _internal_clustering_convergence_tolerance();
}
inline void AsymmetricHasherConfig::set_clustering_convergence_tolerance(float value) {
  _internal_set_clustering_convergence_tolerance(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.clustering_convergence_tolerance)
}
inline float AsymmetricHasherConfig::_internal_clustering_convergence_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clustering_convergence_tolerance_;
}
inline void AsymmetricHasherConfig::_internal_set_clustering_convergence_tolerance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.clustering_convergence_tolerance_ = value;
}

// optional string centers_filename = 6;
inline bool AsymmetricHasherConfig::has_centers_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_centers_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.centers_filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AsymmetricHasherConfig::centers_filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.centers_filename)
  return _internal_centers_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricHasherConfig::set_centers_filename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.centers_filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.centers_filename)
}
inline std::string* AsymmetricHasherConfig::mutable_centers_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_centers_filename();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.centers_filename)
  return _s;
}
inline const std::string& AsymmetricHasherConfig::_internal_centers_filename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.centers_filename_.Get();
}
inline void AsymmetricHasherConfig::_internal_set_centers_filename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.centers_filename_.Set(value, GetArena());
}
inline std::string* AsymmetricHasherConfig::_internal_mutable_centers_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.centers_filename_.Mutable( GetArena());
}
inline std::string* AsymmetricHasherConfig::release_centers_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.centers_filename)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.centers_filename_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.centers_filename_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AsymmetricHasherConfig::set_allocated_centers_filename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.centers_filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.centers_filename_.IsDefault()) {
          _impl_.centers_filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.centers_filename)
}

// optional int32 num_machines = 27;
inline bool AsymmetricHasherConfig::has_num_machines() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_num_machines() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_machines_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t AsymmetricHasherConfig::num_machines() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.num_machines)
  return _internal_num_machines();
}
inline void AsymmetricHasherConfig::set_num_machines(::int32_t value) {
  _internal_set_num_machines(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.num_machines)
}
inline ::int32_t AsymmetricHasherConfig::_internal_num_machines() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_machines_;
}
inline void AsymmetricHasherConfig::_internal_set_num_machines(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.num_machines_ = value;
}

// optional bool use_per_leaf_partition_training = 17 [default = false];
inline bool AsymmetricHasherConfig::has_use_per_leaf_partition_training() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_per_leaf_partition_training() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_per_leaf_partition_training_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AsymmetricHasherConfig::use_per_leaf_partition_training() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_per_leaf_partition_training)
  return _internal_use_per_leaf_partition_training();
}
inline void AsymmetricHasherConfig::set_use_per_leaf_partition_training(bool value) {
  _internal_set_use_per_leaf_partition_training(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_per_leaf_partition_training)
}
inline bool AsymmetricHasherConfig::_internal_use_per_leaf_partition_training() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_per_leaf_partition_training_;
}
inline void AsymmetricHasherConfig::_internal_set_use_per_leaf_partition_training(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.use_per_leaf_partition_training_ = value;
}

// optional string mr_jobname_prefix = 12;
inline bool AsymmetricHasherConfig::has_mr_jobname_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_mr_jobname_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mr_jobname_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AsymmetricHasherConfig::mr_jobname_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
  return _internal_mr_jobname_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricHasherConfig::set_mr_jobname_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mr_jobname_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}
inline std::string* AsymmetricHasherConfig::mutable_mr_jobname_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mr_jobname_prefix();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
  return _s;
}
inline const std::string& AsymmetricHasherConfig::_internal_mr_jobname_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mr_jobname_prefix_.Get();
}
inline void AsymmetricHasherConfig::_internal_set_mr_jobname_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mr_jobname_prefix_.Set(value, GetArena());
}
inline std::string* AsymmetricHasherConfig::_internal_mutable_mr_jobname_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mr_jobname_prefix_.Mutable( GetArena());
}
inline std::string* AsymmetricHasherConfig::release_mr_jobname_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.mr_jobname_prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mr_jobname_prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AsymmetricHasherConfig::set_allocated_mr_jobname_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mr_jobname_prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mr_jobname_prefix_.IsDefault()) {
          _impl_.mr_jobname_prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}

// optional string cell = 13;
inline bool AsymmetricHasherConfig::has_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cell_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AsymmetricHasherConfig::cell() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.cell)
  return _internal_cell();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricHasherConfig::set_cell(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cell_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.cell)
}
inline std::string* AsymmetricHasherConfig::mutable_cell() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.cell)
  return _s;
}
inline const std::string& AsymmetricHasherConfig::_internal_cell() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cell_.Get();
}
inline void AsymmetricHasherConfig::_internal_set_cell(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cell_.Set(value, GetArena());
}
inline std::string* AsymmetricHasherConfig::_internal_mutable_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.cell_.Mutable( GetArena());
}
inline std::string* AsymmetricHasherConfig::release_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.cell)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.cell_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cell_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AsymmetricHasherConfig::set_allocated_cell(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cell_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cell_.IsDefault()) {
          _impl_.cell_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.cell)
}

// optional int32 ram_gb = 14 [default = 4];
inline bool AsymmetricHasherConfig::has_ram_gb() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_ram_gb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ram_gb_ = 4;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::int32_t AsymmetricHasherConfig::ram_gb() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.ram_gb)
  return _internal_ram_gb();
}
inline void AsymmetricHasherConfig::set_ram_gb(::int32_t value) {
  _internal_set_ram_gb(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.ram_gb)
}
inline ::int32_t AsymmetricHasherConfig::_internal_ram_gb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ram_gb_;
}
inline void AsymmetricHasherConfig::_internal_set_ram_gb(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.ram_gb_ = value;
}

// optional int32 num_cpus = 15 [default = 1];
inline bool AsymmetricHasherConfig::has_num_cpus() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_num_cpus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_cpus_ = 1;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::int32_t AsymmetricHasherConfig::num_cpus() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.num_cpus)
  return _internal_num_cpus();
}
inline void AsymmetricHasherConfig::set_num_cpus(::int32_t value) {
  _internal_set_num_cpus(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.num_cpus)
}
inline ::int32_t AsymmetricHasherConfig::_internal_num_cpus() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_cpus_;
}
inline void AsymmetricHasherConfig::_internal_set_num_cpus(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.num_cpus_ = value;
}

// optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
inline bool AsymmetricHasherConfig::has_quantization_scheme() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_quantization_scheme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantization_scheme_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::research_scann::AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::quantization_scheme() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.quantization_scheme)
  return _internal_quantization_scheme();
}
inline void AsymmetricHasherConfig::set_quantization_scheme(::research_scann::AsymmetricHasherConfig_QuantizationScheme value) {
  _internal_set_quantization_scheme(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.quantization_scheme)
}
inline ::research_scann::AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::_internal_quantization_scheme() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::AsymmetricHasherConfig_QuantizationScheme>(_impl_.quantization_scheme_);
}
inline void AsymmetricHasherConfig::_internal_set_quantization_scheme(::research_scann::AsymmetricHasherConfig_QuantizationScheme value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::AsymmetricHasherConfig_QuantizationScheme_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.quantization_scheme_ = value;
}

// optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
inline bool AsymmetricHasherConfig::has_stacked_quantizers_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stacked_quantizers_config_ != nullptr);
  return value;
}
inline void AsymmetricHasherConfig::clear_stacked_quantizers_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stacked_quantizers_config_ != nullptr) _impl_.stacked_quantizers_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::research_scann::StackedQuantizersConfig& AsymmetricHasherConfig::_internal_stacked_quantizers_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::StackedQuantizersConfig* p = _impl_.stacked_quantizers_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::StackedQuantizersConfig&>(::research_scann::_StackedQuantizersConfig_default_instance_);
}
inline const ::research_scann::StackedQuantizersConfig& AsymmetricHasherConfig::stacked_quantizers_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
  return _internal_stacked_quantizers_config();
}
inline void AsymmetricHasherConfig::unsafe_arena_set_allocated_stacked_quantizers_config(::research_scann::StackedQuantizersConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stacked_quantizers_config_);
  }
  _impl_.stacked_quantizers_config_ = reinterpret_cast<::research_scann::StackedQuantizersConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
}
inline ::research_scann::StackedQuantizersConfig* AsymmetricHasherConfig::release_stacked_quantizers_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::StackedQuantizersConfig* released = _impl_.stacked_quantizers_config_;
  _impl_.stacked_quantizers_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::StackedQuantizersConfig* AsymmetricHasherConfig::unsafe_arena_release_stacked_quantizers_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::StackedQuantizersConfig* temp = _impl_.stacked_quantizers_config_;
  _impl_.stacked_quantizers_config_ = nullptr;
  return temp;
}
inline ::research_scann::StackedQuantizersConfig* AsymmetricHasherConfig::_internal_mutable_stacked_quantizers_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.stacked_quantizers_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::StackedQuantizersConfig>(GetArena());
    _impl_.stacked_quantizers_config_ = reinterpret_cast<::research_scann::StackedQuantizersConfig*>(p);
  }
  return _impl_.stacked_quantizers_config_;
}
inline ::research_scann::StackedQuantizersConfig* AsymmetricHasherConfig::mutable_stacked_quantizers_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::StackedQuantizersConfig* _msg = _internal_mutable_stacked_quantizers_config();
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
  return _msg;
}
inline void AsymmetricHasherConfig::set_allocated_stacked_quantizers_config(::research_scann::StackedQuantizersConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::StackedQuantizersConfig*>(_impl_.stacked_quantizers_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::StackedQuantizersConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.stacked_quantizers_config_ = reinterpret_cast<::research_scann::StackedQuantizersConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
}

// optional int32 min_number_machines = 7 [deprecated = true];
inline bool AsymmetricHasherConfig::has_min_number_machines() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_min_number_machines() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_number_machines_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t AsymmetricHasherConfig::min_number_machines() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.min_number_machines)
  return _internal_min_number_machines();
}
inline void AsymmetricHasherConfig::set_min_number_machines(::int32_t value) {
  _internal_set_min_number_machines(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.min_number_machines)
}
inline ::int32_t AsymmetricHasherConfig::_internal_min_number_machines() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_number_machines_;
}
inline void AsymmetricHasherConfig::_internal_set_min_number_machines(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.min_number_machines_ = value;
}

// optional int32 max_sample_size = 3 [default = 2147483647];
inline bool AsymmetricHasherConfig::has_max_sample_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_max_sample_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_sample_size_ = 2147483647;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::int32_t AsymmetricHasherConfig::max_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.max_sample_size)
  return _internal_max_sample_size();
}
inline void AsymmetricHasherConfig::set_max_sample_size(::int32_t value) {
  _internal_set_max_sample_size(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.max_sample_size)
}
inline ::int32_t AsymmetricHasherConfig::_internal_max_sample_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_sample_size_;
}
inline void AsymmetricHasherConfig::_internal_set_max_sample_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.max_sample_size_ = value;
}

// optional bool use_noise_shaped_training = 30 [default = false, deprecated = true];
inline bool AsymmetricHasherConfig::has_use_noise_shaped_training() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_noise_shaped_training() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_noise_shaped_training_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool AsymmetricHasherConfig::use_noise_shaped_training() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_noise_shaped_training)
  return _internal_use_noise_shaped_training();
}
inline void AsymmetricHasherConfig::set_use_noise_shaped_training(bool value) {
  _internal_set_use_noise_shaped_training(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_noise_shaped_training)
}
inline bool AsymmetricHasherConfig::_internal_use_noise_shaped_training() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_noise_shaped_training_;
}
inline void AsymmetricHasherConfig::_internal_set_use_noise_shaped_training(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.use_noise_shaped_training_ = value;
}

// optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
inline bool AsymmetricHasherConfig::has_partition_level_confidence_interval_stdevs() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_partition_level_confidence_interval_stdevs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_level_confidence_interval_stdevs_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float AsymmetricHasherConfig::partition_level_confidence_interval_stdevs() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.partition_level_confidence_interval_stdevs)
  return _internal_partition_level_confidence_interval_stdevs();
}
inline void AsymmetricHasherConfig::set_partition_level_confidence_interval_stdevs(float value) {
  _internal_set_partition_level_confidence_interval_stdevs(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.partition_level_confidence_interval_stdevs)
}
inline float AsymmetricHasherConfig::_internal_partition_level_confidence_interval_stdevs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_level_confidence_interval_stdevs_;
}
inline void AsymmetricHasherConfig::_internal_set_partition_level_confidence_interval_stdevs(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.partition_level_confidence_interval_stdevs_ = value;
}

// optional float min_cluster_size = 19 [default = 1, deprecated = true];
inline bool AsymmetricHasherConfig::has_min_cluster_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_min_cluster_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_cluster_size_ = 1;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline float AsymmetricHasherConfig::min_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.min_cluster_size)
  return _internal_min_cluster_size();
}
inline void AsymmetricHasherConfig::set_min_cluster_size(float value) {
  _internal_set_min_cluster_size(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.min_cluster_size)
}
inline float AsymmetricHasherConfig::_internal_min_cluster_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_cluster_size_;
}
inline void AsymmetricHasherConfig::_internal_set_min_cluster_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.min_cluster_size_ = value;
}

// optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
inline bool AsymmetricHasherConfig::has_use_single_machine_trainer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void AsymmetricHasherConfig::clear_use_single_machine_trainer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_single_machine_trainer_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AsymmetricHasherConfig::use_single_machine_trainer() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_single_machine_trainer)
  return _internal_use_single_machine_trainer();
}
inline void AsymmetricHasherConfig::set_use_single_machine_trainer(bool value) {
  _internal_set_use_single_machine_trainer(value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_single_machine_trainer)
}
inline bool AsymmetricHasherConfig::_internal_use_single_machine_trainer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_single_machine_trainer_;
}
inline void AsymmetricHasherConfig::_internal_set_use_single_machine_trainer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.use_single_machine_trainer_ = value;
}

inline bool AsymmetricHasherConfig::has_SamplingFractionOrExpectedSize() const {
  return SamplingFractionOrExpectedSize_case() != SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline void AsymmetricHasherConfig::clear_has_SamplingFractionOrExpectedSize() {
  _impl_._oneof_case_[0] = SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline AsymmetricHasherConfig::SamplingFractionOrExpectedSizeCase AsymmetricHasherConfig::SamplingFractionOrExpectedSize_case() const {
  return AsymmetricHasherConfig::SamplingFractionOrExpectedSizeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MinHasherConfig

// optional int32 config_id = 1;
inline bool MinHasherConfig::has_config_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MinHasherConfig::clear_config_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.config_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MinHasherConfig::config_id() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.config_id)
  return _internal_config_id();
}
inline void MinHasherConfig::set_config_id(::int32_t value) {
  _internal_set_config_id(value);
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.config_id)
}
inline ::int32_t MinHasherConfig::_internal_config_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.config_id_;
}
inline void MinHasherConfig::_internal_set_config_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.config_id_ = value;
}

// optional int32 num_sketches = 2;
inline bool MinHasherConfig::has_num_sketches() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MinHasherConfig::clear_num_sketches() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_sketches_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MinHasherConfig::num_sketches() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.num_sketches)
  return _internal_num_sketches();
}
inline void MinHasherConfig::set_num_sketches(::int32_t value) {
  _internal_set_num_sketches(value);
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.num_sketches)
}
inline ::int32_t MinHasherConfig::_internal_num_sketches() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_sketches_;
}
inline void MinHasherConfig::_internal_set_num_sketches(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_sketches_ = value;
}

// optional int32 num_hashes = 3;
inline bool MinHasherConfig::has_num_hashes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MinHasherConfig::clear_num_hashes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_hashes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MinHasherConfig::num_hashes() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.num_hashes)
  return _internal_num_hashes();
}
inline void MinHasherConfig::set_num_hashes(::int32_t value) {
  _internal_set_num_hashes(value);
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.num_hashes)
}
inline ::int32_t MinHasherConfig::_internal_num_hashes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_hashes_;
}
inline void MinHasherConfig::_internal_set_num_hashes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_hashes_ = value;
}

// repeated int64 seeds = 4;
inline int MinHasherConfig::_internal_seeds_size() const {
  return _internal_seeds().size();
}
inline int MinHasherConfig::seeds_size() const {
  return _internal_seeds_size();
}
inline void MinHasherConfig::clear_seeds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seeds_.Clear();
}
inline ::int64_t MinHasherConfig::seeds(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.seeds)
  return _internal_seeds().Get(index);
}
inline void MinHasherConfig::set_seeds(int index, ::int64_t value) {
  _internal_mutable_seeds()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.seeds)
}
inline void MinHasherConfig::add_seeds(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_seeds()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.MinHasherConfig.seeds)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& MinHasherConfig::seeds() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.MinHasherConfig.seeds)
  return _internal_seeds();
}
inline ::google::protobuf::RepeatedField<::int64_t>* MinHasherConfig::mutable_seeds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.MinHasherConfig.seeds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_seeds();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& MinHasherConfig::_internal_seeds()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seeds_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* MinHasherConfig::_internal_mutable_seeds() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.seeds_;
}

// optional int32 num_bits_per_hash = 5;
inline bool MinHasherConfig::has_num_bits_per_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MinHasherConfig::clear_num_bits_per_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_bits_per_hash_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MinHasherConfig::num_bits_per_hash() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.num_bits_per_hash)
  return _internal_num_bits_per_hash();
}
inline void MinHasherConfig::set_num_bits_per_hash(::int32_t value) {
  _internal_set_num_bits_per_hash(value);
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.num_bits_per_hash)
}
inline ::int32_t MinHasherConfig::_internal_num_bits_per_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_bits_per_hash_;
}
inline void MinHasherConfig::_internal_set_num_bits_per_hash(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.num_bits_per_hash_ = value;
}

// -------------------------------------------------------------------

// BitSamplingHasherConfig

// optional int32 num_bits = 1 [default = 3];
inline bool BitSamplingHasherConfig::has_num_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BitSamplingHasherConfig::clear_num_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_bits_ = 3;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BitSamplingHasherConfig::num_bits() const {
  // @@protoc_insertion_point(field_get:research_scann.BitSamplingHasherConfig.num_bits)
  return _internal_num_bits();
}
inline void BitSamplingHasherConfig::set_num_bits(::int32_t value) {
  _internal_set_num_bits(value);
  // @@protoc_insertion_point(field_set:research_scann.BitSamplingHasherConfig.num_bits)
}
inline ::int32_t BitSamplingHasherConfig::_internal_num_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_bits_;
}
inline void BitSamplingHasherConfig::_internal_set_num_bits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_bits_ = value;
}

// optional bool use_entropy = 2 [default = false];
inline bool BitSamplingHasherConfig::has_use_entropy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BitSamplingHasherConfig::clear_use_entropy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_entropy_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BitSamplingHasherConfig::use_entropy() const {
  // @@protoc_insertion_point(field_get:research_scann.BitSamplingHasherConfig.use_entropy)
  return _internal_use_entropy();
}
inline void BitSamplingHasherConfig::set_use_entropy(bool value) {
  _internal_set_use_entropy(value);
  // @@protoc_insertion_point(field_set:research_scann.BitSamplingHasherConfig.use_entropy)
}
inline bool BitSamplingHasherConfig::_internal_use_entropy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_entropy_;
}
inline void BitSamplingHasherConfig::_internal_set_use_entropy(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.use_entropy_ = value;
}

// -------------------------------------------------------------------

// PcaHasherConfig

// optional bool rotate_projections = 1 [default = false];
inline bool PcaHasherConfig::has_rotate_projections() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_rotate_projections() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotate_projections_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PcaHasherConfig::rotate_projections() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.rotate_projections)
  return _internal_rotate_projections();
}
inline void PcaHasherConfig::set_rotate_projections(bool value) {
  _internal_set_rotate_projections(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.rotate_projections)
}
inline bool PcaHasherConfig::_internal_rotate_projections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotate_projections_;
}
inline void PcaHasherConfig::_internal_set_rotate_projections(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rotate_projections_ = value;
}

// optional float sampling_fraction = 2 [default = 1];
inline bool PcaHasherConfig::has_sampling_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_sampling_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampling_fraction_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float PcaHasherConfig::sampling_fraction() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.sampling_fraction)
  return _internal_sampling_fraction();
}
inline void PcaHasherConfig::set_sampling_fraction(float value) {
  _internal_set_sampling_fraction(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.sampling_fraction)
}
inline float PcaHasherConfig::_internal_sampling_fraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampling_fraction_;
}
inline void PcaHasherConfig::_internal_set_sampling_fraction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sampling_fraction_ = value;
}

// optional int32 sampling_seed = 3 [default = 1];
inline bool PcaHasherConfig::has_sampling_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_sampling_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampling_seed_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t PcaHasherConfig::sampling_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.sampling_seed)
  return _internal_sampling_seed();
}
inline void PcaHasherConfig::set_sampling_seed(::int32_t value) {
  _internal_set_sampling_seed(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.sampling_seed)
}
inline ::int32_t PcaHasherConfig::_internal_sampling_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampling_seed_;
}
inline void PcaHasherConfig::_internal_set_sampling_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sampling_seed_ = value;
}

// optional int32 max_sample_size = 4;
inline bool PcaHasherConfig::has_max_sample_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_max_sample_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_sample_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t PcaHasherConfig::max_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.max_sample_size)
  return _internal_max_sample_size();
}
inline void PcaHasherConfig::set_max_sample_size(::int32_t value) {
  _internal_set_max_sample_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.max_sample_size)
}
inline ::int32_t PcaHasherConfig::_internal_max_sample_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_sample_size_;
}
inline void PcaHasherConfig::_internal_set_max_sample_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_sample_size_ = value;
}

// optional bool learn_projections = 5 [default = false];
inline bool PcaHasherConfig::has_learn_projections() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_learn_projections() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.learn_projections_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PcaHasherConfig::learn_projections() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.learn_projections)
  return _internal_learn_projections();
}
inline void PcaHasherConfig::set_learn_projections(bool value) {
  _internal_set_learn_projections(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.learn_projections)
}
inline bool PcaHasherConfig::_internal_learn_projections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.learn_projections_;
}
inline void PcaHasherConfig::_internal_set_learn_projections(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.learn_projections_ = value;
}

// optional int32 max_num_iteration = 6 [default = 40];
inline bool PcaHasherConfig::has_max_num_iteration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_max_num_iteration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_num_iteration_ = 40;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t PcaHasherConfig::max_num_iteration() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.max_num_iteration)
  return _internal_max_num_iteration();
}
inline void PcaHasherConfig::set_max_num_iteration(::int32_t value) {
  _internal_set_max_num_iteration(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.max_num_iteration)
}
inline ::int32_t PcaHasherConfig::_internal_max_num_iteration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_num_iteration_;
}
inline void PcaHasherConfig::_internal_set_max_num_iteration(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.max_num_iteration_ = value;
}

// optional float iteration_tolerance = 7 [default = 1e-05];
inline bool PcaHasherConfig::has_iteration_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PcaHasherConfig::clear_iteration_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.iteration_tolerance_ = 1e-05f;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float PcaHasherConfig::iteration_tolerance() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.iteration_tolerance)
  return _internal_iteration_tolerance();
}
inline void PcaHasherConfig::set_iteration_tolerance(float value) {
  _internal_set_iteration_tolerance(value);
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.iteration_tolerance)
}
inline float PcaHasherConfig::_internal_iteration_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.iteration_tolerance_;
}
inline void PcaHasherConfig::_internal_set_iteration_tolerance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.iteration_tolerance_ = value;
}

// -------------------------------------------------------------------

// BncHasherConfig

// optional float compression_ratio = 1 [default = 0];
inline bool BncHasherConfig::has_compression_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BncHasherConfig::clear_compression_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compression_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float BncHasherConfig::compression_ratio() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.compression_ratio)
  return _internal_compression_ratio();
}
inline void BncHasherConfig::set_compression_ratio(float value) {
  _internal_set_compression_ratio(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.compression_ratio)
}
inline float BncHasherConfig::_internal_compression_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compression_ratio_;
}
inline void BncHasherConfig::_internal_set_compression_ratio(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.compression_ratio_ = value;
}

// optional float gamma = 2 [default = 10];
inline bool BncHasherConfig::has_gamma() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BncHasherConfig::clear_gamma() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gamma_ = 10;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float BncHasherConfig::gamma() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.gamma)
  return _internal_gamma();
}
inline void BncHasherConfig::set_gamma(float value) {
  _internal_set_gamma(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.gamma)
}
inline float BncHasherConfig::_internal_gamma() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gamma_;
}
inline void BncHasherConfig::_internal_set_gamma(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gamma_ = value;
}

// optional float learning_rate = 3 [default = 0.1];
inline bool BncHasherConfig::has_learning_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BncHasherConfig::clear_learning_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.learning_rate_ = 0.1f;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float BncHasherConfig::learning_rate() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.learning_rate)
  return _internal_learning_rate();
}
inline void BncHasherConfig::set_learning_rate(float value) {
  _internal_set_learning_rate(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.learning_rate)
}
inline float BncHasherConfig::_internal_learning_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.learning_rate_;
}
inline void BncHasherConfig::_internal_set_learning_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.learning_rate_ = value;
}

// optional int32 batch_size = 4 [default = 128];
inline bool BncHasherConfig::has_batch_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BncHasherConfig::clear_batch_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.batch_size_ = 128;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BncHasherConfig::batch_size() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.batch_size)
  return _internal_batch_size();
}
inline void BncHasherConfig::set_batch_size(::int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.batch_size)
}
inline ::int32_t BncHasherConfig::_internal_batch_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.batch_size_;
}
inline void BncHasherConfig::_internal_set_batch_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.batch_size_ = value;
}

// optional int32 num_phase1_iterations = 5 [default = 50];
inline bool BncHasherConfig::has_num_phase1_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BncHasherConfig::clear_num_phase1_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_phase1_iterations_ = 50;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BncHasherConfig::num_phase1_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.num_phase1_iterations)
  return _internal_num_phase1_iterations();
}
inline void BncHasherConfig::set_num_phase1_iterations(::int32_t value) {
  _internal_set_num_phase1_iterations(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.num_phase1_iterations)
}
inline ::int32_t BncHasherConfig::_internal_num_phase1_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_phase1_iterations_;
}
inline void BncHasherConfig::_internal_set_num_phase1_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.num_phase1_iterations_ = value;
}

// optional int32 num_phase2_iterations = 6 [default = 100];
inline bool BncHasherConfig::has_num_phase2_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BncHasherConfig::clear_num_phase2_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_phase2_iterations_ = 100;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t BncHasherConfig::num_phase2_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.num_phase2_iterations)
  return _internal_num_phase2_iterations();
}
inline void BncHasherConfig::set_num_phase2_iterations(::int32_t value) {
  _internal_set_num_phase2_iterations(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.num_phase2_iterations)
}
inline ::int32_t BncHasherConfig::_internal_num_phase2_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_phase2_iterations_;
}
inline void BncHasherConfig::_internal_set_num_phase2_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.num_phase2_iterations_ = value;
}

// optional int32 sampling_seed = 7 [default = 1];
inline bool BncHasherConfig::has_sampling_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BncHasherConfig::clear_sampling_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampling_seed_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t BncHasherConfig::sampling_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.sampling_seed)
  return _internal_sampling_seed();
}
inline void BncHasherConfig::set_sampling_seed(::int32_t value) {
  _internal_set_sampling_seed(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.sampling_seed)
}
inline ::int32_t BncHasherConfig::_internal_sampling_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampling_seed_;
}
inline void BncHasherConfig::_internal_set_sampling_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sampling_seed_ = value;
}

// optional int32 num_cpus = 8 [default = 1];
inline bool BncHasherConfig::has_num_cpus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BncHasherConfig::clear_num_cpus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_cpus_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BncHasherConfig::num_cpus() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.num_cpus)
  return _internal_num_cpus();
}
inline void BncHasherConfig::set_num_cpus(::int32_t value) {
  _internal_set_num_cpus(value);
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.num_cpus)
}
inline ::int32_t BncHasherConfig::_internal_num_cpus() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_cpus_;
}
inline void BncHasherConfig::_internal_set_num_cpus(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_cpus_ = value;
}

// -------------------------------------------------------------------

// StackedQuantizersConfig

// optional int32 min_num_iterations = 1 [default = 3];
inline bool StackedQuantizersConfig::has_min_num_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StackedQuantizersConfig::clear_min_num_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_num_iterations_ = 3;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t StackedQuantizersConfig::min_num_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.StackedQuantizersConfig.min_num_iterations)
  return _internal_min_num_iterations();
}
inline void StackedQuantizersConfig::set_min_num_iterations(::int32_t value) {
  _internal_set_min_num_iterations(value);
  // @@protoc_insertion_point(field_set:research_scann.StackedQuantizersConfig.min_num_iterations)
}
inline ::int32_t StackedQuantizersConfig::_internal_min_num_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_num_iterations_;
}
inline void StackedQuantizersConfig::_internal_set_min_num_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_num_iterations_ = value;
}

// optional int32 max_num_iterations = 2 [default = 10];
inline bool StackedQuantizersConfig::has_max_num_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StackedQuantizersConfig::clear_max_num_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_num_iterations_ = 10;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t StackedQuantizersConfig::max_num_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.StackedQuantizersConfig.max_num_iterations)
  return _internal_max_num_iterations();
}
inline void StackedQuantizersConfig::set_max_num_iterations(::int32_t value) {
  _internal_set_max_num_iterations(value);
  // @@protoc_insertion_point(field_set:research_scann.StackedQuantizersConfig.max_num_iterations)
}
inline ::int32_t StackedQuantizersConfig::_internal_max_num_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_num_iterations_;
}
inline void StackedQuantizersConfig::_internal_set_max_num_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_num_iterations_ = value;
}

// optional float relative_improvement_threshold = 3 [default = 0.001];
inline bool StackedQuantizersConfig::has_relative_improvement_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StackedQuantizersConfig::clear_relative_improvement_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_improvement_threshold_ = 0.001f;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float StackedQuantizersConfig::relative_improvement_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.StackedQuantizersConfig.relative_improvement_threshold)
  return _internal_relative_improvement_threshold();
}
inline void StackedQuantizersConfig::set_relative_improvement_threshold(float value) {
  _internal_set_relative_improvement_threshold(value);
  // @@protoc_insertion_point(field_set:research_scann.StackedQuantizersConfig.relative_improvement_threshold)
}
inline float StackedQuantizersConfig::_internal_relative_improvement_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_improvement_threshold_;
}
inline void StackedQuantizersConfig::_internal_set_relative_improvement_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.relative_improvement_threshold_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace research_scann


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::research_scann::HashConfig_ThresholdType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::HashConfig_ThresholdType>() {
  return ::research_scann::HashConfig_ThresholdType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>() {
  return ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor();
}
template <>
struct is_proto_enum<::research_scann::AsymmetricHasherConfig_LookupType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::AsymmetricHasherConfig_LookupType>() {
  return ::research_scann::AsymmetricHasherConfig_LookupType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::AsymmetricHasherConfig_QuantizationScheme> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::AsymmetricHasherConfig_QuantizationScheme>() {
  return ::research_scann::AsymmetricHasherConfig_QuantizationScheme_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fhash_2eproto_2epb_2eh
