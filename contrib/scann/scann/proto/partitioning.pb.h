// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/partitioning.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fpartitioning_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fpartitioning_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "scann/proto/distance_measure.pb.h"
#include "scann/proto/exact_reordering.pb.h"
#include "scann/proto/input_output.pb.h"
#include "scann/proto/projection.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fpartitioning_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2fpartitioning_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_scann_2fproto_2fpartitioning_2eproto;
namespace research_scann {
class DatabaseSpillingConfig;
struct DatabaseSpillingConfigDefaultTypeInternal;
extern DatabaseSpillingConfigDefaultTypeInternal _DatabaseSpillingConfig_default_instance_;
class HierarchicalPartitionerConfig;
struct HierarchicalPartitionerConfigDefaultTypeInternal;
extern HierarchicalPartitionerConfigDefaultTypeInternal _HierarchicalPartitionerConfig_default_instance_;
class PartitioningConfig;
struct PartitioningConfigDefaultTypeInternal;
extern PartitioningConfigDefaultTypeInternal _PartitioningConfig_default_instance_;
class QuerySpillingConfig;
struct QuerySpillingConfigDefaultTypeInternal;
extern QuerySpillingConfigDefaultTypeInternal _QuerySpillingConfig_default_instance_;
class TokenList;
struct TokenListDefaultTypeInternal;
extern TokenListDefaultTypeInternal _TokenList_default_instance_;
class TreeXHybridPartitioningConfig;
struct TreeXHybridPartitioningConfigDefaultTypeInternal;
extern TreeXHybridPartitioningConfigDefaultTypeInternal _TreeXHybridPartitioningConfig_default_instance_;
}  // namespace research_scann
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace research_scann {
enum PartitioningConfig_TreeType : int {
  PartitioningConfig_TreeType_KMEANS_TREE = 0,
  PartitioningConfig_TreeType_PCA_TREE = 1,
  PartitioningConfig_TreeType_RANDOM_PROJECTION_TREE = 2,
  PartitioningConfig_TreeType_BALL_TREE = 3,
  PartitioningConfig_TreeType_RANDOM = 4,
  PartitioningConfig_TreeType_TREE_X_HYBRID = 5,
};

bool PartitioningConfig_TreeType_IsValid(int value);
extern const uint32_t PartitioningConfig_TreeType_internal_data_[];
constexpr PartitioningConfig_TreeType PartitioningConfig_TreeType_TreeType_MIN = static_cast<PartitioningConfig_TreeType>(0);
constexpr PartitioningConfig_TreeType PartitioningConfig_TreeType_TreeType_MAX = static_cast<PartitioningConfig_TreeType>(5);
constexpr int PartitioningConfig_TreeType_TreeType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
PartitioningConfig_TreeType_descriptor();
template <typename T>
const std::string& PartitioningConfig_TreeType_Name(T value) {
  static_assert(std::is_same<T, PartitioningConfig_TreeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TreeType_Name().");
  return PartitioningConfig_TreeType_Name(static_cast<PartitioningConfig_TreeType>(value));
}
template <>
inline const std::string& PartitioningConfig_TreeType_Name(PartitioningConfig_TreeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PartitioningConfig_TreeType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool PartitioningConfig_TreeType_Parse(absl::string_view name, PartitioningConfig_TreeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitioningConfig_TreeType>(
      PartitioningConfig_TreeType_descriptor(), name, value);
}
enum PartitioningConfig_TokenizationType : int {
  PartitioningConfig_TokenizationType_FLOAT = 1,
  PartitioningConfig_TokenizationType_FIXED_POINT_INT8 = 2,
  PartitioningConfig_TokenizationType_ASYMMETRIC = 3,
};

bool PartitioningConfig_TokenizationType_IsValid(int value);
extern const uint32_t PartitioningConfig_TokenizationType_internal_data_[];
constexpr PartitioningConfig_TokenizationType PartitioningConfig_TokenizationType_TokenizationType_MIN = static_cast<PartitioningConfig_TokenizationType>(1);
constexpr PartitioningConfig_TokenizationType PartitioningConfig_TokenizationType_TokenizationType_MAX = static_cast<PartitioningConfig_TokenizationType>(3);
constexpr int PartitioningConfig_TokenizationType_TokenizationType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PartitioningConfig_TokenizationType_descriptor();
template <typename T>
const std::string& PartitioningConfig_TokenizationType_Name(T value) {
  static_assert(std::is_same<T, PartitioningConfig_TokenizationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TokenizationType_Name().");
  return PartitioningConfig_TokenizationType_Name(static_cast<PartitioningConfig_TokenizationType>(value));
}
template <>
inline const std::string& PartitioningConfig_TokenizationType_Name(PartitioningConfig_TokenizationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PartitioningConfig_TokenizationType_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool PartitioningConfig_TokenizationType_Parse(absl::string_view name, PartitioningConfig_TokenizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitioningConfig_TokenizationType>(
      PartitioningConfig_TokenizationType_descriptor(), name, value);
}
enum PartitioningConfig_PartitioningType : int {
  PartitioningConfig_PartitioningType_GENERIC = 0,
  PartitioningConfig_PartitioningType_SPHERICAL = 1,
};

bool PartitioningConfig_PartitioningType_IsValid(int value);
extern const uint32_t PartitioningConfig_PartitioningType_internal_data_[];
constexpr PartitioningConfig_PartitioningType PartitioningConfig_PartitioningType_PartitioningType_MIN = static_cast<PartitioningConfig_PartitioningType>(0);
constexpr PartitioningConfig_PartitioningType PartitioningConfig_PartitioningType_PartitioningType_MAX = static_cast<PartitioningConfig_PartitioningType>(1);
constexpr int PartitioningConfig_PartitioningType_PartitioningType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PartitioningConfig_PartitioningType_descriptor();
template <typename T>
const std::string& PartitioningConfig_PartitioningType_Name(T value) {
  static_assert(std::is_same<T, PartitioningConfig_PartitioningType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PartitioningType_Name().");
  return PartitioningConfig_PartitioningType_Name(static_cast<PartitioningConfig_PartitioningType>(value));
}
template <>
inline const std::string& PartitioningConfig_PartitioningType_Name(PartitioningConfig_PartitioningType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PartitioningConfig_PartitioningType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PartitioningConfig_PartitioningType_Parse(absl::string_view name, PartitioningConfig_PartitioningType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitioningConfig_PartitioningType>(
      PartitioningConfig_PartitioningType_descriptor(), name, value);
}
enum PartitioningConfig_BalancingType : int {
  PartitioningConfig_BalancingType_DEFAULT_UNBALANCED = 0,
  PartitioningConfig_BalancingType_GREEDY_BALANCED = 1,
};

bool PartitioningConfig_BalancingType_IsValid(int value);
extern const uint32_t PartitioningConfig_BalancingType_internal_data_[];
constexpr PartitioningConfig_BalancingType PartitioningConfig_BalancingType_BalancingType_MIN = static_cast<PartitioningConfig_BalancingType>(0);
constexpr PartitioningConfig_BalancingType PartitioningConfig_BalancingType_BalancingType_MAX = static_cast<PartitioningConfig_BalancingType>(1);
constexpr int PartitioningConfig_BalancingType_BalancingType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PartitioningConfig_BalancingType_descriptor();
template <typename T>
const std::string& PartitioningConfig_BalancingType_Name(T value) {
  static_assert(std::is_same<T, PartitioningConfig_BalancingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BalancingType_Name().");
  return PartitioningConfig_BalancingType_Name(static_cast<PartitioningConfig_BalancingType>(value));
}
template <>
inline const std::string& PartitioningConfig_BalancingType_Name(PartitioningConfig_BalancingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PartitioningConfig_BalancingType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PartitioningConfig_BalancingType_Parse(absl::string_view name, PartitioningConfig_BalancingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitioningConfig_BalancingType>(
      PartitioningConfig_BalancingType_descriptor(), name, value);
}
enum PartitioningConfig_SingleMachineCenterInitializationType : int {
  PartitioningConfig_SingleMachineCenterInitializationType_DEFAULT_KMEANS_PLUS_PLUS = 0,
  PartitioningConfig_SingleMachineCenterInitializationType_RANDOM_INITIALIZATION = 1,
};

bool PartitioningConfig_SingleMachineCenterInitializationType_IsValid(int value);
extern const uint32_t PartitioningConfig_SingleMachineCenterInitializationType_internal_data_[];
constexpr PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MIN = static_cast<PartitioningConfig_SingleMachineCenterInitializationType>(0);
constexpr PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MAX = static_cast<PartitioningConfig_SingleMachineCenterInitializationType>(1);
constexpr int PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PartitioningConfig_SingleMachineCenterInitializationType_descriptor();
template <typename T>
const std::string& PartitioningConfig_SingleMachineCenterInitializationType_Name(T value) {
  static_assert(std::is_same<T, PartitioningConfig_SingleMachineCenterInitializationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SingleMachineCenterInitializationType_Name().");
  return PartitioningConfig_SingleMachineCenterInitializationType_Name(static_cast<PartitioningConfig_SingleMachineCenterInitializationType>(value));
}
template <>
inline const std::string& PartitioningConfig_SingleMachineCenterInitializationType_Name(PartitioningConfig_SingleMachineCenterInitializationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PartitioningConfig_SingleMachineCenterInitializationType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PartitioningConfig_SingleMachineCenterInitializationType_Parse(absl::string_view name, PartitioningConfig_SingleMachineCenterInitializationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitioningConfig_SingleMachineCenterInitializationType>(
      PartitioningConfig_SingleMachineCenterInitializationType_descriptor(), name, value);
}
enum PartitioningConfig_PartitionerTrainerType : int {
  PartitioningConfig_PartitionerTrainerType_DEFAULT_SAMPLING_TRAINER = 0,
  PartitioningConfig_PartitionerTrainerType_FLUME_KMEANS_TRAINER = 1,
  PartitioningConfig_PartitionerTrainerType_PCA_KMEANS_TRAINER = 3,
  PartitioningConfig_PartitionerTrainerType_SAMPLING_PCA_KMEANS_TRAINER = 4,
};

bool PartitioningConfig_PartitionerTrainerType_IsValid(int value);
extern const uint32_t PartitioningConfig_PartitionerTrainerType_internal_data_[];
constexpr PartitioningConfig_PartitionerTrainerType PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MIN = static_cast<PartitioningConfig_PartitionerTrainerType>(0);
constexpr PartitioningConfig_PartitionerTrainerType PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MAX = static_cast<PartitioningConfig_PartitionerTrainerType>(4);
constexpr int PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
PartitioningConfig_PartitionerTrainerType_descriptor();
template <typename T>
const std::string& PartitioningConfig_PartitionerTrainerType_Name(T value) {
  static_assert(std::is_same<T, PartitioningConfig_PartitionerTrainerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PartitionerTrainerType_Name().");
  return PartitioningConfig_PartitionerTrainerType_Name(static_cast<PartitioningConfig_PartitionerTrainerType>(value));
}
template <>
inline const std::string& PartitioningConfig_PartitionerTrainerType_Name(PartitioningConfig_PartitionerTrainerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PartitioningConfig_PartitionerTrainerType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool PartitioningConfig_PartitionerTrainerType_Parse(absl::string_view name, PartitioningConfig_PartitionerTrainerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitioningConfig_PartitionerTrainerType>(
      PartitioningConfig_PartitionerTrainerType_descriptor(), name, value);
}
enum DatabaseSpillingConfig_SpillingType : int {
  DatabaseSpillingConfig_SpillingType_NO_SPILLING = 0,
  DatabaseSpillingConfig_SpillingType_MULTIPLICATIVE = 1,
  DatabaseSpillingConfig_SpillingType_ADDITIVE = 2,
  DatabaseSpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS = 3,
};

bool DatabaseSpillingConfig_SpillingType_IsValid(int value);
extern const uint32_t DatabaseSpillingConfig_SpillingType_internal_data_[];
constexpr DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig_SpillingType_SpillingType_MIN = static_cast<DatabaseSpillingConfig_SpillingType>(0);
constexpr DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig_SpillingType_SpillingType_MAX = static_cast<DatabaseSpillingConfig_SpillingType>(3);
constexpr int DatabaseSpillingConfig_SpillingType_SpillingType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseSpillingConfig_SpillingType_descriptor();
template <typename T>
const std::string& DatabaseSpillingConfig_SpillingType_Name(T value) {
  static_assert(std::is_same<T, DatabaseSpillingConfig_SpillingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SpillingType_Name().");
  return DatabaseSpillingConfig_SpillingType_Name(static_cast<DatabaseSpillingConfig_SpillingType>(value));
}
template <>
inline const std::string& DatabaseSpillingConfig_SpillingType_Name(DatabaseSpillingConfig_SpillingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseSpillingConfig_SpillingType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DatabaseSpillingConfig_SpillingType_Parse(absl::string_view name, DatabaseSpillingConfig_SpillingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseSpillingConfig_SpillingType>(
      DatabaseSpillingConfig_SpillingType_descriptor(), name, value);
}
enum QuerySpillingConfig_SpillingType : int {
  QuerySpillingConfig_SpillingType_NO_SPILLING = 0,
  QuerySpillingConfig_SpillingType_MULTIPLICATIVE = 1,
  QuerySpillingConfig_SpillingType_ADDITIVE = 2,
  QuerySpillingConfig_SpillingType_ABSOLUTE_DISTANCE = 3,
  QuerySpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS = 4,
};

bool QuerySpillingConfig_SpillingType_IsValid(int value);
extern const uint32_t QuerySpillingConfig_SpillingType_internal_data_[];
constexpr QuerySpillingConfig_SpillingType QuerySpillingConfig_SpillingType_SpillingType_MIN = static_cast<QuerySpillingConfig_SpillingType>(0);
constexpr QuerySpillingConfig_SpillingType QuerySpillingConfig_SpillingType_SpillingType_MAX = static_cast<QuerySpillingConfig_SpillingType>(4);
constexpr int QuerySpillingConfig_SpillingType_SpillingType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
QuerySpillingConfig_SpillingType_descriptor();
template <typename T>
const std::string& QuerySpillingConfig_SpillingType_Name(T value) {
  static_assert(std::is_same<T, QuerySpillingConfig_SpillingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SpillingType_Name().");
  return QuerySpillingConfig_SpillingType_Name(static_cast<QuerySpillingConfig_SpillingType>(value));
}
template <>
inline const std::string& QuerySpillingConfig_SpillingType_Name(QuerySpillingConfig_SpillingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<QuerySpillingConfig_SpillingType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool QuerySpillingConfig_SpillingType_Parse(absl::string_view name, QuerySpillingConfig_SpillingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuerySpillingConfig_SpillingType>(
      QuerySpillingConfig_SpillingType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TokenList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.TokenList) */ {
 public:
  inline TokenList() : TokenList(nullptr) {}
  ~TokenList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenList(::google::protobuf::internal::ConstantInitialized);

  inline TokenList(const TokenList& from)
      : TokenList(nullptr, from) {}
  TokenList(TokenList&& from) noexcept
    : TokenList() {
    *this = ::std::move(from);
  }

  inline TokenList& operator=(const TokenList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenList& operator=(TokenList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenList* internal_default_instance() {
    return reinterpret_cast<const TokenList*>(
               &_TokenList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TokenList& a, TokenList& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TokenList& from) {
    TokenList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.TokenList";
  }
  protected:
  explicit TokenList(::google::protobuf::Arena* arena);
  TokenList(::google::protobuf::Arena* arena, const TokenList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatapointIndexFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated int64 datapoint_index = 2;
  int datapoint_index_size() const;
  private:
  int _internal_datapoint_index_size() const;

  public:
  void clear_datapoint_index() ;
  ::int64_t datapoint_index(int index) const;
  void set_datapoint_index(int index, ::int64_t value);
  void add_datapoint_index(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& datapoint_index() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_datapoint_index();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_datapoint_index() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_datapoint_index();

  public:
  // optional uint64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.TokenList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> datapoint_index_;
    ::uint64_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};// -------------------------------------------------------------------

class QuerySpillingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.QuerySpillingConfig) */ {
 public:
  inline QuerySpillingConfig() : QuerySpillingConfig(nullptr) {}
  ~QuerySpillingConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpillingConfig(::google::protobuf::internal::ConstantInitialized);

  inline QuerySpillingConfig(const QuerySpillingConfig& from)
      : QuerySpillingConfig(nullptr, from) {}
  QuerySpillingConfig(QuerySpillingConfig&& from) noexcept
    : QuerySpillingConfig() {
    *this = ::std::move(from);
  }

  inline QuerySpillingConfig& operator=(const QuerySpillingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpillingConfig& operator=(QuerySpillingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpillingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpillingConfig* internal_default_instance() {
    return reinterpret_cast<const QuerySpillingConfig*>(
               &_QuerySpillingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QuerySpillingConfig& a, QuerySpillingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpillingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpillingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpillingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpillingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuerySpillingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QuerySpillingConfig& from) {
    QuerySpillingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QuerySpillingConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.QuerySpillingConfig";
  }
  protected:
  explicit QuerySpillingConfig(::google::protobuf::Arena* arena);
  QuerySpillingConfig(::google::protobuf::Arena* arena, const QuerySpillingConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SpillingType = QuerySpillingConfig_SpillingType;
  static constexpr SpillingType NO_SPILLING = QuerySpillingConfig_SpillingType_NO_SPILLING;
  static constexpr SpillingType MULTIPLICATIVE = QuerySpillingConfig_SpillingType_MULTIPLICATIVE;
  static constexpr SpillingType ADDITIVE = QuerySpillingConfig_SpillingType_ADDITIVE;
  static constexpr SpillingType ABSOLUTE_DISTANCE = QuerySpillingConfig_SpillingType_ABSOLUTE_DISTANCE;
  static constexpr SpillingType FIXED_NUMBER_OF_CENTERS = QuerySpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS;
  static inline bool SpillingType_IsValid(int value) {
    return QuerySpillingConfig_SpillingType_IsValid(value);
  }
  static constexpr SpillingType SpillingType_MIN = QuerySpillingConfig_SpillingType_SpillingType_MIN;
  static constexpr SpillingType SpillingType_MAX = QuerySpillingConfig_SpillingType_SpillingType_MAX;
  static constexpr int SpillingType_ARRAYSIZE = QuerySpillingConfig_SpillingType_SpillingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SpillingType_descriptor() {
    return QuerySpillingConfig_SpillingType_descriptor();
  }
  template <typename T>
  static inline const std::string& SpillingType_Name(T value) {
    return QuerySpillingConfig_SpillingType_Name(value);
  }
  static inline bool SpillingType_Parse(absl::string_view name, SpillingType* value) {
    return QuerySpillingConfig_SpillingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpillingTypeFieldNumber = 1,
    kSpillingThresholdFieldNumber = 2,
    kMaxSpillCentersFieldNumber = 3,
  };
  // optional .research_scann.QuerySpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
  bool has_spilling_type() const;
  void clear_spilling_type() ;
  ::research_scann::QuerySpillingConfig_SpillingType spilling_type() const;
  void set_spilling_type(::research_scann::QuerySpillingConfig_SpillingType value);

  private:
  ::research_scann::QuerySpillingConfig_SpillingType _internal_spilling_type() const;
  void _internal_set_spilling_type(::research_scann::QuerySpillingConfig_SpillingType value);

  public:
  // optional float spilling_threshold = 2;
  bool has_spilling_threshold() const;
  void clear_spilling_threshold() ;
  float spilling_threshold() const;
  void set_spilling_threshold(float value);

  private:
  float _internal_spilling_threshold() const;
  void _internal_set_spilling_threshold(float value);

  public:
  // optional uint32 max_spill_centers = 3 [default = 4294967295];
  bool has_max_spill_centers() const;
  void clear_max_spill_centers() ;
  ::uint32_t max_spill_centers() const;
  void set_max_spill_centers(::uint32_t value);

  private:
  ::uint32_t _internal_max_spill_centers() const;
  void _internal_set_max_spill_centers(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.QuerySpillingConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int spilling_type_;
    float spilling_threshold_;
    ::uint32_t max_spill_centers_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};// -------------------------------------------------------------------

class DatabaseSpillingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.DatabaseSpillingConfig) */ {
 public:
  inline DatabaseSpillingConfig() : DatabaseSpillingConfig(nullptr) {}
  ~DatabaseSpillingConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseSpillingConfig(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseSpillingConfig(const DatabaseSpillingConfig& from)
      : DatabaseSpillingConfig(nullptr, from) {}
  DatabaseSpillingConfig(DatabaseSpillingConfig&& from) noexcept
    : DatabaseSpillingConfig() {
    *this = ::std::move(from);
  }

  inline DatabaseSpillingConfig& operator=(const DatabaseSpillingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseSpillingConfig& operator=(DatabaseSpillingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseSpillingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseSpillingConfig* internal_default_instance() {
    return reinterpret_cast<const DatabaseSpillingConfig*>(
               &_DatabaseSpillingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatabaseSpillingConfig& a, DatabaseSpillingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseSpillingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseSpillingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseSpillingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseSpillingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatabaseSpillingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DatabaseSpillingConfig& from) {
    DatabaseSpillingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DatabaseSpillingConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.DatabaseSpillingConfig";
  }
  protected:
  explicit DatabaseSpillingConfig(::google::protobuf::Arena* arena);
  DatabaseSpillingConfig(::google::protobuf::Arena* arena, const DatabaseSpillingConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SpillingType = DatabaseSpillingConfig_SpillingType;
  static constexpr SpillingType NO_SPILLING = DatabaseSpillingConfig_SpillingType_NO_SPILLING;
  static constexpr SpillingType MULTIPLICATIVE = DatabaseSpillingConfig_SpillingType_MULTIPLICATIVE;
  static constexpr SpillingType ADDITIVE = DatabaseSpillingConfig_SpillingType_ADDITIVE;
  static constexpr SpillingType FIXED_NUMBER_OF_CENTERS = DatabaseSpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS;
  static inline bool SpillingType_IsValid(int value) {
    return DatabaseSpillingConfig_SpillingType_IsValid(value);
  }
  static constexpr SpillingType SpillingType_MIN = DatabaseSpillingConfig_SpillingType_SpillingType_MIN;
  static constexpr SpillingType SpillingType_MAX = DatabaseSpillingConfig_SpillingType_SpillingType_MAX;
  static constexpr int SpillingType_ARRAYSIZE = DatabaseSpillingConfig_SpillingType_SpillingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SpillingType_descriptor() {
    return DatabaseSpillingConfig_SpillingType_descriptor();
  }
  template <typename T>
  static inline const std::string& SpillingType_Name(T value) {
    return DatabaseSpillingConfig_SpillingType_Name(value);
  }
  static inline bool SpillingType_Parse(absl::string_view name, SpillingType* value) {
    return DatabaseSpillingConfig_SpillingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpillingTypeFieldNumber = 1,
    kReplicationFactorFieldNumber = 2,
    kMaxSpillCentersFieldNumber = 3,
  };
  // optional .research_scann.DatabaseSpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
  bool has_spilling_type() const;
  void clear_spilling_type() ;
  ::research_scann::DatabaseSpillingConfig_SpillingType spilling_type() const;
  void set_spilling_type(::research_scann::DatabaseSpillingConfig_SpillingType value);

  private:
  ::research_scann::DatabaseSpillingConfig_SpillingType _internal_spilling_type() const;
  void _internal_set_spilling_type(::research_scann::DatabaseSpillingConfig_SpillingType value);

  public:
  // optional float replication_factor = 2;
  bool has_replication_factor() const;
  void clear_replication_factor() ;
  float replication_factor() const;
  void set_replication_factor(float value);

  private:
  float _internal_replication_factor() const;
  void _internal_set_replication_factor(float value);

  public:
  // optional uint32 max_spill_centers = 3 [default = 4294967295];
  bool has_max_spill_centers() const;
  void clear_max_spill_centers() ;
  ::uint32_t max_spill_centers() const;
  void set_max_spill_centers(::uint32_t value);

  private:
  ::uint32_t _internal_max_spill_centers() const;
  void _internal_set_max_spill_centers(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.DatabaseSpillingConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int spilling_type_;
    float replication_factor_;
    ::uint32_t max_spill_centers_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};// -------------------------------------------------------------------

class TreeXHybridPartitioningConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.TreeXHybridPartitioningConfig) */ {
 public:
  inline TreeXHybridPartitioningConfig() : TreeXHybridPartitioningConfig(nullptr) {}
  ~TreeXHybridPartitioningConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TreeXHybridPartitioningConfig(::google::protobuf::internal::ConstantInitialized);

  inline TreeXHybridPartitioningConfig(const TreeXHybridPartitioningConfig& from)
      : TreeXHybridPartitioningConfig(nullptr, from) {}
  TreeXHybridPartitioningConfig(TreeXHybridPartitioningConfig&& from) noexcept
    : TreeXHybridPartitioningConfig() {
    *this = ::std::move(from);
  }

  inline TreeXHybridPartitioningConfig& operator=(const TreeXHybridPartitioningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeXHybridPartitioningConfig& operator=(TreeXHybridPartitioningConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreeXHybridPartitioningConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreeXHybridPartitioningConfig* internal_default_instance() {
    return reinterpret_cast<const TreeXHybridPartitioningConfig*>(
               &_TreeXHybridPartitioningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TreeXHybridPartitioningConfig& a, TreeXHybridPartitioningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeXHybridPartitioningConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeXHybridPartitioningConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreeXHybridPartitioningConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreeXHybridPartitioningConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TreeXHybridPartitioningConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TreeXHybridPartitioningConfig& from) {
    TreeXHybridPartitioningConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TreeXHybridPartitioningConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.TreeXHybridPartitioningConfig";
  }
  protected:
  explicit TreeXHybridPartitioningConfig(::google::protobuf::Arena* arena);
  TreeXHybridPartitioningConfig(::google::protobuf::Arena* arena, const TreeXHybridPartitioningConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetsDirFieldNumber = 3,
    kTrainingReorderingFieldNumber = 4,
    kDatabaseTokenizationReorderingFieldNumber = 5,
    kQueryTokenizationReorderingFieldNumber = 6,
    kTopPartitioningChildrenFieldNumber = 1,
    kTopPartitionerUseFlumeTrainerFieldNumber = 9,
    kTopPartitionerSpillingRatioFieldNumber = 2,
    kTopPartitionerQueryTokenizationTypeFieldNumber = 7,
    kTopPartitionerDatabaseTokenizationTypeFieldNumber = 8,
    kTopPartitionerTrainingTokenizationTypeFieldNumber = 10,
  };
  // optional string assets_dir = 3;
  bool has_assets_dir() const;
  void clear_assets_dir() ;
  const std::string& assets_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assets_dir(Arg_&& arg, Args_... args);
  std::string* mutable_assets_dir();
  PROTOBUF_NODISCARD std::string* release_assets_dir();
  void set_allocated_assets_dir(std::string* value);

  private:
  const std::string& _internal_assets_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assets_dir(
      const std::string& value);
  std::string* _internal_mutable_assets_dir();

  public:
  // optional .research_scann.ExactReordering training_reordering = 4 [deprecated = true];
  [[deprecated]]  bool has_training_reordering() const;
  [[deprecated]]  void clear_training_reordering() ;
  [[deprecated]] const ::research_scann::ExactReordering& training_reordering() const;
  [[deprecated]] PROTOBUF_NODISCARD ::research_scann::ExactReordering* release_training_reordering();
  [[deprecated]] ::research_scann::ExactReordering* mutable_training_reordering();
  [[deprecated]] void set_allocated_training_reordering(::research_scann::ExactReordering* value);
  [[deprecated]] void unsafe_arena_set_allocated_training_reordering(::research_scann::ExactReordering* value);
  [[deprecated]] ::research_scann::ExactReordering* unsafe_arena_release_training_reordering();

  private:
  const ::research_scann::ExactReordering& _internal_training_reordering() const;
  ::research_scann::ExactReordering* _internal_mutable_training_reordering();

  public:
  // optional .research_scann.ExactReordering database_tokenization_reordering = 5 [deprecated = true];
  [[deprecated]]  bool has_database_tokenization_reordering() const;
  [[deprecated]]  void clear_database_tokenization_reordering() ;
  [[deprecated]] const ::research_scann::ExactReordering& database_tokenization_reordering() const;
  [[deprecated]] PROTOBUF_NODISCARD ::research_scann::ExactReordering* release_database_tokenization_reordering();
  [[deprecated]] ::research_scann::ExactReordering* mutable_database_tokenization_reordering();
  [[deprecated]] void set_allocated_database_tokenization_reordering(::research_scann::ExactReordering* value);
  [[deprecated]] void unsafe_arena_set_allocated_database_tokenization_reordering(::research_scann::ExactReordering* value);
  [[deprecated]] ::research_scann::ExactReordering* unsafe_arena_release_database_tokenization_reordering();

  private:
  const ::research_scann::ExactReordering& _internal_database_tokenization_reordering() const;
  ::research_scann::ExactReordering* _internal_mutable_database_tokenization_reordering();

  public:
  // optional .research_scann.ExactReordering query_tokenization_reordering = 6;
  bool has_query_tokenization_reordering() const;
  void clear_query_tokenization_reordering() ;
  const ::research_scann::ExactReordering& query_tokenization_reordering() const;
  PROTOBUF_NODISCARD ::research_scann::ExactReordering* release_query_tokenization_reordering();
  ::research_scann::ExactReordering* mutable_query_tokenization_reordering();
  void set_allocated_query_tokenization_reordering(::research_scann::ExactReordering* value);
  void unsafe_arena_set_allocated_query_tokenization_reordering(::research_scann::ExactReordering* value);
  ::research_scann::ExactReordering* unsafe_arena_release_query_tokenization_reordering();

  private:
  const ::research_scann::ExactReordering& _internal_query_tokenization_reordering() const;
  ::research_scann::ExactReordering* _internal_mutable_query_tokenization_reordering();

  public:
  // optional uint32 top_partitioning_children = 1;
  bool has_top_partitioning_children() const;
  void clear_top_partitioning_children() ;
  ::uint32_t top_partitioning_children() const;
  void set_top_partitioning_children(::uint32_t value);

  private:
  ::uint32_t _internal_top_partitioning_children() const;
  void _internal_set_top_partitioning_children(::uint32_t value);

  public:
  // optional bool top_partitioner_use_flume_trainer = 9 [default = false];
  bool has_top_partitioner_use_flume_trainer() const;
  void clear_top_partitioner_use_flume_trainer() ;
  bool top_partitioner_use_flume_trainer() const;
  void set_top_partitioner_use_flume_trainer(bool value);

  private:
  bool _internal_top_partitioner_use_flume_trainer() const;
  void _internal_set_top_partitioner_use_flume_trainer(bool value);

  public:
  // optional float top_partitioner_spilling_ratio = 2 [default = 0.05];
  bool has_top_partitioner_spilling_ratio() const;
  void clear_top_partitioner_spilling_ratio() ;
  float top_partitioner_spilling_ratio() const;
  void set_top_partitioner_spilling_ratio(float value);

  private:
  float _internal_top_partitioner_spilling_ratio() const;
  void _internal_set_top_partitioner_spilling_ratio(float value);

  public:
  // optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_query_tokenization_type = 7 [default = FLOAT];
  bool has_top_partitioner_query_tokenization_type() const;
  void clear_top_partitioner_query_tokenization_type() ;
  ::research_scann::PartitioningConfig_TokenizationType top_partitioner_query_tokenization_type() const;
  void set_top_partitioner_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  private:
  ::research_scann::PartitioningConfig_TokenizationType _internal_top_partitioner_query_tokenization_type() const;
  void _internal_set_top_partitioner_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  public:
  // optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_database_tokenization_type = 8 [default = FLOAT];
  bool has_top_partitioner_database_tokenization_type() const;
  void clear_top_partitioner_database_tokenization_type() ;
  ::research_scann::PartitioningConfig_TokenizationType top_partitioner_database_tokenization_type() const;
  void set_top_partitioner_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  private:
  ::research_scann::PartitioningConfig_TokenizationType _internal_top_partitioner_database_tokenization_type() const;
  void _internal_set_top_partitioner_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  public:
  // optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_training_tokenization_type = 10 [default = FLOAT];
  bool has_top_partitioner_training_tokenization_type() const;
  void clear_top_partitioner_training_tokenization_type() ;
  ::research_scann::PartitioningConfig_TokenizationType top_partitioner_training_tokenization_type() const;
  void set_top_partitioner_training_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  private:
  ::research_scann::PartitioningConfig_TokenizationType _internal_top_partitioner_training_tokenization_type() const;
  void _internal_set_top_partitioner_training_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.TreeXHybridPartitioningConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 6,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr assets_dir_;
    ::research_scann::ExactReordering* training_reordering_;
    ::research_scann::ExactReordering* database_tokenization_reordering_;
    ::research_scann::ExactReordering* query_tokenization_reordering_;
    ::uint32_t top_partitioning_children_;
    bool top_partitioner_use_flume_trainer_;
    float top_partitioner_spilling_ratio_;
    int top_partitioner_query_tokenization_type_;
    int top_partitioner_database_tokenization_type_;
    int top_partitioner_training_tokenization_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};// -------------------------------------------------------------------

class PartitioningConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.PartitioningConfig) */ {
 public:
  inline PartitioningConfig() : PartitioningConfig(nullptr) {}
  ~PartitioningConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PartitioningConfig(::google::protobuf::internal::ConstantInitialized);

  inline PartitioningConfig(const PartitioningConfig& from)
      : PartitioningConfig(nullptr, from) {}
  PartitioningConfig(PartitioningConfig&& from) noexcept
    : PartitioningConfig() {
    *this = ::std::move(from);
  }

  inline PartitioningConfig& operator=(const PartitioningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitioningConfig& operator=(PartitioningConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitioningConfig& default_instance() {
    return *internal_default_instance();
  }
  enum SamplingFractionOrExpectedSizeCase {
    kPartitioningSamplingFraction = 4,
    kExpectedSampleSize = 45,
    SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET = 0,
  };

  static inline const PartitioningConfig* internal_default_instance() {
    return reinterpret_cast<const PartitioningConfig*>(
               &_PartitioningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PartitioningConfig& a, PartitioningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitioningConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitioningConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitioningConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitioningConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartitioningConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PartitioningConfig& from) {
    PartitioningConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PartitioningConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.PartitioningConfig";
  }
  protected:
  explicit PartitioningConfig(::google::protobuf::Arena* arena);
  PartitioningConfig(::google::protobuf::Arena* arena, const PartitioningConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TreeType = PartitioningConfig_TreeType;
  static constexpr TreeType KMEANS_TREE = PartitioningConfig_TreeType_KMEANS_TREE;
  static constexpr TreeType PCA_TREE = PartitioningConfig_TreeType_PCA_TREE;
  static constexpr TreeType RANDOM_PROJECTION_TREE = PartitioningConfig_TreeType_RANDOM_PROJECTION_TREE;
  static constexpr TreeType BALL_TREE = PartitioningConfig_TreeType_BALL_TREE;
  static constexpr TreeType RANDOM = PartitioningConfig_TreeType_RANDOM;
  static constexpr TreeType TREE_X_HYBRID = PartitioningConfig_TreeType_TREE_X_HYBRID;
  static inline bool TreeType_IsValid(int value) {
    return PartitioningConfig_TreeType_IsValid(value);
  }
  static constexpr TreeType TreeType_MIN = PartitioningConfig_TreeType_TreeType_MIN;
  static constexpr TreeType TreeType_MAX = PartitioningConfig_TreeType_TreeType_MAX;
  static constexpr int TreeType_ARRAYSIZE = PartitioningConfig_TreeType_TreeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TreeType_descriptor() {
    return PartitioningConfig_TreeType_descriptor();
  }
  template <typename T>
  static inline const std::string& TreeType_Name(T value) {
    return PartitioningConfig_TreeType_Name(value);
  }
  static inline bool TreeType_Parse(absl::string_view name, TreeType* value) {
    return PartitioningConfig_TreeType_Parse(name, value);
  }

  using TokenizationType = PartitioningConfig_TokenizationType;
  static constexpr TokenizationType FLOAT = PartitioningConfig_TokenizationType_FLOAT;
  static constexpr TokenizationType FIXED_POINT_INT8 = PartitioningConfig_TokenizationType_FIXED_POINT_INT8;
  static constexpr TokenizationType ASYMMETRIC = PartitioningConfig_TokenizationType_ASYMMETRIC;
  static inline bool TokenizationType_IsValid(int value) {
    return PartitioningConfig_TokenizationType_IsValid(value);
  }
  static constexpr TokenizationType TokenizationType_MIN = PartitioningConfig_TokenizationType_TokenizationType_MIN;
  static constexpr TokenizationType TokenizationType_MAX = PartitioningConfig_TokenizationType_TokenizationType_MAX;
  static constexpr int TokenizationType_ARRAYSIZE = PartitioningConfig_TokenizationType_TokenizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TokenizationType_descriptor() {
    return PartitioningConfig_TokenizationType_descriptor();
  }
  template <typename T>
  static inline const std::string& TokenizationType_Name(T value) {
    return PartitioningConfig_TokenizationType_Name(value);
  }
  static inline bool TokenizationType_Parse(absl::string_view name, TokenizationType* value) {
    return PartitioningConfig_TokenizationType_Parse(name, value);
  }

  using PartitioningType = PartitioningConfig_PartitioningType;
  static constexpr PartitioningType GENERIC = PartitioningConfig_PartitioningType_GENERIC;
  static constexpr PartitioningType SPHERICAL = PartitioningConfig_PartitioningType_SPHERICAL;
  static inline bool PartitioningType_IsValid(int value) {
    return PartitioningConfig_PartitioningType_IsValid(value);
  }
  static constexpr PartitioningType PartitioningType_MIN = PartitioningConfig_PartitioningType_PartitioningType_MIN;
  static constexpr PartitioningType PartitioningType_MAX = PartitioningConfig_PartitioningType_PartitioningType_MAX;
  static constexpr int PartitioningType_ARRAYSIZE = PartitioningConfig_PartitioningType_PartitioningType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PartitioningType_descriptor() {
    return PartitioningConfig_PartitioningType_descriptor();
  }
  template <typename T>
  static inline const std::string& PartitioningType_Name(T value) {
    return PartitioningConfig_PartitioningType_Name(value);
  }
  static inline bool PartitioningType_Parse(absl::string_view name, PartitioningType* value) {
    return PartitioningConfig_PartitioningType_Parse(name, value);
  }

  using BalancingType = PartitioningConfig_BalancingType;
  static constexpr BalancingType DEFAULT_UNBALANCED = PartitioningConfig_BalancingType_DEFAULT_UNBALANCED;
  static constexpr BalancingType GREEDY_BALANCED = PartitioningConfig_BalancingType_GREEDY_BALANCED;
  static inline bool BalancingType_IsValid(int value) {
    return PartitioningConfig_BalancingType_IsValid(value);
  }
  static constexpr BalancingType BalancingType_MIN = PartitioningConfig_BalancingType_BalancingType_MIN;
  static constexpr BalancingType BalancingType_MAX = PartitioningConfig_BalancingType_BalancingType_MAX;
  static constexpr int BalancingType_ARRAYSIZE = PartitioningConfig_BalancingType_BalancingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BalancingType_descriptor() {
    return PartitioningConfig_BalancingType_descriptor();
  }
  template <typename T>
  static inline const std::string& BalancingType_Name(T value) {
    return PartitioningConfig_BalancingType_Name(value);
  }
  static inline bool BalancingType_Parse(absl::string_view name, BalancingType* value) {
    return PartitioningConfig_BalancingType_Parse(name, value);
  }

  using SingleMachineCenterInitializationType = PartitioningConfig_SingleMachineCenterInitializationType;
  static constexpr SingleMachineCenterInitializationType DEFAULT_KMEANS_PLUS_PLUS = PartitioningConfig_SingleMachineCenterInitializationType_DEFAULT_KMEANS_PLUS_PLUS;
  static constexpr SingleMachineCenterInitializationType RANDOM_INITIALIZATION = PartitioningConfig_SingleMachineCenterInitializationType_RANDOM_INITIALIZATION;
  static inline bool SingleMachineCenterInitializationType_IsValid(int value) {
    return PartitioningConfig_SingleMachineCenterInitializationType_IsValid(value);
  }
  static constexpr SingleMachineCenterInitializationType SingleMachineCenterInitializationType_MIN = PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MIN;
  static constexpr SingleMachineCenterInitializationType SingleMachineCenterInitializationType_MAX = PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MAX;
  static constexpr int SingleMachineCenterInitializationType_ARRAYSIZE = PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SingleMachineCenterInitializationType_descriptor() {
    return PartitioningConfig_SingleMachineCenterInitializationType_descriptor();
  }
  template <typename T>
  static inline const std::string& SingleMachineCenterInitializationType_Name(T value) {
    return PartitioningConfig_SingleMachineCenterInitializationType_Name(value);
  }
  static inline bool SingleMachineCenterInitializationType_Parse(absl::string_view name, SingleMachineCenterInitializationType* value) {
    return PartitioningConfig_SingleMachineCenterInitializationType_Parse(name, value);
  }

  using PartitionerTrainerType = PartitioningConfig_PartitionerTrainerType;
  static constexpr PartitionerTrainerType DEFAULT_SAMPLING_TRAINER = PartitioningConfig_PartitionerTrainerType_DEFAULT_SAMPLING_TRAINER;
  static constexpr PartitionerTrainerType FLUME_KMEANS_TRAINER = PartitioningConfig_PartitionerTrainerType_FLUME_KMEANS_TRAINER;
  static constexpr PartitionerTrainerType PCA_KMEANS_TRAINER = PartitioningConfig_PartitionerTrainerType_PCA_KMEANS_TRAINER;
  static constexpr PartitionerTrainerType SAMPLING_PCA_KMEANS_TRAINER = PartitioningConfig_PartitionerTrainerType_SAMPLING_PCA_KMEANS_TRAINER;
  static inline bool PartitionerTrainerType_IsValid(int value) {
    return PartitioningConfig_PartitionerTrainerType_IsValid(value);
  }
  static constexpr PartitionerTrainerType PartitionerTrainerType_MIN = PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MIN;
  static constexpr PartitionerTrainerType PartitionerTrainerType_MAX = PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MAX;
  static constexpr int PartitionerTrainerType_ARRAYSIZE = PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PartitionerTrainerType_descriptor() {
    return PartitioningConfig_PartitionerTrainerType_descriptor();
  }
  template <typename T>
  static inline const std::string& PartitionerTrainerType_Name(T value) {
    return PartitioningConfig_PartitionerTrainerType_Name(value);
  }
  static inline bool PartitionerTrainerType_Parse(absl::string_view name, PartitionerTrainerType* value) {
    return PartitioningConfig_PartitionerTrainerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumChildrenPerLevelFieldNumber = 60,
    kPartitionerPrefixFieldNumber = 8,
    kMrJobnamePrefixFieldNumber = 13,
    kReshardedPrefixFieldNumber = 14,
    kCellFieldNumber = 15,
    kTrainerStatsPrefixFieldNumber = 37,
    kPartitioningDistanceFieldNumber = 10,
    kProjectionFieldNumber = 12,
    kDatabaseSpillingFieldNumber = 20,
    kQuerySpillingFieldNumber = 21,
    kDatabaseTokenizationDistanceOverrideFieldNumber = 24,
    kQueryTokenizationDistanceOverrideFieldNumber = 25,
    kTreeXHybridFieldNumber = 46,
    kPartitioningTypeFieldNumber = 23,
    kClusteringSeedFieldNumber = 27,
    kTreeTypeFieldNumber = 31,
    kComputeResidualStdevFieldNumber = 47,
    kUseFloatCentersForQueryTokenizationFieldNumber = 26,
    kPartitioningOnTheFlyFieldNumber = 22,
    kUseFlumeKmeansFieldNumber = 32,
    kBalancingTypeFieldNumber = 35,
    kTrainerTypeFieldNumber = 36,
    kPerturbationFieldNumber = 41,
    kMaxClusterSizeFieldNumber = 40,
    kSingleMachineCenterInitializationFieldNumber = 49,
    kNumPartitioningEpochsFieldNumber = 1,
    kMaxNumLevelsFieldNumber = 2,
    kNumChildrenFieldNumber = 3,
    kMaxClusteringIterationsFieldNumber = 6,
    kClusteringConvergenceToleranceFieldNumber = 7,
    kMinClusterSizeFieldNumber = 9,
    kMaxLeafSizeFieldNumber = 11,
    kRamGbFieldNumber = 16,
    kDiskGbFieldNumber = 17,
    kNumCpusFieldNumber = 19,
    kQueryTokenizationTypeFieldNumber = 28,
    kDatabaseTokenizationTypeFieldNumber = 29,
    kNumMapperMachinesFieldNumber = 30,
    kMaxSampleSizeFieldNumber = 33,
    kDesiredAverageClusterSizeFieldNumber = 34,
    kNumMiniBatchesFieldNumber = 38,
    kMaxPowerOf2SplitFieldNumber = 39,
    kNumTopTokensForPcaFieldNumber = 42,
    kPcaSplittingSimilarityThresholdFieldNumber = 43,
    kAvqFieldNumber = 51,
    kResidualStdevMinValueFieldNumber = 48,
    kPartitioningSamplingFractionFieldNumber = 4,
    kExpectedSampleSizeFieldNumber = 45,
  };
  // repeated int32 num_children_per_level = 60;
  int num_children_per_level_size() const;
  private:
  int _internal_num_children_per_level_size() const;

  public:
  void clear_num_children_per_level() ;
  ::int32_t num_children_per_level(int index) const;
  void set_num_children_per_level(int index, ::int32_t value);
  void add_num_children_per_level(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& num_children_per_level() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_num_children_per_level();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_num_children_per_level() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_num_children_per_level();

  public:
  // optional string partitioner_prefix = 8;
  bool has_partitioner_prefix() const;
  void clear_partitioner_prefix() ;
  const std::string& partitioner_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partitioner_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_partitioner_prefix();
  PROTOBUF_NODISCARD std::string* release_partitioner_prefix();
  void set_allocated_partitioner_prefix(std::string* value);

  private:
  const std::string& _internal_partitioner_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partitioner_prefix(
      const std::string& value);
  std::string* _internal_mutable_partitioner_prefix();

  public:
  // optional string mr_jobname_prefix = 13 [default = "PartitionReshard"];
  bool has_mr_jobname_prefix() const;
  void clear_mr_jobname_prefix() ;
  const std::string& mr_jobname_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mr_jobname_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_mr_jobname_prefix();
  PROTOBUF_NODISCARD std::string* release_mr_jobname_prefix();
  void set_allocated_mr_jobname_prefix(std::string* value);

  private:
  const std::string& _internal_mr_jobname_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mr_jobname_prefix(
      const std::string& value);
  std::string* _internal_mutable_mr_jobname_prefix();

  public:
  // optional string resharded_prefix = 14;
  bool has_resharded_prefix() const;
  void clear_resharded_prefix() ;
  const std::string& resharded_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resharded_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_resharded_prefix();
  PROTOBUF_NODISCARD std::string* release_resharded_prefix();
  void set_allocated_resharded_prefix(std::string* value);

  private:
  const std::string& _internal_resharded_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resharded_prefix(
      const std::string& value);
  std::string* _internal_mutable_resharded_prefix();

  public:
  // optional string cell = 15;
  bool has_cell() const;
  void clear_cell() ;
  const std::string& cell() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cell(Arg_&& arg, Args_... args);
  std::string* mutable_cell();
  PROTOBUF_NODISCARD std::string* release_cell();
  void set_allocated_cell(std::string* value);

  private:
  const std::string& _internal_cell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cell(
      const std::string& value);
  std::string* _internal_mutable_cell();

  public:
  // optional string trainer_stats_prefix = 37;
  bool has_trainer_stats_prefix() const;
  void clear_trainer_stats_prefix() ;
  const std::string& trainer_stats_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trainer_stats_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_trainer_stats_prefix();
  PROTOBUF_NODISCARD std::string* release_trainer_stats_prefix();
  void set_allocated_trainer_stats_prefix(std::string* value);

  private:
  const std::string& _internal_trainer_stats_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trainer_stats_prefix(
      const std::string& value);
  std::string* _internal_mutable_trainer_stats_prefix();

  public:
  // optional .research_scann.DistanceMeasureConfig partitioning_distance = 10;
  bool has_partitioning_distance() const;
  void clear_partitioning_distance() ;
  const ::research_scann::DistanceMeasureConfig& partitioning_distance() const;
  PROTOBUF_NODISCARD ::research_scann::DistanceMeasureConfig* release_partitioning_distance();
  ::research_scann::DistanceMeasureConfig* mutable_partitioning_distance();
  void set_allocated_partitioning_distance(::research_scann::DistanceMeasureConfig* value);
  void unsafe_arena_set_allocated_partitioning_distance(::research_scann::DistanceMeasureConfig* value);
  ::research_scann::DistanceMeasureConfig* unsafe_arena_release_partitioning_distance();

  private:
  const ::research_scann::DistanceMeasureConfig& _internal_partitioning_distance() const;
  ::research_scann::DistanceMeasureConfig* _internal_mutable_partitioning_distance();

  public:
  // optional .research_scann.ProjectionConfig projection = 12;
  bool has_projection() const;
  void clear_projection() ;
  const ::research_scann::ProjectionConfig& projection() const;
  PROTOBUF_NODISCARD ::research_scann::ProjectionConfig* release_projection();
  ::research_scann::ProjectionConfig* mutable_projection();
  void set_allocated_projection(::research_scann::ProjectionConfig* value);
  void unsafe_arena_set_allocated_projection(::research_scann::ProjectionConfig* value);
  ::research_scann::ProjectionConfig* unsafe_arena_release_projection();

  private:
  const ::research_scann::ProjectionConfig& _internal_projection() const;
  ::research_scann::ProjectionConfig* _internal_mutable_projection();

  public:
  // optional .research_scann.DatabaseSpillingConfig database_spilling = 20;
  bool has_database_spilling() const;
  void clear_database_spilling() ;
  const ::research_scann::DatabaseSpillingConfig& database_spilling() const;
  PROTOBUF_NODISCARD ::research_scann::DatabaseSpillingConfig* release_database_spilling();
  ::research_scann::DatabaseSpillingConfig* mutable_database_spilling();
  void set_allocated_database_spilling(::research_scann::DatabaseSpillingConfig* value);
  void unsafe_arena_set_allocated_database_spilling(::research_scann::DatabaseSpillingConfig* value);
  ::research_scann::DatabaseSpillingConfig* unsafe_arena_release_database_spilling();

  private:
  const ::research_scann::DatabaseSpillingConfig& _internal_database_spilling() const;
  ::research_scann::DatabaseSpillingConfig* _internal_mutable_database_spilling();

  public:
  // optional .research_scann.QuerySpillingConfig query_spilling = 21;
  bool has_query_spilling() const;
  void clear_query_spilling() ;
  const ::research_scann::QuerySpillingConfig& query_spilling() const;
  PROTOBUF_NODISCARD ::research_scann::QuerySpillingConfig* release_query_spilling();
  ::research_scann::QuerySpillingConfig* mutable_query_spilling();
  void set_allocated_query_spilling(::research_scann::QuerySpillingConfig* value);
  void unsafe_arena_set_allocated_query_spilling(::research_scann::QuerySpillingConfig* value);
  ::research_scann::QuerySpillingConfig* unsafe_arena_release_query_spilling();

  private:
  const ::research_scann::QuerySpillingConfig& _internal_query_spilling() const;
  ::research_scann::QuerySpillingConfig* _internal_mutable_query_spilling();

  public:
  // optional .research_scann.DistanceMeasureConfig database_tokenization_distance_override = 24;
  bool has_database_tokenization_distance_override() const;
  void clear_database_tokenization_distance_override() ;
  const ::research_scann::DistanceMeasureConfig& database_tokenization_distance_override() const;
  PROTOBUF_NODISCARD ::research_scann::DistanceMeasureConfig* release_database_tokenization_distance_override();
  ::research_scann::DistanceMeasureConfig* mutable_database_tokenization_distance_override();
  void set_allocated_database_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value);
  void unsafe_arena_set_allocated_database_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value);
  ::research_scann::DistanceMeasureConfig* unsafe_arena_release_database_tokenization_distance_override();

  private:
  const ::research_scann::DistanceMeasureConfig& _internal_database_tokenization_distance_override() const;
  ::research_scann::DistanceMeasureConfig* _internal_mutable_database_tokenization_distance_override();

  public:
  // optional .research_scann.DistanceMeasureConfig query_tokenization_distance_override = 25;
  bool has_query_tokenization_distance_override() const;
  void clear_query_tokenization_distance_override() ;
  const ::research_scann::DistanceMeasureConfig& query_tokenization_distance_override() const;
  PROTOBUF_NODISCARD ::research_scann::DistanceMeasureConfig* release_query_tokenization_distance_override();
  ::research_scann::DistanceMeasureConfig* mutable_query_tokenization_distance_override();
  void set_allocated_query_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value);
  void unsafe_arena_set_allocated_query_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value);
  ::research_scann::DistanceMeasureConfig* unsafe_arena_release_query_tokenization_distance_override();

  private:
  const ::research_scann::DistanceMeasureConfig& _internal_query_tokenization_distance_override() const;
  ::research_scann::DistanceMeasureConfig* _internal_mutable_query_tokenization_distance_override();

  public:
  // optional .research_scann.TreeXHybridPartitioningConfig tree_x_hybrid = 46;
  bool has_tree_x_hybrid() const;
  void clear_tree_x_hybrid() ;
  const ::research_scann::TreeXHybridPartitioningConfig& tree_x_hybrid() const;
  PROTOBUF_NODISCARD ::research_scann::TreeXHybridPartitioningConfig* release_tree_x_hybrid();
  ::research_scann::TreeXHybridPartitioningConfig* mutable_tree_x_hybrid();
  void set_allocated_tree_x_hybrid(::research_scann::TreeXHybridPartitioningConfig* value);
  void unsafe_arena_set_allocated_tree_x_hybrid(::research_scann::TreeXHybridPartitioningConfig* value);
  ::research_scann::TreeXHybridPartitioningConfig* unsafe_arena_release_tree_x_hybrid();

  private:
  const ::research_scann::TreeXHybridPartitioningConfig& _internal_tree_x_hybrid() const;
  ::research_scann::TreeXHybridPartitioningConfig* _internal_mutable_tree_x_hybrid();

  public:
  // optional .research_scann.PartitioningConfig.PartitioningType partitioning_type = 23 [default = GENERIC];
  bool has_partitioning_type() const;
  void clear_partitioning_type() ;
  ::research_scann::PartitioningConfig_PartitioningType partitioning_type() const;
  void set_partitioning_type(::research_scann::PartitioningConfig_PartitioningType value);

  private:
  ::research_scann::PartitioningConfig_PartitioningType _internal_partitioning_type() const;
  void _internal_set_partitioning_type(::research_scann::PartitioningConfig_PartitioningType value);

  public:
  // optional int32 clustering_seed = 27 [default = 0];
  bool has_clustering_seed() const;
  void clear_clustering_seed() ;
  ::int32_t clustering_seed() const;
  void set_clustering_seed(::int32_t value);

  private:
  ::int32_t _internal_clustering_seed() const;
  void _internal_set_clustering_seed(::int32_t value);

  public:
  // optional .research_scann.PartitioningConfig.TreeType tree_type = 31 [default = KMEANS_TREE];
  bool has_tree_type() const;
  void clear_tree_type() ;
  ::research_scann::PartitioningConfig_TreeType tree_type() const;
  void set_tree_type(::research_scann::PartitioningConfig_TreeType value);

  private:
  ::research_scann::PartitioningConfig_TreeType _internal_tree_type() const;
  void _internal_set_tree_type(::research_scann::PartitioningConfig_TreeType value);

  public:
  // optional bool compute_residual_stdev = 47 [default = false];
  bool has_compute_residual_stdev() const;
  void clear_compute_residual_stdev() ;
  bool compute_residual_stdev() const;
  void set_compute_residual_stdev(bool value);

  private:
  bool _internal_compute_residual_stdev() const;
  void _internal_set_compute_residual_stdev(bool value);

  public:
  // optional bool use_float_centers_for_query_tokenization = 26 [default = false, deprecated = true];
  [[deprecated]]  bool has_use_float_centers_for_query_tokenization() const;
  [[deprecated]]  void clear_use_float_centers_for_query_tokenization() ;
  [[deprecated]] bool use_float_centers_for_query_tokenization() const;
  [[deprecated]] void set_use_float_centers_for_query_tokenization(bool value);

  private:
  bool _internal_use_float_centers_for_query_tokenization() const;
  void _internal_set_use_float_centers_for_query_tokenization(bool value);

  public:
  // optional bool partitioning_on_the_fly = 22 [default = false, deprecated = true];
  [[deprecated]]  bool has_partitioning_on_the_fly() const;
  [[deprecated]]  void clear_partitioning_on_the_fly() ;
  [[deprecated]] bool partitioning_on_the_fly() const;
  [[deprecated]] void set_partitioning_on_the_fly(bool value);

  private:
  bool _internal_partitioning_on_the_fly() const;
  void _internal_set_partitioning_on_the_fly(bool value);

  public:
  // optional bool use_flume_kmeans = 32 [default = false, deprecated = true];
  [[deprecated]]  bool has_use_flume_kmeans() const;
  [[deprecated]]  void clear_use_flume_kmeans() ;
  [[deprecated]] bool use_flume_kmeans() const;
  [[deprecated]] void set_use_flume_kmeans(bool value);

  private:
  bool _internal_use_flume_kmeans() const;
  void _internal_set_use_flume_kmeans(bool value);

  public:
  // optional .research_scann.PartitioningConfig.BalancingType balancing_type = 35 [default = DEFAULT_UNBALANCED];
  bool has_balancing_type() const;
  void clear_balancing_type() ;
  ::research_scann::PartitioningConfig_BalancingType balancing_type() const;
  void set_balancing_type(::research_scann::PartitioningConfig_BalancingType value);

  private:
  ::research_scann::PartitioningConfig_BalancingType _internal_balancing_type() const;
  void _internal_set_balancing_type(::research_scann::PartitioningConfig_BalancingType value);

  public:
  // optional .research_scann.PartitioningConfig.PartitionerTrainerType trainer_type = 36 [default = DEFAULT_SAMPLING_TRAINER];
  bool has_trainer_type() const;
  void clear_trainer_type() ;
  ::research_scann::PartitioningConfig_PartitionerTrainerType trainer_type() const;
  void set_trainer_type(::research_scann::PartitioningConfig_PartitionerTrainerType value);

  private:
  ::research_scann::PartitioningConfig_PartitionerTrainerType _internal_trainer_type() const;
  void _internal_set_trainer_type(::research_scann::PartitioningConfig_PartitionerTrainerType value);

  public:
  // optional double perturbation = 41;
  bool has_perturbation() const;
  void clear_perturbation() ;
  double perturbation() const;
  void set_perturbation(double value);

  private:
  double _internal_perturbation() const;
  void _internal_set_perturbation(double value);

  public:
  // optional int32 max_cluster_size = 40;
  bool has_max_cluster_size() const;
  void clear_max_cluster_size() ;
  ::int32_t max_cluster_size() const;
  void set_max_cluster_size(::int32_t value);

  private:
  ::int32_t _internal_max_cluster_size() const;
  void _internal_set_max_cluster_size(::int32_t value);

  public:
  // optional .research_scann.PartitioningConfig.SingleMachineCenterInitializationType single_machine_center_initialization = 49 [default = DEFAULT_KMEANS_PLUS_PLUS];
  bool has_single_machine_center_initialization() const;
  void clear_single_machine_center_initialization() ;
  ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType single_machine_center_initialization() const;
  void set_single_machine_center_initialization(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType value);

  private:
  ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType _internal_single_machine_center_initialization() const;
  void _internal_set_single_machine_center_initialization(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType value);

  public:
  // optional int32 num_partitioning_epochs = 1 [default = 1];
  bool has_num_partitioning_epochs() const;
  void clear_num_partitioning_epochs() ;
  ::int32_t num_partitioning_epochs() const;
  void set_num_partitioning_epochs(::int32_t value);

  private:
  ::int32_t _internal_num_partitioning_epochs() const;
  void _internal_set_num_partitioning_epochs(::int32_t value);

  public:
  // optional int32 max_num_levels = 2 [default = 1];
  bool has_max_num_levels() const;
  void clear_max_num_levels() ;
  ::int32_t max_num_levels() const;
  void set_max_num_levels(::int32_t value);

  private:
  ::int32_t _internal_max_num_levels() const;
  void _internal_set_max_num_levels(::int32_t value);

  public:
  // optional int32 num_children = 3 [default = 2];
  bool has_num_children() const;
  void clear_num_children() ;
  ::int32_t num_children() const;
  void set_num_children(::int32_t value);

  private:
  ::int32_t _internal_num_children() const;
  void _internal_set_num_children(::int32_t value);

  public:
  // optional int32 max_clustering_iterations = 6 [default = 10];
  bool has_max_clustering_iterations() const;
  void clear_max_clustering_iterations() ;
  ::int32_t max_clustering_iterations() const;
  void set_max_clustering_iterations(::int32_t value);

  private:
  ::int32_t _internal_max_clustering_iterations() const;
  void _internal_set_max_clustering_iterations(::int32_t value);

  public:
  // optional float clustering_convergence_tolerance = 7 [default = 1e-05];
  bool has_clustering_convergence_tolerance() const;
  void clear_clustering_convergence_tolerance() ;
  float clustering_convergence_tolerance() const;
  void set_clustering_convergence_tolerance(float value);

  private:
  float _internal_clustering_convergence_tolerance() const;
  void _internal_set_clustering_convergence_tolerance(float value);

  public:
  // optional float min_cluster_size = 9 [default = 1];
  bool has_min_cluster_size() const;
  void clear_min_cluster_size() ;
  float min_cluster_size() const;
  void set_min_cluster_size(float value);

  private:
  float _internal_min_cluster_size() const;
  void _internal_set_min_cluster_size(float value);

  public:
  // optional int32 max_leaf_size = 11 [default = 1];
  bool has_max_leaf_size() const;
  void clear_max_leaf_size() ;
  ::int32_t max_leaf_size() const;
  void set_max_leaf_size(::int32_t value);

  private:
  ::int32_t _internal_max_leaf_size() const;
  void _internal_set_max_leaf_size(::int32_t value);

  public:
  // optional int32 ram_gb = 16 [default = 4];
  bool has_ram_gb() const;
  void clear_ram_gb() ;
  ::int32_t ram_gb() const;
  void set_ram_gb(::int32_t value);

  private:
  ::int32_t _internal_ram_gb() const;
  void _internal_set_ram_gb(::int32_t value);

  public:
  // optional int32 disk_gb = 17 [default = 1];
  bool has_disk_gb() const;
  void clear_disk_gb() ;
  ::int32_t disk_gb() const;
  void set_disk_gb(::int32_t value);

  private:
  ::int32_t _internal_disk_gb() const;
  void _internal_set_disk_gb(::int32_t value);

  public:
  // optional int32 num_cpus = 19 [default = 1];
  bool has_num_cpus() const;
  void clear_num_cpus() ;
  ::int32_t num_cpus() const;
  void set_num_cpus(::int32_t value);

  private:
  ::int32_t _internal_num_cpus() const;
  void _internal_set_num_cpus(::int32_t value);

  public:
  // optional .research_scann.PartitioningConfig.TokenizationType query_tokenization_type = 28 [default = FLOAT];
  bool has_query_tokenization_type() const;
  void clear_query_tokenization_type() ;
  ::research_scann::PartitioningConfig_TokenizationType query_tokenization_type() const;
  void set_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  private:
  ::research_scann::PartitioningConfig_TokenizationType _internal_query_tokenization_type() const;
  void _internal_set_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  public:
  // optional .research_scann.PartitioningConfig.TokenizationType database_tokenization_type = 29 [default = FLOAT];
  bool has_database_tokenization_type() const;
  void clear_database_tokenization_type() ;
  ::research_scann::PartitioningConfig_TokenizationType database_tokenization_type() const;
  void set_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  private:
  ::research_scann::PartitioningConfig_TokenizationType _internal_database_tokenization_type() const;
  void _internal_set_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  public:
  // optional int32 num_mapper_machines = 30 [default = -1];
  bool has_num_mapper_machines() const;
  void clear_num_mapper_machines() ;
  ::int32_t num_mapper_machines() const;
  void set_num_mapper_machines(::int32_t value);

  private:
  ::int32_t _internal_num_mapper_machines() const;
  void _internal_set_num_mapper_machines(::int32_t value);

  public:
  // optional int32 max_sample_size = 33 [default = 2147483647, deprecated = true];
  [[deprecated]]  bool has_max_sample_size() const;
  [[deprecated]]  void clear_max_sample_size() ;
  [[deprecated]] ::int32_t max_sample_size() const;
  [[deprecated]] void set_max_sample_size(::int32_t value);

  private:
  ::int32_t _internal_max_sample_size() const;
  void _internal_set_max_sample_size(::int32_t value);

  public:
  // optional int32 desired_average_cluster_size = 34 [default = 3000];
  bool has_desired_average_cluster_size() const;
  void clear_desired_average_cluster_size() ;
  ::int32_t desired_average_cluster_size() const;
  void set_desired_average_cluster_size(::int32_t value);

  private:
  ::int32_t _internal_desired_average_cluster_size() const;
  void _internal_set_desired_average_cluster_size(::int32_t value);

  public:
  // optional int32 num_mini_batches = 38 [default = 1];
  bool has_num_mini_batches() const;
  void clear_num_mini_batches() ;
  ::int32_t num_mini_batches() const;
  void set_num_mini_batches(::int32_t value);

  private:
  ::int32_t _internal_num_mini_batches() const;
  void _internal_set_num_mini_batches(::int32_t value);

  public:
  // optional int32 max_power_of_2_split = 39 [default = 2];
  bool has_max_power_of_2_split() const;
  void clear_max_power_of_2_split() ;
  ::int32_t max_power_of_2_split() const;
  void set_max_power_of_2_split(::int32_t value);

  private:
  ::int32_t _internal_max_power_of_2_split() const;
  void _internal_set_max_power_of_2_split(::int32_t value);

  public:
  // optional int32 num_top_tokens_for_pca = 42 [default = 20];
  bool has_num_top_tokens_for_pca() const;
  void clear_num_top_tokens_for_pca() ;
  ::int32_t num_top_tokens_for_pca() const;
  void set_num_top_tokens_for_pca(::int32_t value);

  private:
  ::int32_t _internal_num_top_tokens_for_pca() const;
  void _internal_set_num_top_tokens_for_pca(::int32_t value);

  public:
  // optional float pca_splitting_similarity_threshold = 43 [default = 1e-05];
  bool has_pca_splitting_similarity_threshold() const;
  void clear_pca_splitting_similarity_threshold() ;
  float pca_splitting_similarity_threshold() const;
  void set_pca_splitting_similarity_threshold(float value);

  private:
  float _internal_pca_splitting_similarity_threshold() const;
  void _internal_set_pca_splitting_similarity_threshold(float value);

  public:
  // optional float avq = 51 [default = nan];
  bool has_avq() const;
  void clear_avq() ;
  float avq() const;
  void set_avq(float value);

  private:
  float _internal_avq() const;
  void _internal_set_avq(float value);

  public:
  // optional double residual_stdev_min_value = 48 [default = 1e-05];
  bool has_residual_stdev_min_value() const;
  void clear_residual_stdev_min_value() ;
  double residual_stdev_min_value() const;
  void set_residual_stdev_min_value(double value);

  private:
  double _internal_residual_stdev_min_value() const;
  void _internal_set_residual_stdev_min_value(double value);

  public:
  // float partitioning_sampling_fraction = 4 [default = 1];
  bool has_partitioning_sampling_fraction() const;
  void clear_partitioning_sampling_fraction() ;
  float partitioning_sampling_fraction() const;
  void set_partitioning_sampling_fraction(float value);

  private:
  float _internal_partitioning_sampling_fraction() const;
  void _internal_set_partitioning_sampling_fraction(float value);

  public:
  // int32 expected_sample_size = 45;
  bool has_expected_sample_size() const;
  void clear_expected_sample_size() ;
  ::int32_t expected_sample_size() const;
  void set_expected_sample_size(::int32_t value);

  private:
  ::int32_t _internal_expected_sample_size() const;
  void _internal_set_expected_sample_size(::int32_t value);

  public:
  void clear_SamplingFractionOrExpectedSize();
  SamplingFractionOrExpectedSizeCase SamplingFractionOrExpectedSize_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.PartitioningConfig)
 private:
  class _Internal;
  void set_has_partitioning_sampling_fraction();
  void set_has_expected_sample_size();

  inline bool has_SamplingFractionOrExpectedSize() const;
  inline void clear_has_SamplingFractionOrExpectedSize();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 48, 14,
      165, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<2> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> num_children_per_level_;
    ::google::protobuf::internal::ArenaStringPtr partitioner_prefix_;
    static const ::google::protobuf::internal::LazyString _i_give_permission_to_break_this_code_default_mr_jobname_prefix_;
    ::google::protobuf::internal::ArenaStringPtr mr_jobname_prefix_;
    ::google::protobuf::internal::ArenaStringPtr resharded_prefix_;
    ::google::protobuf::internal::ArenaStringPtr cell_;
    ::google::protobuf::internal::ArenaStringPtr trainer_stats_prefix_;
    ::research_scann::DistanceMeasureConfig* partitioning_distance_;
    ::research_scann::ProjectionConfig* projection_;
    ::research_scann::DatabaseSpillingConfig* database_spilling_;
    ::research_scann::QuerySpillingConfig* query_spilling_;
    ::research_scann::DistanceMeasureConfig* database_tokenization_distance_override_;
    ::research_scann::DistanceMeasureConfig* query_tokenization_distance_override_;
    ::research_scann::TreeXHybridPartitioningConfig* tree_x_hybrid_;
    int partitioning_type_;
    ::int32_t clustering_seed_;
    int tree_type_;
    bool compute_residual_stdev_;
    bool use_float_centers_for_query_tokenization_;
    bool partitioning_on_the_fly_;
    bool use_flume_kmeans_;
    int balancing_type_;
    int trainer_type_;
    double perturbation_;
    ::int32_t max_cluster_size_;
    int single_machine_center_initialization_;
    ::int32_t num_partitioning_epochs_;
    ::int32_t max_num_levels_;
    ::int32_t num_children_;
    ::int32_t max_clustering_iterations_;
    float clustering_convergence_tolerance_;
    float min_cluster_size_;
    ::int32_t max_leaf_size_;
    ::int32_t ram_gb_;
    ::int32_t disk_gb_;
    ::int32_t num_cpus_;
    int query_tokenization_type_;
    int database_tokenization_type_;
    ::int32_t num_mapper_machines_;
    ::int32_t max_sample_size_;
    ::int32_t desired_average_cluster_size_;
    ::int32_t num_mini_batches_;
    ::int32_t max_power_of_2_split_;
    ::int32_t num_top_tokens_for_pca_;
    float pca_splitting_similarity_threshold_;
    float avq_;
    double residual_stdev_min_value_;
    union SamplingFractionOrExpectedSizeUnion {
      constexpr SamplingFractionOrExpectedSizeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float partitioning_sampling_fraction_;
      ::int32_t expected_sample_size_;
    } SamplingFractionOrExpectedSize_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};// -------------------------------------------------------------------

class HierarchicalPartitionerConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.HierarchicalPartitionerConfig) */ {
 public:
  inline HierarchicalPartitionerConfig() : HierarchicalPartitionerConfig(nullptr) {}
  ~HierarchicalPartitionerConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HierarchicalPartitionerConfig(::google::protobuf::internal::ConstantInitialized);

  inline HierarchicalPartitionerConfig(const HierarchicalPartitionerConfig& from)
      : HierarchicalPartitionerConfig(nullptr, from) {}
  HierarchicalPartitionerConfig(HierarchicalPartitionerConfig&& from) noexcept
    : HierarchicalPartitionerConfig() {
    *this = ::std::move(from);
  }

  inline HierarchicalPartitionerConfig& operator=(const HierarchicalPartitionerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HierarchicalPartitionerConfig& operator=(HierarchicalPartitionerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HierarchicalPartitionerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HierarchicalPartitionerConfig* internal_default_instance() {
    return reinterpret_cast<const HierarchicalPartitionerConfig*>(
               &_HierarchicalPartitionerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HierarchicalPartitionerConfig& a, HierarchicalPartitionerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HierarchicalPartitionerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HierarchicalPartitionerConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HierarchicalPartitionerConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HierarchicalPartitionerConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HierarchicalPartitionerConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HierarchicalPartitionerConfig& from) {
    HierarchicalPartitionerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HierarchicalPartitionerConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.HierarchicalPartitionerConfig";
  }
  protected:
  explicit HierarchicalPartitionerConfig(::google::protobuf::Arena* arena);
  HierarchicalPartitionerConfig(::google::protobuf::Arena* arena, const HierarchicalPartitionerConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitioningFieldNumber = 2,
    kInputOutputFieldNumber = 1,
  };
  // repeated .research_scann.PartitioningConfig partitioning = 2;
  int partitioning_size() const;
  private:
  int _internal_partitioning_size() const;

  public:
  void clear_partitioning() ;
  ::research_scann::PartitioningConfig* mutable_partitioning(int index);
  ::google::protobuf::RepeatedPtrField< ::research_scann::PartitioningConfig >*
      mutable_partitioning();
  private:
  const ::google::protobuf::RepeatedPtrField<::research_scann::PartitioningConfig>& _internal_partitioning() const;
  ::google::protobuf::RepeatedPtrField<::research_scann::PartitioningConfig>* _internal_mutable_partitioning();
  public:
  const ::research_scann::PartitioningConfig& partitioning(int index) const;
  ::research_scann::PartitioningConfig* add_partitioning();
  const ::google::protobuf::RepeatedPtrField< ::research_scann::PartitioningConfig >&
      partitioning() const;
  // optional .research_scann.InputOutputConfig input_output = 1;
  bool has_input_output() const;
  void clear_input_output() ;
  const ::research_scann::InputOutputConfig& input_output() const;
  PROTOBUF_NODISCARD ::research_scann::InputOutputConfig* release_input_output();
  ::research_scann::InputOutputConfig* mutable_input_output();
  void set_allocated_input_output(::research_scann::InputOutputConfig* value);
  void unsafe_arena_set_allocated_input_output(::research_scann::InputOutputConfig* value);
  ::research_scann::InputOutputConfig* unsafe_arena_release_input_output();

  private:
  const ::research_scann::InputOutputConfig& _internal_input_output() const;
  ::research_scann::InputOutputConfig* _internal_mutable_input_output();

  public:
  // @@protoc_insertion_point(class_scope:research_scann.HierarchicalPartitionerConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::research_scann::PartitioningConfig > partitioning_;
    ::research_scann::InputOutputConfig* input_output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PartitioningConfig

// optional .research_scann.PartitioningConfig.TreeType tree_type = 31 [default = KMEANS_TREE];
inline bool PartitioningConfig::has_tree_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_tree_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tree_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::research_scann::PartitioningConfig_TreeType PartitioningConfig::tree_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.tree_type)
  return _internal_tree_type();
}
inline void PartitioningConfig::set_tree_type(::research_scann::PartitioningConfig_TreeType value) {
  _internal_set_tree_type(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.tree_type)
}
inline ::research_scann::PartitioningConfig_TreeType PartitioningConfig::_internal_tree_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_TreeType>(_impl_.tree_type_);
}
inline void PartitioningConfig::_internal_set_tree_type(::research_scann::PartitioningConfig_TreeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_TreeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.tree_type_ = value;
}

// optional .research_scann.TreeXHybridPartitioningConfig tree_x_hybrid = 46;
inline bool PartitioningConfig::has_tree_x_hybrid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tree_x_hybrid_ != nullptr);
  return value;
}
inline void PartitioningConfig::clear_tree_x_hybrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tree_x_hybrid_ != nullptr) _impl_.tree_x_hybrid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::research_scann::TreeXHybridPartitioningConfig& PartitioningConfig::_internal_tree_x_hybrid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::TreeXHybridPartitioningConfig* p = _impl_.tree_x_hybrid_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::TreeXHybridPartitioningConfig&>(::research_scann::_TreeXHybridPartitioningConfig_default_instance_);
}
inline const ::research_scann::TreeXHybridPartitioningConfig& PartitioningConfig::tree_x_hybrid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.tree_x_hybrid)
  return _internal_tree_x_hybrid();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_tree_x_hybrid(::research_scann::TreeXHybridPartitioningConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tree_x_hybrid_);
  }
  _impl_.tree_x_hybrid_ = reinterpret_cast<::research_scann::TreeXHybridPartitioningConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.tree_x_hybrid)
}
inline ::research_scann::TreeXHybridPartitioningConfig* PartitioningConfig::release_tree_x_hybrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::research_scann::TreeXHybridPartitioningConfig* released = _impl_.tree_x_hybrid_;
  _impl_.tree_x_hybrid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::TreeXHybridPartitioningConfig* PartitioningConfig::unsafe_arena_release_tree_x_hybrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.tree_x_hybrid)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::research_scann::TreeXHybridPartitioningConfig* temp = _impl_.tree_x_hybrid_;
  _impl_.tree_x_hybrid_ = nullptr;
  return temp;
}
inline ::research_scann::TreeXHybridPartitioningConfig* PartitioningConfig::_internal_mutable_tree_x_hybrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.tree_x_hybrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::TreeXHybridPartitioningConfig>(GetArena());
    _impl_.tree_x_hybrid_ = reinterpret_cast<::research_scann::TreeXHybridPartitioningConfig*>(p);
  }
  return _impl_.tree_x_hybrid_;
}
inline ::research_scann::TreeXHybridPartitioningConfig* PartitioningConfig::mutable_tree_x_hybrid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::TreeXHybridPartitioningConfig* _msg = _internal_mutable_tree_x_hybrid();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.tree_x_hybrid)
  return _msg;
}
inline void PartitioningConfig::set_allocated_tree_x_hybrid(::research_scann::TreeXHybridPartitioningConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::TreeXHybridPartitioningConfig*>(_impl_.tree_x_hybrid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::TreeXHybridPartitioningConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.tree_x_hybrid_ = reinterpret_cast<::research_scann::TreeXHybridPartitioningConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.tree_x_hybrid)
}

// float partitioning_sampling_fraction = 4 [default = 1];
inline bool PartitioningConfig::has_partitioning_sampling_fraction() const {
  return SamplingFractionOrExpectedSize_case() == kPartitioningSamplingFraction;
}
inline void PartitioningConfig::set_has_partitioning_sampling_fraction() {
  _impl_._oneof_case_[0] = kPartitioningSamplingFraction;
}
inline void PartitioningConfig::clear_partitioning_sampling_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (SamplingFractionOrExpectedSize_case() == kPartitioningSamplingFraction) {
    _impl_.SamplingFractionOrExpectedSize_.partitioning_sampling_fraction_ = 1;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline float PartitioningConfig::partitioning_sampling_fraction() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_sampling_fraction)
  return _internal_partitioning_sampling_fraction();
}
inline void PartitioningConfig::set_partitioning_sampling_fraction(float value) {
  _internal_set_partitioning_sampling_fraction(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioning_sampling_fraction)
}
inline float PartitioningConfig::_internal_partitioning_sampling_fraction() const {
  if (SamplingFractionOrExpectedSize_case() == kPartitioningSamplingFraction) {
    return _impl_.SamplingFractionOrExpectedSize_.partitioning_sampling_fraction_;
  }
  return 1;
}
inline void PartitioningConfig::_internal_set_partitioning_sampling_fraction(float value) {
  if (SamplingFractionOrExpectedSize_case() != kPartitioningSamplingFraction) {
    clear_SamplingFractionOrExpectedSize();
    set_has_partitioning_sampling_fraction();
  }
  _impl_.SamplingFractionOrExpectedSize_.partitioning_sampling_fraction_ = value;
}

// int32 expected_sample_size = 45;
inline bool PartitioningConfig::has_expected_sample_size() const {
  return SamplingFractionOrExpectedSize_case() == kExpectedSampleSize;
}
inline void PartitioningConfig::set_has_expected_sample_size() {
  _impl_._oneof_case_[0] = kExpectedSampleSize;
}
inline void PartitioningConfig::clear_expected_sample_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (SamplingFractionOrExpectedSize_case() == kExpectedSampleSize) {
    _impl_.SamplingFractionOrExpectedSize_.expected_sample_size_ = 0;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline ::int32_t PartitioningConfig::expected_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.expected_sample_size)
  return _internal_expected_sample_size();
}
inline void PartitioningConfig::set_expected_sample_size(::int32_t value) {
  _internal_set_expected_sample_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.expected_sample_size)
}
inline ::int32_t PartitioningConfig::_internal_expected_sample_size() const {
  if (SamplingFractionOrExpectedSize_case() == kExpectedSampleSize) {
    return _impl_.SamplingFractionOrExpectedSize_.expected_sample_size_;
  }
  return 0;
}
inline void PartitioningConfig::_internal_set_expected_sample_size(::int32_t value) {
  if (SamplingFractionOrExpectedSize_case() != kExpectedSampleSize) {
    clear_SamplingFractionOrExpectedSize();
    set_has_expected_sample_size();
  }
  _impl_.SamplingFractionOrExpectedSize_.expected_sample_size_ = value;
}

// optional string partitioner_prefix = 8;
inline bool PartitioningConfig::has_partitioner_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PartitioningConfig::clear_partitioner_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partitioner_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitioningConfig::partitioner_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioner_prefix)
  return _internal_partitioner_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitioningConfig::set_partitioner_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.partitioner_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioner_prefix)
}
inline std::string* PartitioningConfig::mutable_partitioner_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partitioner_prefix();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.partitioner_prefix)
  return _s;
}
inline const std::string& PartitioningConfig::_internal_partitioner_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partitioner_prefix_.Get();
}
inline void PartitioningConfig::_internal_set_partitioner_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.partitioner_prefix_.Set(value, GetArena());
}
inline std::string* PartitioningConfig::_internal_mutable_partitioner_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.partitioner_prefix_.Mutable( GetArena());
}
inline std::string* PartitioningConfig::release_partitioner_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.partitioner_prefix)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.partitioner_prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.partitioner_prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PartitioningConfig::set_allocated_partitioner_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.partitioner_prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partitioner_prefix_.IsDefault()) {
          _impl_.partitioner_prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.partitioner_prefix)
}

// optional int32 max_num_levels = 2 [default = 1];
inline bool PartitioningConfig::has_max_num_levels() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_max_num_levels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_num_levels_ = 1;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::int32_t PartitioningConfig::max_num_levels() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_num_levels)
  return _internal_max_num_levels();
}
inline void PartitioningConfig::set_max_num_levels(::int32_t value) {
  _internal_set_max_num_levels(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_num_levels)
}
inline ::int32_t PartitioningConfig::_internal_max_num_levels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_num_levels_;
}
inline void PartitioningConfig::_internal_set_max_num_levels(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.max_num_levels_ = value;
}

// optional int32 max_leaf_size = 11 [default = 1];
inline bool PartitioningConfig::has_max_leaf_size() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_max_leaf_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_leaf_size_ = 1;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline ::int32_t PartitioningConfig::max_leaf_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_leaf_size)
  return _internal_max_leaf_size();
}
inline void PartitioningConfig::set_max_leaf_size(::int32_t value) {
  _internal_set_max_leaf_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_leaf_size)
}
inline ::int32_t PartitioningConfig::_internal_max_leaf_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_leaf_size_;
}
inline void PartitioningConfig::_internal_set_max_leaf_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.max_leaf_size_ = value;
}

// optional int32 clustering_seed = 27 [default = 0];
inline bool PartitioningConfig::has_clustering_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_clustering_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clustering_seed_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t PartitioningConfig::clustering_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.clustering_seed)
  return _internal_clustering_seed();
}
inline void PartitioningConfig::set_clustering_seed(::int32_t value) {
  _internal_set_clustering_seed(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.clustering_seed)
}
inline ::int32_t PartitioningConfig::_internal_clustering_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clustering_seed_;
}
inline void PartitioningConfig::_internal_set_clustering_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.clustering_seed_ = value;
}

// optional .research_scann.ProjectionConfig projection = 12;
inline bool PartitioningConfig::has_projection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.projection_ != nullptr);
  return value;
}
inline const ::research_scann::ProjectionConfig& PartitioningConfig::_internal_projection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::ProjectionConfig* p = _impl_.projection_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::ProjectionConfig&>(::research_scann::_ProjectionConfig_default_instance_);
}
inline const ::research_scann::ProjectionConfig& PartitioningConfig::projection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.projection)
  return _internal_projection();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_projection(::research_scann::ProjectionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }
  _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.projection)
}
inline ::research_scann::ProjectionConfig* PartitioningConfig::release_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::ProjectionConfig* released = _impl_.projection_;
  _impl_.projection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::ProjectionConfig* PartitioningConfig::unsafe_arena_release_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.projection)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::research_scann::ProjectionConfig* temp = _impl_.projection_;
  _impl_.projection_ = nullptr;
  return temp;
}
inline ::research_scann::ProjectionConfig* PartitioningConfig::_internal_mutable_projection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.projection_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ProjectionConfig>(GetArena());
    _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(p);
  }
  return _impl_.projection_;
}
inline ::research_scann::ProjectionConfig* PartitioningConfig::mutable_projection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::ProjectionConfig* _msg = _internal_mutable_projection();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.projection)
  return _msg;
}
inline void PartitioningConfig::set_allocated_projection(::research_scann::ProjectionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.projection_ = reinterpret_cast<::research_scann::ProjectionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.projection)
}

// optional int32 num_children = 3 [default = 2];
inline bool PartitioningConfig::has_num_children() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_num_children() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_children_ = 2;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::int32_t PartitioningConfig::num_children() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_children)
  return _internal_num_children();
}
inline void PartitioningConfig::set_num_children(::int32_t value) {
  _internal_set_num_children(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_children)
}
inline ::int32_t PartitioningConfig::_internal_num_children() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_children_;
}
inline void PartitioningConfig::_internal_set_num_children(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.num_children_ = value;
}

// repeated int32 num_children_per_level = 60;
inline int PartitioningConfig::_internal_num_children_per_level_size() const {
  return _internal_num_children_per_level().size();
}
inline int PartitioningConfig::num_children_per_level_size() const {
  return _internal_num_children_per_level_size();
}
inline void PartitioningConfig::clear_num_children_per_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_children_per_level_.Clear();
}
inline ::int32_t PartitioningConfig::num_children_per_level(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_children_per_level)
  return _internal_num_children_per_level().Get(index);
}
inline void PartitioningConfig::set_num_children_per_level(int index, ::int32_t value) {
  _internal_mutable_num_children_per_level()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_children_per_level)
}
inline void PartitioningConfig::add_num_children_per_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_num_children_per_level()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.PartitioningConfig.num_children_per_level)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& PartitioningConfig::num_children_per_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.PartitioningConfig.num_children_per_level)
  return _internal_num_children_per_level();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PartitioningConfig::mutable_num_children_per_level()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.PartitioningConfig.num_children_per_level)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_num_children_per_level();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& PartitioningConfig::_internal_num_children_per_level()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_children_per_level_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PartitioningConfig::_internal_mutable_num_children_per_level() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.num_children_per_level_;
}

// optional .research_scann.DistanceMeasureConfig partitioning_distance = 10;
inline bool PartitioningConfig::has_partitioning_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.partitioning_distance_ != nullptr);
  return value;
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::_internal_partitioning_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::DistanceMeasureConfig* p = _impl_.partitioning_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::DistanceMeasureConfig&>(::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::partitioning_distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_distance)
  return _internal_partitioning_distance();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_partitioning_distance(::research_scann::DistanceMeasureConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.partitioning_distance_);
  }
  _impl_.partitioning_distance_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.partitioning_distance)
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::release_partitioning_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::DistanceMeasureConfig* released = _impl_.partitioning_distance_;
  _impl_.partitioning_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::unsafe_arena_release_partitioning_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.partitioning_distance)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::research_scann::DistanceMeasureConfig* temp = _impl_.partitioning_distance_;
  _impl_.partitioning_distance_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::_internal_mutable_partitioning_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.partitioning_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArena());
    _impl_.partitioning_distance_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(p);
  }
  return _impl_.partitioning_distance_;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::mutable_partitioning_distance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::DistanceMeasureConfig* _msg = _internal_mutable_partitioning_distance();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.partitioning_distance)
  return _msg;
}
inline void PartitioningConfig::set_allocated_partitioning_distance(::research_scann::DistanceMeasureConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.partitioning_distance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.partitioning_distance_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.partitioning_distance)
}

// optional .research_scann.DistanceMeasureConfig database_tokenization_distance_override = 24;
inline bool PartitioningConfig::has_database_tokenization_distance_override() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_tokenization_distance_override_ != nullptr);
  return value;
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::_internal_database_tokenization_distance_override() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::DistanceMeasureConfig* p = _impl_.database_tokenization_distance_override_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::DistanceMeasureConfig&>(::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::database_tokenization_distance_override() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.database_tokenization_distance_override)
  return _internal_database_tokenization_distance_override();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_database_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.database_tokenization_distance_override_);
  }
  _impl_.database_tokenization_distance_override_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.database_tokenization_distance_override)
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::release_database_tokenization_distance_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::research_scann::DistanceMeasureConfig* released = _impl_.database_tokenization_distance_override_;
  _impl_.database_tokenization_distance_override_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::unsafe_arena_release_database_tokenization_distance_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.database_tokenization_distance_override)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::research_scann::DistanceMeasureConfig* temp = _impl_.database_tokenization_distance_override_;
  _impl_.database_tokenization_distance_override_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::_internal_mutable_database_tokenization_distance_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.database_tokenization_distance_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArena());
    _impl_.database_tokenization_distance_override_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(p);
  }
  return _impl_.database_tokenization_distance_override_;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::mutable_database_tokenization_distance_override() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::DistanceMeasureConfig* _msg = _internal_mutable_database_tokenization_distance_override();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.database_tokenization_distance_override)
  return _msg;
}
inline void PartitioningConfig::set_allocated_database_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.database_tokenization_distance_override_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.database_tokenization_distance_override_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.database_tokenization_distance_override)
}

// optional .research_scann.DistanceMeasureConfig query_tokenization_distance_override = 25;
inline bool PartitioningConfig::has_query_tokenization_distance_override() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_tokenization_distance_override_ != nullptr);
  return value;
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::_internal_query_tokenization_distance_override() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::DistanceMeasureConfig* p = _impl_.query_tokenization_distance_override_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::DistanceMeasureConfig&>(::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::query_tokenization_distance_override() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.query_tokenization_distance_override)
  return _internal_query_tokenization_distance_override();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_query_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_tokenization_distance_override_);
  }
  _impl_.query_tokenization_distance_override_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.query_tokenization_distance_override)
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::release_query_tokenization_distance_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::research_scann::DistanceMeasureConfig* released = _impl_.query_tokenization_distance_override_;
  _impl_.query_tokenization_distance_override_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::unsafe_arena_release_query_tokenization_distance_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.query_tokenization_distance_override)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::research_scann::DistanceMeasureConfig* temp = _impl_.query_tokenization_distance_override_;
  _impl_.query_tokenization_distance_override_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::_internal_mutable_query_tokenization_distance_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.query_tokenization_distance_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArena());
    _impl_.query_tokenization_distance_override_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(p);
  }
  return _impl_.query_tokenization_distance_override_;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::mutable_query_tokenization_distance_override() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::DistanceMeasureConfig* _msg = _internal_mutable_query_tokenization_distance_override();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.query_tokenization_distance_override)
  return _msg;
}
inline void PartitioningConfig::set_allocated_query_tokenization_distance_override(::research_scann::DistanceMeasureConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_tokenization_distance_override_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.query_tokenization_distance_override_ = reinterpret_cast<::research_scann::DistanceMeasureConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.query_tokenization_distance_override)
}

// optional .research_scann.PartitioningConfig.TokenizationType query_tokenization_type = 28 [default = FLOAT];
inline bool PartitioningConfig::has_query_tokenization_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline void PartitioningConfig::clear_query_tokenization_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_tokenization_type_ = 1;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline ::research_scann::PartitioningConfig_TokenizationType PartitioningConfig::query_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.query_tokenization_type)
  return _internal_query_tokenization_type();
}
inline void PartitioningConfig::set_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  _internal_set_query_tokenization_type(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.query_tokenization_type)
}
inline ::research_scann::PartitioningConfig_TokenizationType PartitioningConfig::_internal_query_tokenization_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_TokenizationType>(_impl_.query_tokenization_type_);
}
inline void PartitioningConfig::_internal_set_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.query_tokenization_type_ = value;
}

// optional .research_scann.PartitioningConfig.TokenizationType database_tokenization_type = 29 [default = FLOAT];
inline bool PartitioningConfig::has_database_tokenization_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline void PartitioningConfig::clear_database_tokenization_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_tokenization_type_ = 1;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline ::research_scann::PartitioningConfig_TokenizationType PartitioningConfig::database_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.database_tokenization_type)
  return _internal_database_tokenization_type();
}
inline void PartitioningConfig::set_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  _internal_set_database_tokenization_type(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.database_tokenization_type)
}
inline ::research_scann::PartitioningConfig_TokenizationType PartitioningConfig::_internal_database_tokenization_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_TokenizationType>(_impl_.database_tokenization_type_);
}
inline void PartitioningConfig::_internal_set_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.database_tokenization_type_ = value;
}

// optional int32 max_clustering_iterations = 6 [default = 10];
inline bool PartitioningConfig::has_max_clustering_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_max_clustering_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_clustering_iterations_ = 10;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::int32_t PartitioningConfig::max_clustering_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_clustering_iterations)
  return _internal_max_clustering_iterations();
}
inline void PartitioningConfig::set_max_clustering_iterations(::int32_t value) {
  _internal_set_max_clustering_iterations(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_clustering_iterations)
}
inline ::int32_t PartitioningConfig::_internal_max_clustering_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_clustering_iterations_;
}
inline void PartitioningConfig::_internal_set_max_clustering_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.max_clustering_iterations_ = value;
}

// optional int32 num_mini_batches = 38 [default = 1];
inline bool PartitioningConfig::has_num_mini_batches() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline void PartitioningConfig::clear_num_mini_batches() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_mini_batches_ = 1;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline ::int32_t PartitioningConfig::num_mini_batches() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_mini_batches)
  return _internal_num_mini_batches();
}
inline void PartitioningConfig::set_num_mini_batches(::int32_t value) {
  _internal_set_num_mini_batches(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_mini_batches)
}
inline ::int32_t PartitioningConfig::_internal_num_mini_batches() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_mini_batches_;
}
inline void PartitioningConfig::_internal_set_num_mini_batches(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.num_mini_batches_ = value;
}

// optional float clustering_convergence_tolerance = 7 [default = 1e-05];
inline bool PartitioningConfig::has_clustering_convergence_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_clustering_convergence_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clustering_convergence_tolerance_ = 1e-05f;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline float PartitioningConfig::clustering_convergence_tolerance() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.clustering_convergence_tolerance)
  return _internal_clustering_convergence_tolerance();
}
inline void PartitioningConfig::set_clustering_convergence_tolerance(float value) {
  _internal_set_clustering_convergence_tolerance(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.clustering_convergence_tolerance)
}
inline float PartitioningConfig::_internal_clustering_convergence_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clustering_convergence_tolerance_;
}
inline void PartitioningConfig::_internal_set_clustering_convergence_tolerance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.clustering_convergence_tolerance_ = value;
}

// optional float min_cluster_size = 9 [default = 1];
inline bool PartitioningConfig::has_min_cluster_size() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_min_cluster_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_cluster_size_ = 1;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline float PartitioningConfig::min_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.min_cluster_size)
  return _internal_min_cluster_size();
}
inline void PartitioningConfig::set_min_cluster_size(float value) {
  _internal_set_min_cluster_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.min_cluster_size)
}
inline float PartitioningConfig::_internal_min_cluster_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_cluster_size_;
}
inline void PartitioningConfig::_internal_set_min_cluster_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.min_cluster_size_ = value;
}

// optional int32 max_cluster_size = 40;
inline bool PartitioningConfig::has_max_cluster_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_max_cluster_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_cluster_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::int32_t PartitioningConfig::max_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_cluster_size)
  return _internal_max_cluster_size();
}
inline void PartitioningConfig::set_max_cluster_size(::int32_t value) {
  _internal_set_max_cluster_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_cluster_size)
}
inline ::int32_t PartitioningConfig::_internal_max_cluster_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_cluster_size_;
}
inline void PartitioningConfig::_internal_set_max_cluster_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.max_cluster_size_ = value;
}

// optional double perturbation = 41;
inline bool PartitioningConfig::has_perturbation() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_perturbation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perturbation_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline double PartitioningConfig::perturbation() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.perturbation)
  return _internal_perturbation();
}
inline void PartitioningConfig::set_perturbation(double value) {
  _internal_set_perturbation(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.perturbation)
}
inline double PartitioningConfig::_internal_perturbation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perturbation_;
}
inline void PartitioningConfig::_internal_set_perturbation(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.perturbation_ = value;
}

// optional .research_scann.PartitioningConfig.PartitioningType partitioning_type = 23 [default = GENERIC];
inline bool PartitioningConfig::has_partitioning_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_partitioning_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partitioning_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::research_scann::PartitioningConfig_PartitioningType PartitioningConfig::partitioning_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_type)
  return _internal_partitioning_type();
}
inline void PartitioningConfig::set_partitioning_type(::research_scann::PartitioningConfig_PartitioningType value) {
  _internal_set_partitioning_type(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioning_type)
}
inline ::research_scann::PartitioningConfig_PartitioningType PartitioningConfig::_internal_partitioning_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_PartitioningType>(_impl_.partitioning_type_);
}
inline void PartitioningConfig::_internal_set_partitioning_type(::research_scann::PartitioningConfig_PartitioningType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_PartitioningType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.partitioning_type_ = value;
}

// optional .research_scann.PartitioningConfig.BalancingType balancing_type = 35 [default = DEFAULT_UNBALANCED];
inline bool PartitioningConfig::has_balancing_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_balancing_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balancing_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::research_scann::PartitioningConfig_BalancingType PartitioningConfig::balancing_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.balancing_type)
  return _internal_balancing_type();
}
inline void PartitioningConfig::set_balancing_type(::research_scann::PartitioningConfig_BalancingType value) {
  _internal_set_balancing_type(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.balancing_type)
}
inline ::research_scann::PartitioningConfig_BalancingType PartitioningConfig::_internal_balancing_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_BalancingType>(_impl_.balancing_type_);
}
inline void PartitioningConfig::_internal_set_balancing_type(::research_scann::PartitioningConfig_BalancingType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_BalancingType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.balancing_type_ = value;
}

// optional .research_scann.PartitioningConfig.SingleMachineCenterInitializationType single_machine_center_initialization = 49 [default = DEFAULT_KMEANS_PLUS_PLUS];
inline bool PartitioningConfig::has_single_machine_center_initialization() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_single_machine_center_initialization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.single_machine_center_initialization_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig::single_machine_center_initialization() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.single_machine_center_initialization)
  return _internal_single_machine_center_initialization();
}
inline void PartitioningConfig::set_single_machine_center_initialization(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType value) {
  _internal_set_single_machine_center_initialization(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.single_machine_center_initialization)
}
inline ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig::_internal_single_machine_center_initialization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_SingleMachineCenterInitializationType>(_impl_.single_machine_center_initialization_);
}
inline void PartitioningConfig::_internal_set_single_machine_center_initialization(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.single_machine_center_initialization_ = value;
}

// optional .research_scann.DatabaseSpillingConfig database_spilling = 20;
inline bool PartitioningConfig::has_database_spilling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_spilling_ != nullptr);
  return value;
}
inline void PartitioningConfig::clear_database_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.database_spilling_ != nullptr) _impl_.database_spilling_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::research_scann::DatabaseSpillingConfig& PartitioningConfig::_internal_database_spilling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::DatabaseSpillingConfig* p = _impl_.database_spilling_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::DatabaseSpillingConfig&>(::research_scann::_DatabaseSpillingConfig_default_instance_);
}
inline const ::research_scann::DatabaseSpillingConfig& PartitioningConfig::database_spilling() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.database_spilling)
  return _internal_database_spilling();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_database_spilling(::research_scann::DatabaseSpillingConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.database_spilling_);
  }
  _impl_.database_spilling_ = reinterpret_cast<::research_scann::DatabaseSpillingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.database_spilling)
}
inline ::research_scann::DatabaseSpillingConfig* PartitioningConfig::release_database_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::research_scann::DatabaseSpillingConfig* released = _impl_.database_spilling_;
  _impl_.database_spilling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::DatabaseSpillingConfig* PartitioningConfig::unsafe_arena_release_database_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.database_spilling)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::research_scann::DatabaseSpillingConfig* temp = _impl_.database_spilling_;
  _impl_.database_spilling_ = nullptr;
  return temp;
}
inline ::research_scann::DatabaseSpillingConfig* PartitioningConfig::_internal_mutable_database_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.database_spilling_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DatabaseSpillingConfig>(GetArena());
    _impl_.database_spilling_ = reinterpret_cast<::research_scann::DatabaseSpillingConfig*>(p);
  }
  return _impl_.database_spilling_;
}
inline ::research_scann::DatabaseSpillingConfig* PartitioningConfig::mutable_database_spilling() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::DatabaseSpillingConfig* _msg = _internal_mutable_database_spilling();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.database_spilling)
  return _msg;
}
inline void PartitioningConfig::set_allocated_database_spilling(::research_scann::DatabaseSpillingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::DatabaseSpillingConfig*>(_impl_.database_spilling_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::DatabaseSpillingConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.database_spilling_ = reinterpret_cast<::research_scann::DatabaseSpillingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.database_spilling)
}

// optional .research_scann.QuerySpillingConfig query_spilling = 21;
inline bool PartitioningConfig::has_query_spilling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_spilling_ != nullptr);
  return value;
}
inline void PartitioningConfig::clear_query_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.query_spilling_ != nullptr) _impl_.query_spilling_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::research_scann::QuerySpillingConfig& PartitioningConfig::_internal_query_spilling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::QuerySpillingConfig* p = _impl_.query_spilling_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::QuerySpillingConfig&>(::research_scann::_QuerySpillingConfig_default_instance_);
}
inline const ::research_scann::QuerySpillingConfig& PartitioningConfig::query_spilling() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.query_spilling)
  return _internal_query_spilling();
}
inline void PartitioningConfig::unsafe_arena_set_allocated_query_spilling(::research_scann::QuerySpillingConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_spilling_);
  }
  _impl_.query_spilling_ = reinterpret_cast<::research_scann::QuerySpillingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.PartitioningConfig.query_spilling)
}
inline ::research_scann::QuerySpillingConfig* PartitioningConfig::release_query_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::research_scann::QuerySpillingConfig* released = _impl_.query_spilling_;
  _impl_.query_spilling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::QuerySpillingConfig* PartitioningConfig::unsafe_arena_release_query_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.query_spilling)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::research_scann::QuerySpillingConfig* temp = _impl_.query_spilling_;
  _impl_.query_spilling_ = nullptr;
  return temp;
}
inline ::research_scann::QuerySpillingConfig* PartitioningConfig::_internal_mutable_query_spilling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.query_spilling_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::QuerySpillingConfig>(GetArena());
    _impl_.query_spilling_ = reinterpret_cast<::research_scann::QuerySpillingConfig*>(p);
  }
  return _impl_.query_spilling_;
}
inline ::research_scann::QuerySpillingConfig* PartitioningConfig::mutable_query_spilling() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::QuerySpillingConfig* _msg = _internal_mutable_query_spilling();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.query_spilling)
  return _msg;
}
inline void PartitioningConfig::set_allocated_query_spilling(::research_scann::QuerySpillingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::QuerySpillingConfig*>(_impl_.query_spilling_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::QuerySpillingConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.query_spilling_ = reinterpret_cast<::research_scann::QuerySpillingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.query_spilling)
}

// optional string resharded_prefix = 14;
inline bool PartitioningConfig::has_resharded_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PartitioningConfig::clear_resharded_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resharded_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PartitioningConfig::resharded_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.resharded_prefix)
  return _internal_resharded_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitioningConfig::set_resharded_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resharded_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.resharded_prefix)
}
inline std::string* PartitioningConfig::mutable_resharded_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resharded_prefix();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.resharded_prefix)
  return _s;
}
inline const std::string& PartitioningConfig::_internal_resharded_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resharded_prefix_.Get();
}
inline void PartitioningConfig::_internal_set_resharded_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resharded_prefix_.Set(value, GetArena());
}
inline std::string* PartitioningConfig::_internal_mutable_resharded_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.resharded_prefix_.Mutable( GetArena());
}
inline std::string* PartitioningConfig::release_resharded_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.resharded_prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.resharded_prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resharded_prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PartitioningConfig::set_allocated_resharded_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.resharded_prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resharded_prefix_.IsDefault()) {
          _impl_.resharded_prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.resharded_prefix)
}

// optional int32 num_partitioning_epochs = 1 [default = 1];
inline bool PartitioningConfig::has_num_partitioning_epochs() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_num_partitioning_epochs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_partitioning_epochs_ = 1;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::int32_t PartitioningConfig::num_partitioning_epochs() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_partitioning_epochs)
  return _internal_num_partitioning_epochs();
}
inline void PartitioningConfig::set_num_partitioning_epochs(::int32_t value) {
  _internal_set_num_partitioning_epochs(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_partitioning_epochs)
}
inline ::int32_t PartitioningConfig::_internal_num_partitioning_epochs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_partitioning_epochs_;
}
inline void PartitioningConfig::_internal_set_num_partitioning_epochs(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.num_partitioning_epochs_ = value;
}

// optional string mr_jobname_prefix = 13 [default = "PartitionReshard"];
inline bool PartitioningConfig::has_mr_jobname_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PartitioningConfig::clear_mr_jobname_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mr_jobname_prefix_.ClearToDefault(::research_scann::PartitioningConfig::Impl_::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_, GetArena());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartitioningConfig::mr_jobname_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.mr_jobname_prefix)
  if (_impl_.mr_jobname_prefix_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get();
  }
  return _internal_mr_jobname_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitioningConfig::set_mr_jobname_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mr_jobname_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.mr_jobname_prefix)
}
inline std::string* PartitioningConfig::mutable_mr_jobname_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mr_jobname_prefix();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.mr_jobname_prefix)
  return _s;
}
inline const std::string& PartitioningConfig::_internal_mr_jobname_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mr_jobname_prefix_.Get();
}
inline void PartitioningConfig::_internal_set_mr_jobname_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mr_jobname_prefix_.Set(value, GetArena());
}
inline std::string* PartitioningConfig::_internal_mutable_mr_jobname_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mr_jobname_prefix_.Mutable(::research_scann::PartitioningConfig::Impl_::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_, GetArena());
}
inline std::string* PartitioningConfig::release_mr_jobname_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.mr_jobname_prefix)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  return _impl_.mr_jobname_prefix_.Release();
}
inline void PartitioningConfig::set_allocated_mr_jobname_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mr_jobname_prefix_.SetAllocated(value, GetArena());
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.mr_jobname_prefix)
}

// optional string cell = 15;
inline bool PartitioningConfig::has_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PartitioningConfig::clear_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cell_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PartitioningConfig::cell() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.cell)
  return _internal_cell();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitioningConfig::set_cell(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cell_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.cell)
}
inline std::string* PartitioningConfig::mutable_cell() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.cell)
  return _s;
}
inline const std::string& PartitioningConfig::_internal_cell() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cell_.Get();
}
inline void PartitioningConfig::_internal_set_cell(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cell_.Set(value, GetArena());
}
inline std::string* PartitioningConfig::_internal_mutable_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.cell_.Mutable( GetArena());
}
inline std::string* PartitioningConfig::release_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.cell)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.cell_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cell_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PartitioningConfig::set_allocated_cell(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.cell_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cell_.IsDefault()) {
          _impl_.cell_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.cell)
}

// optional int32 num_cpus = 19 [default = 1];
inline bool PartitioningConfig::has_num_cpus() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline void PartitioningConfig::clear_num_cpus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_cpus_ = 1;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline ::int32_t PartitioningConfig::num_cpus() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_cpus)
  return _internal_num_cpus();
}
inline void PartitioningConfig::set_num_cpus(::int32_t value) {
  _internal_set_num_cpus(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_cpus)
}
inline ::int32_t PartitioningConfig::_internal_num_cpus() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_cpus_;
}
inline void PartitioningConfig::_internal_set_num_cpus(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.num_cpus_ = value;
}

// optional int32 num_mapper_machines = 30 [default = -1];
inline bool PartitioningConfig::has_num_mapper_machines() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline void PartitioningConfig::clear_num_mapper_machines() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_mapper_machines_ = -1;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline ::int32_t PartitioningConfig::num_mapper_machines() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_mapper_machines)
  return _internal_num_mapper_machines();
}
inline void PartitioningConfig::set_num_mapper_machines(::int32_t value) {
  _internal_set_num_mapper_machines(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_mapper_machines)
}
inline ::int32_t PartitioningConfig::_internal_num_mapper_machines() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_mapper_machines_;
}
inline void PartitioningConfig::_internal_set_num_mapper_machines(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.num_mapper_machines_ = value;
}

// optional int32 ram_gb = 16 [default = 4];
inline bool PartitioningConfig::has_ram_gb() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_ram_gb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ram_gb_ = 4;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::int32_t PartitioningConfig::ram_gb() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.ram_gb)
  return _internal_ram_gb();
}
inline void PartitioningConfig::set_ram_gb(::int32_t value) {
  _internal_set_ram_gb(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.ram_gb)
}
inline ::int32_t PartitioningConfig::_internal_ram_gb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ram_gb_;
}
inline void PartitioningConfig::_internal_set_ram_gb(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.ram_gb_ = value;
}

// optional int32 disk_gb = 17 [default = 1];
inline bool PartitioningConfig::has_disk_gb() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline void PartitioningConfig::clear_disk_gb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disk_gb_ = 1;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline ::int32_t PartitioningConfig::disk_gb() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.disk_gb)
  return _internal_disk_gb();
}
inline void PartitioningConfig::set_disk_gb(::int32_t value) {
  _internal_set_disk_gb(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.disk_gb)
}
inline ::int32_t PartitioningConfig::_internal_disk_gb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disk_gb_;
}
inline void PartitioningConfig::_internal_set_disk_gb(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.disk_gb_ = value;
}

// optional .research_scann.PartitioningConfig.PartitionerTrainerType trainer_type = 36 [default = DEFAULT_SAMPLING_TRAINER];
inline bool PartitioningConfig::has_trainer_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_trainer_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trainer_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::research_scann::PartitioningConfig_PartitionerTrainerType PartitioningConfig::trainer_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.trainer_type)
  return _internal_trainer_type();
}
inline void PartitioningConfig::set_trainer_type(::research_scann::PartitioningConfig_PartitionerTrainerType value) {
  _internal_set_trainer_type(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.trainer_type)
}
inline ::research_scann::PartitioningConfig_PartitionerTrainerType PartitioningConfig::_internal_trainer_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_PartitionerTrainerType>(_impl_.trainer_type_);
}
inline void PartitioningConfig::_internal_set_trainer_type(::research_scann::PartitioningConfig_PartitionerTrainerType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_PartitionerTrainerType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.trainer_type_ = value;
}

// optional string trainer_stats_prefix = 37;
inline bool PartitioningConfig::has_trainer_stats_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PartitioningConfig::clear_trainer_stats_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trainer_stats_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PartitioningConfig::trainer_stats_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.trainer_stats_prefix)
  return _internal_trainer_stats_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitioningConfig::set_trainer_stats_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.trainer_stats_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.trainer_stats_prefix)
}
inline std::string* PartitioningConfig::mutable_trainer_stats_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trainer_stats_prefix();
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.trainer_stats_prefix)
  return _s;
}
inline const std::string& PartitioningConfig::_internal_trainer_stats_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trainer_stats_prefix_.Get();
}
inline void PartitioningConfig::_internal_set_trainer_stats_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.trainer_stats_prefix_.Set(value, GetArena());
}
inline std::string* PartitioningConfig::_internal_mutable_trainer_stats_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.trainer_stats_prefix_.Mutable( GetArena());
}
inline std::string* PartitioningConfig::release_trainer_stats_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.trainer_stats_prefix)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.trainer_stats_prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trainer_stats_prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PartitioningConfig::set_allocated_trainer_stats_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.trainer_stats_prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trainer_stats_prefix_.IsDefault()) {
          _impl_.trainer_stats_prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.trainer_stats_prefix)
}

// optional int32 max_power_of_2_split = 39 [default = 2];
inline bool PartitioningConfig::has_max_power_of_2_split() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline void PartitioningConfig::clear_max_power_of_2_split() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_power_of_2_split_ = 2;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline ::int32_t PartitioningConfig::max_power_of_2_split() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_power_of_2_split)
  return _internal_max_power_of_2_split();
}
inline void PartitioningConfig::set_max_power_of_2_split(::int32_t value) {
  _internal_set_max_power_of_2_split(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_power_of_2_split)
}
inline ::int32_t PartitioningConfig::_internal_max_power_of_2_split() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_power_of_2_split_;
}
inline void PartitioningConfig::_internal_set_max_power_of_2_split(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.max_power_of_2_split_ = value;
}

// optional int32 num_top_tokens_for_pca = 42 [default = 20];
inline bool PartitioningConfig::has_num_top_tokens_for_pca() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline void PartitioningConfig::clear_num_top_tokens_for_pca() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_top_tokens_for_pca_ = 20;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline ::int32_t PartitioningConfig::num_top_tokens_for_pca() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_top_tokens_for_pca)
  return _internal_num_top_tokens_for_pca();
}
inline void PartitioningConfig::set_num_top_tokens_for_pca(::int32_t value) {
  _internal_set_num_top_tokens_for_pca(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_top_tokens_for_pca)
}
inline ::int32_t PartitioningConfig::_internal_num_top_tokens_for_pca() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_top_tokens_for_pca_;
}
inline void PartitioningConfig::_internal_set_num_top_tokens_for_pca(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.num_top_tokens_for_pca_ = value;
}

// optional float pca_splitting_similarity_threshold = 43 [default = 1e-05];
inline bool PartitioningConfig::has_pca_splitting_similarity_threshold() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline void PartitioningConfig::clear_pca_splitting_similarity_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pca_splitting_similarity_threshold_ = 1e-05f;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline float PartitioningConfig::pca_splitting_similarity_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.pca_splitting_similarity_threshold)
  return _internal_pca_splitting_similarity_threshold();
}
inline void PartitioningConfig::set_pca_splitting_similarity_threshold(float value) {
  _internal_set_pca_splitting_similarity_threshold(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.pca_splitting_similarity_threshold)
}
inline float PartitioningConfig::_internal_pca_splitting_similarity_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pca_splitting_similarity_threshold_;
}
inline void PartitioningConfig::_internal_set_pca_splitting_similarity_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.pca_splitting_similarity_threshold_ = value;
}

// optional int32 desired_average_cluster_size = 34 [default = 3000];
inline bool PartitioningConfig::has_desired_average_cluster_size() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline void PartitioningConfig::clear_desired_average_cluster_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desired_average_cluster_size_ = 3000;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline ::int32_t PartitioningConfig::desired_average_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.desired_average_cluster_size)
  return _internal_desired_average_cluster_size();
}
inline void PartitioningConfig::set_desired_average_cluster_size(::int32_t value) {
  _internal_set_desired_average_cluster_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.desired_average_cluster_size)
}
inline ::int32_t PartitioningConfig::_internal_desired_average_cluster_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desired_average_cluster_size_;
}
inline void PartitioningConfig::_internal_set_desired_average_cluster_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.desired_average_cluster_size_ = value;
}

// optional bool compute_residual_stdev = 47 [default = false];
inline bool PartitioningConfig::has_compute_residual_stdev() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_compute_residual_stdev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compute_residual_stdev_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool PartitioningConfig::compute_residual_stdev() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.compute_residual_stdev)
  return _internal_compute_residual_stdev();
}
inline void PartitioningConfig::set_compute_residual_stdev(bool value) {
  _internal_set_compute_residual_stdev(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.compute_residual_stdev)
}
inline bool PartitioningConfig::_internal_compute_residual_stdev() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compute_residual_stdev_;
}
inline void PartitioningConfig::_internal_set_compute_residual_stdev(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.compute_residual_stdev_ = value;
}

// optional double residual_stdev_min_value = 48 [default = 1e-05];
inline bool PartitioningConfig::has_residual_stdev_min_value() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_residual_stdev_min_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.residual_stdev_min_value_ = 1e-05;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline double PartitioningConfig::residual_stdev_min_value() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.residual_stdev_min_value)
  return _internal_residual_stdev_min_value();
}
inline void PartitioningConfig::set_residual_stdev_min_value(double value) {
  _internal_set_residual_stdev_min_value(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.residual_stdev_min_value)
}
inline double PartitioningConfig::_internal_residual_stdev_min_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.residual_stdev_min_value_;
}
inline void PartitioningConfig::_internal_set_residual_stdev_min_value(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.residual_stdev_min_value_ = value;
}

// optional float avq = 51 [default = nan];
inline bool PartitioningConfig::has_avq() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline void PartitioningConfig::clear_avq() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.avq_ = std::numeric_limits<float>::quiet_NaN();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline float PartitioningConfig::avq() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.avq)
  return _internal_avq();
}
inline void PartitioningConfig::set_avq(float value) {
  _internal_set_avq(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.avq)
}
inline float PartitioningConfig::_internal_avq() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.avq_;
}
inline void PartitioningConfig::_internal_set_avq(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.avq_ = value;
}

// optional bool use_float_centers_for_query_tokenization = 26 [default = false, deprecated = true];
inline bool PartitioningConfig::has_use_float_centers_for_query_tokenization() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_use_float_centers_for_query_tokenization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_float_centers_for_query_tokenization_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool PartitioningConfig::use_float_centers_for_query_tokenization() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.use_float_centers_for_query_tokenization)
  return _internal_use_float_centers_for_query_tokenization();
}
inline void PartitioningConfig::set_use_float_centers_for_query_tokenization(bool value) {
  _internal_set_use_float_centers_for_query_tokenization(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.use_float_centers_for_query_tokenization)
}
inline bool PartitioningConfig::_internal_use_float_centers_for_query_tokenization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_float_centers_for_query_tokenization_;
}
inline void PartitioningConfig::_internal_set_use_float_centers_for_query_tokenization(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.use_float_centers_for_query_tokenization_ = value;
}

// optional bool partitioning_on_the_fly = 22 [default = false, deprecated = true];
inline bool PartitioningConfig::has_partitioning_on_the_fly() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_partitioning_on_the_fly() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partitioning_on_the_fly_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool PartitioningConfig::partitioning_on_the_fly() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_on_the_fly)
  return _internal_partitioning_on_the_fly();
}
inline void PartitioningConfig::set_partitioning_on_the_fly(bool value) {
  _internal_set_partitioning_on_the_fly(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioning_on_the_fly)
}
inline bool PartitioningConfig::_internal_partitioning_on_the_fly() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partitioning_on_the_fly_;
}
inline void PartitioningConfig::_internal_set_partitioning_on_the_fly(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.partitioning_on_the_fly_ = value;
}

// optional bool use_flume_kmeans = 32 [default = false, deprecated = true];
inline bool PartitioningConfig::has_use_flume_kmeans() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void PartitioningConfig::clear_use_flume_kmeans() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_flume_kmeans_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool PartitioningConfig::use_flume_kmeans() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.use_flume_kmeans)
  return _internal_use_flume_kmeans();
}
inline void PartitioningConfig::set_use_flume_kmeans(bool value) {
  _internal_set_use_flume_kmeans(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.use_flume_kmeans)
}
inline bool PartitioningConfig::_internal_use_flume_kmeans() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_flume_kmeans_;
}
inline void PartitioningConfig::_internal_set_use_flume_kmeans(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.use_flume_kmeans_ = value;
}

// optional int32 max_sample_size = 33 [default = 2147483647, deprecated = true];
inline bool PartitioningConfig::has_max_sample_size() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline void PartitioningConfig::clear_max_sample_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_sample_size_ = 2147483647;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline ::int32_t PartitioningConfig::max_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_sample_size)
  return _internal_max_sample_size();
}
inline void PartitioningConfig::set_max_sample_size(::int32_t value) {
  _internal_set_max_sample_size(value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_sample_size)
}
inline ::int32_t PartitioningConfig::_internal_max_sample_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_sample_size_;
}
inline void PartitioningConfig::_internal_set_max_sample_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.max_sample_size_ = value;
}

inline bool PartitioningConfig::has_SamplingFractionOrExpectedSize() const {
  return SamplingFractionOrExpectedSize_case() != SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline void PartitioningConfig::clear_has_SamplingFractionOrExpectedSize() {
  _impl_._oneof_case_[0] = SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline PartitioningConfig::SamplingFractionOrExpectedSizeCase PartitioningConfig::SamplingFractionOrExpectedSize_case() const {
  return PartitioningConfig::SamplingFractionOrExpectedSizeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DatabaseSpillingConfig

// optional .research_scann.DatabaseSpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
inline bool DatabaseSpillingConfig::has_spilling_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DatabaseSpillingConfig::clear_spilling_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spilling_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::research_scann::DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig::spilling_type() const {
  // @@protoc_insertion_point(field_get:research_scann.DatabaseSpillingConfig.spilling_type)
  return _internal_spilling_type();
}
inline void DatabaseSpillingConfig::set_spilling_type(::research_scann::DatabaseSpillingConfig_SpillingType value) {
  _internal_set_spilling_type(value);
  // @@protoc_insertion_point(field_set:research_scann.DatabaseSpillingConfig.spilling_type)
}
inline ::research_scann::DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig::_internal_spilling_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::DatabaseSpillingConfig_SpillingType>(_impl_.spilling_type_);
}
inline void DatabaseSpillingConfig::_internal_set_spilling_type(::research_scann::DatabaseSpillingConfig_SpillingType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::DatabaseSpillingConfig_SpillingType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.spilling_type_ = value;
}

// optional float replication_factor = 2;
inline bool DatabaseSpillingConfig::has_replication_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DatabaseSpillingConfig::clear_replication_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replication_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float DatabaseSpillingConfig::replication_factor() const {
  // @@protoc_insertion_point(field_get:research_scann.DatabaseSpillingConfig.replication_factor)
  return _internal_replication_factor();
}
inline void DatabaseSpillingConfig::set_replication_factor(float value) {
  _internal_set_replication_factor(value);
  // @@protoc_insertion_point(field_set:research_scann.DatabaseSpillingConfig.replication_factor)
}
inline float DatabaseSpillingConfig::_internal_replication_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replication_factor_;
}
inline void DatabaseSpillingConfig::_internal_set_replication_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.replication_factor_ = value;
}

// optional uint32 max_spill_centers = 3 [default = 4294967295];
inline bool DatabaseSpillingConfig::has_max_spill_centers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DatabaseSpillingConfig::clear_max_spill_centers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_spill_centers_ = 4294967295u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t DatabaseSpillingConfig::max_spill_centers() const {
  // @@protoc_insertion_point(field_get:research_scann.DatabaseSpillingConfig.max_spill_centers)
  return _internal_max_spill_centers();
}
inline void DatabaseSpillingConfig::set_max_spill_centers(::uint32_t value) {
  _internal_set_max_spill_centers(value);
  // @@protoc_insertion_point(field_set:research_scann.DatabaseSpillingConfig.max_spill_centers)
}
inline ::uint32_t DatabaseSpillingConfig::_internal_max_spill_centers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_spill_centers_;
}
inline void DatabaseSpillingConfig::_internal_set_max_spill_centers(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_spill_centers_ = value;
}

// -------------------------------------------------------------------

// QuerySpillingConfig

// optional .research_scann.QuerySpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
inline bool QuerySpillingConfig::has_spilling_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QuerySpillingConfig::clear_spilling_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spilling_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::research_scann::QuerySpillingConfig_SpillingType QuerySpillingConfig::spilling_type() const {
  // @@protoc_insertion_point(field_get:research_scann.QuerySpillingConfig.spilling_type)
  return _internal_spilling_type();
}
inline void QuerySpillingConfig::set_spilling_type(::research_scann::QuerySpillingConfig_SpillingType value) {
  _internal_set_spilling_type(value);
  // @@protoc_insertion_point(field_set:research_scann.QuerySpillingConfig.spilling_type)
}
inline ::research_scann::QuerySpillingConfig_SpillingType QuerySpillingConfig::_internal_spilling_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::QuerySpillingConfig_SpillingType>(_impl_.spilling_type_);
}
inline void QuerySpillingConfig::_internal_set_spilling_type(::research_scann::QuerySpillingConfig_SpillingType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::QuerySpillingConfig_SpillingType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.spilling_type_ = value;
}

// optional float spilling_threshold = 2;
inline bool QuerySpillingConfig::has_spilling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QuerySpillingConfig::clear_spilling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spilling_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float QuerySpillingConfig::spilling_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.QuerySpillingConfig.spilling_threshold)
  return _internal_spilling_threshold();
}
inline void QuerySpillingConfig::set_spilling_threshold(float value) {
  _internal_set_spilling_threshold(value);
  // @@protoc_insertion_point(field_set:research_scann.QuerySpillingConfig.spilling_threshold)
}
inline float QuerySpillingConfig::_internal_spilling_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.spilling_threshold_;
}
inline void QuerySpillingConfig::_internal_set_spilling_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.spilling_threshold_ = value;
}

// optional uint32 max_spill_centers = 3 [default = 4294967295];
inline bool QuerySpillingConfig::has_max_spill_centers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QuerySpillingConfig::clear_max_spill_centers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_spill_centers_ = 4294967295u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t QuerySpillingConfig::max_spill_centers() const {
  // @@protoc_insertion_point(field_get:research_scann.QuerySpillingConfig.max_spill_centers)
  return _internal_max_spill_centers();
}
inline void QuerySpillingConfig::set_max_spill_centers(::uint32_t value) {
  _internal_set_max_spill_centers(value);
  // @@protoc_insertion_point(field_set:research_scann.QuerySpillingConfig.max_spill_centers)
}
inline ::uint32_t QuerySpillingConfig::_internal_max_spill_centers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_spill_centers_;
}
inline void QuerySpillingConfig::_internal_set_max_spill_centers(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_spill_centers_ = value;
}

// -------------------------------------------------------------------

// TreeXHybridPartitioningConfig

// optional uint32 top_partitioning_children = 1;
inline bool TreeXHybridPartitioningConfig::has_top_partitioning_children() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioning_children() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_partitioning_children_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t TreeXHybridPartitioningConfig::top_partitioning_children() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioning_children)
  return _internal_top_partitioning_children();
}
inline void TreeXHybridPartitioningConfig::set_top_partitioning_children(::uint32_t value) {
  _internal_set_top_partitioning_children(value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioning_children)
}
inline ::uint32_t TreeXHybridPartitioningConfig::_internal_top_partitioning_children() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_partitioning_children_;
}
inline void TreeXHybridPartitioningConfig::_internal_set_top_partitioning_children(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.top_partitioning_children_ = value;
}

// optional float top_partitioner_spilling_ratio = 2 [default = 0.05];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_spilling_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_spilling_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_partitioner_spilling_ratio_ = 0.05f;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float TreeXHybridPartitioningConfig::top_partitioner_spilling_ratio() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_spilling_ratio)
  return _internal_top_partitioner_spilling_ratio();
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_spilling_ratio(float value) {
  _internal_set_top_partitioner_spilling_ratio(value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_spilling_ratio)
}
inline float TreeXHybridPartitioningConfig::_internal_top_partitioner_spilling_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_partitioner_spilling_ratio_;
}
inline void TreeXHybridPartitioningConfig::_internal_set_top_partitioner_spilling_ratio(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.top_partitioner_spilling_ratio_ = value;
}

// optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_query_tokenization_type = 7 [default = FLOAT];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_query_tokenization_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_query_tokenization_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_partitioner_query_tokenization_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::top_partitioner_query_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_query_tokenization_type)
  return _internal_top_partitioner_query_tokenization_type();
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  _internal_set_top_partitioner_query_tokenization_type(value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_query_tokenization_type)
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::_internal_top_partitioner_query_tokenization_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_TokenizationType>(_impl_.top_partitioner_query_tokenization_type_);
}
inline void TreeXHybridPartitioningConfig::_internal_set_top_partitioner_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.top_partitioner_query_tokenization_type_ = value;
}

// optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_database_tokenization_type = 8 [default = FLOAT];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_database_tokenization_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_database_tokenization_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_partitioner_database_tokenization_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::top_partitioner_database_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_database_tokenization_type)
  return _internal_top_partitioner_database_tokenization_type();
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  _internal_set_top_partitioner_database_tokenization_type(value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_database_tokenization_type)
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::_internal_top_partitioner_database_tokenization_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_TokenizationType>(_impl_.top_partitioner_database_tokenization_type_);
}
inline void TreeXHybridPartitioningConfig::_internal_set_top_partitioner_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.top_partitioner_database_tokenization_type_ = value;
}

// optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_training_tokenization_type = 10 [default = FLOAT];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_training_tokenization_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_training_tokenization_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_partitioner_training_tokenization_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::top_partitioner_training_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_training_tokenization_type)
  return _internal_top_partitioner_training_tokenization_type();
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_training_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  _internal_set_top_partitioner_training_tokenization_type(value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_training_tokenization_type)
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::_internal_top_partitioner_training_tokenization_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::PartitioningConfig_TokenizationType>(_impl_.top_partitioner_training_tokenization_type_);
}
inline void TreeXHybridPartitioningConfig::_internal_set_top_partitioner_training_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.top_partitioner_training_tokenization_type_ = value;
}

// optional bool top_partitioner_use_flume_trainer = 9 [default = false];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_use_flume_trainer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_use_flume_trainer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_partitioner_use_flume_trainer_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool TreeXHybridPartitioningConfig::top_partitioner_use_flume_trainer() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_use_flume_trainer)
  return _internal_top_partitioner_use_flume_trainer();
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_use_flume_trainer(bool value) {
  _internal_set_top_partitioner_use_flume_trainer(value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_use_flume_trainer)
}
inline bool TreeXHybridPartitioningConfig::_internal_top_partitioner_use_flume_trainer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_partitioner_use_flume_trainer_;
}
inline void TreeXHybridPartitioningConfig::_internal_set_top_partitioner_use_flume_trainer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.top_partitioner_use_flume_trainer_ = value;
}

// optional string assets_dir = 3;
inline bool TreeXHybridPartitioningConfig::has_assets_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TreeXHybridPartitioningConfig::clear_assets_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assets_dir_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TreeXHybridPartitioningConfig::assets_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.assets_dir)
  return _internal_assets_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TreeXHybridPartitioningConfig::set_assets_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assets_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}
inline std::string* TreeXHybridPartitioningConfig::mutable_assets_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assets_dir();
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.assets_dir)
  return _s;
}
inline const std::string& TreeXHybridPartitioningConfig::_internal_assets_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assets_dir_.Get();
}
inline void TreeXHybridPartitioningConfig::_internal_set_assets_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assets_dir_.Set(value, GetArena());
}
inline std::string* TreeXHybridPartitioningConfig::_internal_mutable_assets_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.assets_dir_.Mutable( GetArena());
}
inline std::string* TreeXHybridPartitioningConfig::release_assets_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.assets_dir)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.assets_dir_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.assets_dir_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TreeXHybridPartitioningConfig::set_allocated_assets_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.assets_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.assets_dir_.IsDefault()) {
          _impl_.assets_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}

// optional .research_scann.ExactReordering query_tokenization_reordering = 6;
inline bool TreeXHybridPartitioningConfig::has_query_tokenization_reordering() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_tokenization_reordering_ != nullptr);
  return value;
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::_internal_query_tokenization_reordering() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::ExactReordering* p = _impl_.query_tokenization_reordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::ExactReordering&>(::research_scann::_ExactReordering_default_instance_);
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::query_tokenization_reordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
  return _internal_query_tokenization_reordering();
}
inline void TreeXHybridPartitioningConfig::unsafe_arena_set_allocated_query_tokenization_reordering(::research_scann::ExactReordering* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_tokenization_reordering_);
  }
  _impl_.query_tokenization_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::release_query_tokenization_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::research_scann::ExactReordering* released = _impl_.query_tokenization_reordering_;
  _impl_.query_tokenization_reordering_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::unsafe_arena_release_query_tokenization_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::research_scann::ExactReordering* temp = _impl_.query_tokenization_reordering_;
  _impl_.query_tokenization_reordering_ = nullptr;
  return temp;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::_internal_mutable_query_tokenization_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.query_tokenization_reordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ExactReordering>(GetArena());
    _impl_.query_tokenization_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(p);
  }
  return _impl_.query_tokenization_reordering_;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::mutable_query_tokenization_reordering() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::ExactReordering* _msg = _internal_mutable_query_tokenization_reordering();
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
  return _msg;
}
inline void TreeXHybridPartitioningConfig::set_allocated_query_tokenization_reordering(::research_scann::ExactReordering* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_tokenization_reordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.query_tokenization_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
}

// optional .research_scann.ExactReordering training_reordering = 4 [deprecated = true];
inline bool TreeXHybridPartitioningConfig::has_training_reordering() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.training_reordering_ != nullptr);
  return value;
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::_internal_training_reordering() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::ExactReordering* p = _impl_.training_reordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::ExactReordering&>(::research_scann::_ExactReordering_default_instance_);
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::training_reordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.training_reordering)
  return _internal_training_reordering();
}
inline void TreeXHybridPartitioningConfig::unsafe_arena_set_allocated_training_reordering(::research_scann::ExactReordering* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.training_reordering_);
  }
  _impl_.training_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.TreeXHybridPartitioningConfig.training_reordering)
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::release_training_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::research_scann::ExactReordering* released = _impl_.training_reordering_;
  _impl_.training_reordering_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::unsafe_arena_release_training_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.training_reordering)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::research_scann::ExactReordering* temp = _impl_.training_reordering_;
  _impl_.training_reordering_ = nullptr;
  return temp;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::_internal_mutable_training_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.training_reordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ExactReordering>(GetArena());
    _impl_.training_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(p);
  }
  return _impl_.training_reordering_;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::mutable_training_reordering() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::ExactReordering* _msg = _internal_mutable_training_reordering();
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.training_reordering)
  return _msg;
}
inline void TreeXHybridPartitioningConfig::set_allocated_training_reordering(::research_scann::ExactReordering* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.training_reordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.training_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.training_reordering)
}

// optional .research_scann.ExactReordering database_tokenization_reordering = 5 [deprecated = true];
inline bool TreeXHybridPartitioningConfig::has_database_tokenization_reordering() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_tokenization_reordering_ != nullptr);
  return value;
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::_internal_database_tokenization_reordering() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::ExactReordering* p = _impl_.database_tokenization_reordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::ExactReordering&>(::research_scann::_ExactReordering_default_instance_);
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::database_tokenization_reordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
  return _internal_database_tokenization_reordering();
}
inline void TreeXHybridPartitioningConfig::unsafe_arena_set_allocated_database_tokenization_reordering(::research_scann::ExactReordering* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.database_tokenization_reordering_);
  }
  _impl_.database_tokenization_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::release_database_tokenization_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::research_scann::ExactReordering* released = _impl_.database_tokenization_reordering_;
  _impl_.database_tokenization_reordering_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::unsafe_arena_release_database_tokenization_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::research_scann::ExactReordering* temp = _impl_.database_tokenization_reordering_;
  _impl_.database_tokenization_reordering_ = nullptr;
  return temp;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::_internal_mutable_database_tokenization_reordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.database_tokenization_reordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ExactReordering>(GetArena());
    _impl_.database_tokenization_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(p);
  }
  return _impl_.database_tokenization_reordering_;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::mutable_database_tokenization_reordering() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::ExactReordering* _msg = _internal_mutable_database_tokenization_reordering();
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
  return _msg;
}
inline void TreeXHybridPartitioningConfig::set_allocated_database_tokenization_reordering(::research_scann::ExactReordering* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.database_tokenization_reordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.database_tokenization_reordering_ = reinterpret_cast<::research_scann::ExactReordering*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
}

// -------------------------------------------------------------------

// TokenList

// optional uint64 id = 1;
inline bool TokenList::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TokenList::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t TokenList::id() const {
  // @@protoc_insertion_point(field_get:research_scann.TokenList.id)
  return _internal_id();
}
inline void TokenList::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:research_scann.TokenList.id)
}
inline ::uint64_t TokenList::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TokenList::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}

// repeated int64 datapoint_index = 2;
inline int TokenList::_internal_datapoint_index_size() const {
  return _internal_datapoint_index().size();
}
inline int TokenList::datapoint_index_size() const {
  return _internal_datapoint_index_size();
}
inline void TokenList::clear_datapoint_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datapoint_index_.Clear();
}
inline ::int64_t TokenList::datapoint_index(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.TokenList.datapoint_index)
  return _internal_datapoint_index().Get(index);
}
inline void TokenList::set_datapoint_index(int index, ::int64_t value) {
  _internal_mutable_datapoint_index()->Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.TokenList.datapoint_index)
}
inline void TokenList::add_datapoint_index(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_datapoint_index()->Add(value);
  // @@protoc_insertion_point(field_add:research_scann.TokenList.datapoint_index)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TokenList::datapoint_index() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.TokenList.datapoint_index)
  return _internal_datapoint_index();
}
inline ::google::protobuf::RepeatedField<::int64_t>* TokenList::mutable_datapoint_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.TokenList.datapoint_index)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_datapoint_index();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TokenList::_internal_datapoint_index()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datapoint_index_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* TokenList::_internal_mutable_datapoint_index() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.datapoint_index_;
}

// -------------------------------------------------------------------

// HierarchicalPartitionerConfig

// optional .research_scann.InputOutputConfig input_output = 1;
inline bool HierarchicalPartitionerConfig::has_input_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_output_ != nullptr);
  return value;
}
inline const ::research_scann::InputOutputConfig& HierarchicalPartitionerConfig::_internal_input_output() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::InputOutputConfig* p = _impl_.input_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::InputOutputConfig&>(::research_scann::_InputOutputConfig_default_instance_);
}
inline const ::research_scann::InputOutputConfig& HierarchicalPartitionerConfig::input_output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HierarchicalPartitionerConfig.input_output)
  return _internal_input_output();
}
inline void HierarchicalPartitionerConfig::unsafe_arena_set_allocated_input_output(::research_scann::InputOutputConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_output_);
  }
  _impl_.input_output_ = reinterpret_cast<::research_scann::InputOutputConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.HierarchicalPartitionerConfig.input_output)
}
inline ::research_scann::InputOutputConfig* HierarchicalPartitionerConfig::release_input_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::research_scann::InputOutputConfig* released = _impl_.input_output_;
  _impl_.input_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::InputOutputConfig* HierarchicalPartitionerConfig::unsafe_arena_release_input_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.HierarchicalPartitionerConfig.input_output)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::research_scann::InputOutputConfig* temp = _impl_.input_output_;
  _impl_.input_output_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig* HierarchicalPartitionerConfig::_internal_mutable_input_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.input_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig>(GetArena());
    _impl_.input_output_ = reinterpret_cast<::research_scann::InputOutputConfig*>(p);
  }
  return _impl_.input_output_;
}
inline ::research_scann::InputOutputConfig* HierarchicalPartitionerConfig::mutable_input_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::InputOutputConfig* _msg = _internal_mutable_input_output();
  // @@protoc_insertion_point(field_mutable:research_scann.HierarchicalPartitionerConfig.input_output)
  return _msg;
}
inline void HierarchicalPartitionerConfig::set_allocated_input_output(::research_scann::InputOutputConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_output_ = reinterpret_cast<::research_scann::InputOutputConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HierarchicalPartitionerConfig.input_output)
}

// repeated .research_scann.PartitioningConfig partitioning = 2;
inline int HierarchicalPartitionerConfig::_internal_partitioning_size() const {
  return _internal_partitioning().size();
}
inline int HierarchicalPartitionerConfig::partitioning_size() const {
  return _internal_partitioning_size();
}
inline void HierarchicalPartitionerConfig::clear_partitioning() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partitioning_.Clear();
}
inline ::research_scann::PartitioningConfig* HierarchicalPartitionerConfig::mutable_partitioning(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:research_scann.HierarchicalPartitionerConfig.partitioning)
  return _internal_mutable_partitioning()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::research_scann::PartitioningConfig>* HierarchicalPartitionerConfig::mutable_partitioning()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:research_scann.HierarchicalPartitionerConfig.partitioning)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_partitioning();
}
inline const ::research_scann::PartitioningConfig& HierarchicalPartitionerConfig::partitioning(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.HierarchicalPartitionerConfig.partitioning)
  return _internal_partitioning().Get(index);
}
inline ::research_scann::PartitioningConfig* HierarchicalPartitionerConfig::add_partitioning() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::research_scann::PartitioningConfig* _add = _internal_mutable_partitioning()->Add();
  // @@protoc_insertion_point(field_add:research_scann.HierarchicalPartitionerConfig.partitioning)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::research_scann::PartitioningConfig>& HierarchicalPartitionerConfig::partitioning() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:research_scann.HierarchicalPartitionerConfig.partitioning)
  return _internal_partitioning();
}
inline const ::google::protobuf::RepeatedPtrField<::research_scann::PartitioningConfig>&
HierarchicalPartitionerConfig::_internal_partitioning() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partitioning_;
}
inline ::google::protobuf::RepeatedPtrField<::research_scann::PartitioningConfig>*
HierarchicalPartitionerConfig::_internal_mutable_partitioning() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.partitioning_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace research_scann


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::research_scann::PartitioningConfig_TreeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::PartitioningConfig_TreeType>() {
  return ::research_scann::PartitioningConfig_TreeType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::PartitioningConfig_TokenizationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::PartitioningConfig_TokenizationType>() {
  return ::research_scann::PartitioningConfig_TokenizationType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::PartitioningConfig_PartitioningType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::PartitioningConfig_PartitioningType>() {
  return ::research_scann::PartitioningConfig_PartitioningType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::PartitioningConfig_BalancingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::PartitioningConfig_BalancingType>() {
  return ::research_scann::PartitioningConfig_BalancingType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::PartitioningConfig_SingleMachineCenterInitializationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::PartitioningConfig_SingleMachineCenterInitializationType>() {
  return ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::PartitioningConfig_PartitionerTrainerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::PartitioningConfig_PartitionerTrainerType>() {
  return ::research_scann::PartitioningConfig_PartitionerTrainerType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::DatabaseSpillingConfig_SpillingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::DatabaseSpillingConfig_SpillingType>() {
  return ::research_scann::DatabaseSpillingConfig_SpillingType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::QuerySpillingConfig_SpillingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::QuerySpillingConfig_SpillingType>() {
  return ::research_scann::QuerySpillingConfig_SpillingType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fpartitioning_2eproto_2epb_2eh
