// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/input_output.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "scann/proto/incremental_updates.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2finput_5foutput_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2finput_5foutput_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_scann_2fproto_2finput_5foutput_2eproto;
namespace research_scann {
class InputOutputConfig;
struct InputOutputConfigDefaultTypeInternal;
extern InputOutputConfigDefaultTypeInternal _InputOutputConfig_default_instance_;
class InputOutputConfig_PreprocessingFunction;
struct InputOutputConfig_PreprocessingFunctionDefaultTypeInternal;
extern InputOutputConfig_PreprocessingFunctionDefaultTypeInternal _InputOutputConfig_PreprocessingFunction_default_instance_;
class InputOutputConfig_PureDynamicConfig;
struct InputOutputConfig_PureDynamicConfigDefaultTypeInternal;
extern InputOutputConfig_PureDynamicConfigDefaultTypeInternal _InputOutputConfig_PureDynamicConfig_default_instance_;
}  // namespace research_scann
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace research_scann {
enum InputOutputConfig_PureDynamicConfig_VectorType : int {
  InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE = 0,
  InputOutputConfig_PureDynamicConfig_VectorType_SPARSE = 1,
  InputOutputConfig_PureDynamicConfig_VectorType_DENSE = 2,
};

bool InputOutputConfig_PureDynamicConfig_VectorType_IsValid(int value);
extern const uint32_t InputOutputConfig_PureDynamicConfig_VectorType_internal_data_[];
constexpr InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MIN = static_cast<InputOutputConfig_PureDynamicConfig_VectorType>(0);
constexpr InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX = static_cast<InputOutputConfig_PureDynamicConfig_VectorType>(2);
constexpr int InputOutputConfig_PureDynamicConfig_VectorType_VectorType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
template <typename T>
const std::string& InputOutputConfig_PureDynamicConfig_VectorType_Name(T value) {
  static_assert(std::is_same<T, InputOutputConfig_PureDynamicConfig_VectorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VectorType_Name().");
  return InputOutputConfig_PureDynamicConfig_VectorType_Name(static_cast<InputOutputConfig_PureDynamicConfig_VectorType>(value));
}
template <>
inline const std::string& InputOutputConfig_PureDynamicConfig_VectorType_Name(InputOutputConfig_PureDynamicConfig_VectorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InputOutputConfig_PureDynamicConfig_VectorType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool InputOutputConfig_PureDynamicConfig_VectorType_Parse(absl::string_view name, InputOutputConfig_PureDynamicConfig_VectorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputOutputConfig_PureDynamicConfig_VectorType>(
      InputOutputConfig_PureDynamicConfig_VectorType_descriptor(), name, value);
}
enum InputOutputConfig_InMemoryTypes : int {
  InputOutputConfig_InMemoryTypes_INT8 = 0,
  InputOutputConfig_InMemoryTypes_UINT8 = 1,
  InputOutputConfig_InMemoryTypes_INT16 = 2,
  InputOutputConfig_InMemoryTypes_INT32 = 4,
  InputOutputConfig_InMemoryTypes_UINT32 = 5,
  InputOutputConfig_InMemoryTypes_INT64 = 6,
  InputOutputConfig_InMemoryTypes_FLOAT = 8,
  InputOutputConfig_InMemoryTypes_DOUBLE = 9,
  InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED = 255,
  InputOutputConfig_InMemoryTypes_UINT16 [[deprecated]] = 3,
  InputOutputConfig_InMemoryTypes_UINT64 [[deprecated]] = 7,
};

bool InputOutputConfig_InMemoryTypes_IsValid(int value);
extern const uint32_t InputOutputConfig_InMemoryTypes_internal_data_[];
constexpr InputOutputConfig_InMemoryTypes InputOutputConfig_InMemoryTypes_InMemoryTypes_MIN = static_cast<InputOutputConfig_InMemoryTypes>(0);
constexpr InputOutputConfig_InMemoryTypes InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX = static_cast<InputOutputConfig_InMemoryTypes>(255);
constexpr int InputOutputConfig_InMemoryTypes_InMemoryTypes_ARRAYSIZE = 255 + 1;
const ::google::protobuf::EnumDescriptor*
InputOutputConfig_InMemoryTypes_descriptor();
template <typename T>
const std::string& InputOutputConfig_InMemoryTypes_Name(T value) {
  static_assert(std::is_same<T, InputOutputConfig_InMemoryTypes>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InMemoryTypes_Name().");
  return ::google::protobuf::internal::NameOfEnum(InputOutputConfig_InMemoryTypes_descriptor(), value);
}
inline bool InputOutputConfig_InMemoryTypes_Parse(absl::string_view name, InputOutputConfig_InMemoryTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputOutputConfig_InMemoryTypes>(
      InputOutputConfig_InMemoryTypes_descriptor(), name, value);
}
enum InputOutputConfig_ArtifactsNamingOption : int {
  InputOutputConfig_ArtifactsNamingOption_HASHED = 0,
  InputOutputConfig_ArtifactsNamingOption_NO_HASH = 1,
};

bool InputOutputConfig_ArtifactsNamingOption_IsValid(int value);
extern const uint32_t InputOutputConfig_ArtifactsNamingOption_internal_data_[];
constexpr InputOutputConfig_ArtifactsNamingOption InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MIN = static_cast<InputOutputConfig_ArtifactsNamingOption>(0);
constexpr InputOutputConfig_ArtifactsNamingOption InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX = static_cast<InputOutputConfig_ArtifactsNamingOption>(1);
constexpr int InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
InputOutputConfig_ArtifactsNamingOption_descriptor();
template <typename T>
const std::string& InputOutputConfig_ArtifactsNamingOption_Name(T value) {
  static_assert(std::is_same<T, InputOutputConfig_ArtifactsNamingOption>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ArtifactsNamingOption_Name().");
  return InputOutputConfig_ArtifactsNamingOption_Name(static_cast<InputOutputConfig_ArtifactsNamingOption>(value));
}
template <>
inline const std::string& InputOutputConfig_ArtifactsNamingOption_Name(InputOutputConfig_ArtifactsNamingOption value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InputOutputConfig_ArtifactsNamingOption_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool InputOutputConfig_ArtifactsNamingOption_Parse(absl::string_view name, InputOutputConfig_ArtifactsNamingOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputOutputConfig_ArtifactsNamingOption>(
      InputOutputConfig_ArtifactsNamingOption_descriptor(), name, value);
}
enum InputOutputConfig_FeatureNorm : int {
  InputOutputConfig_FeatureNorm_NONE = 0,
  InputOutputConfig_FeatureNorm_UNITL2NORM = 1,
  InputOutputConfig_FeatureNorm_STDGAUSSNORM = 2,
  InputOutputConfig_FeatureNorm_UNITL1NORM = 3,
};

bool InputOutputConfig_FeatureNorm_IsValid(int value);
extern const uint32_t InputOutputConfig_FeatureNorm_internal_data_[];
constexpr InputOutputConfig_FeatureNorm InputOutputConfig_FeatureNorm_FeatureNorm_MIN = static_cast<InputOutputConfig_FeatureNorm>(0);
constexpr InputOutputConfig_FeatureNorm InputOutputConfig_FeatureNorm_FeatureNorm_MAX = static_cast<InputOutputConfig_FeatureNorm>(3);
constexpr int InputOutputConfig_FeatureNorm_FeatureNorm_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
InputOutputConfig_FeatureNorm_descriptor();
template <typename T>
const std::string& InputOutputConfig_FeatureNorm_Name(T value) {
  static_assert(std::is_same<T, InputOutputConfig_FeatureNorm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FeatureNorm_Name().");
  return InputOutputConfig_FeatureNorm_Name(static_cast<InputOutputConfig_FeatureNorm>(value));
}
template <>
inline const std::string& InputOutputConfig_FeatureNorm_Name(InputOutputConfig_FeatureNorm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InputOutputConfig_FeatureNorm_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool InputOutputConfig_FeatureNorm_Parse(absl::string_view name, InputOutputConfig_FeatureNorm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputOutputConfig_FeatureNorm>(
      InputOutputConfig_FeatureNorm_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class InputOutputConfig_PureDynamicConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.PureDynamicConfig) */ {
 public:
  inline InputOutputConfig_PureDynamicConfig() : InputOutputConfig_PureDynamicConfig(nullptr) {}
  ~InputOutputConfig_PureDynamicConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InputOutputConfig_PureDynamicConfig(::google::protobuf::internal::ConstantInitialized);

  inline InputOutputConfig_PureDynamicConfig(const InputOutputConfig_PureDynamicConfig& from)
      : InputOutputConfig_PureDynamicConfig(nullptr, from) {}
  InputOutputConfig_PureDynamicConfig(InputOutputConfig_PureDynamicConfig&& from) noexcept
    : InputOutputConfig_PureDynamicConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_PureDynamicConfig& operator=(const InputOutputConfig_PureDynamicConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_PureDynamicConfig& operator=(InputOutputConfig_PureDynamicConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputOutputConfig_PureDynamicConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputOutputConfig_PureDynamicConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_PureDynamicConfig*>(
               &_InputOutputConfig_PureDynamicConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InputOutputConfig_PureDynamicConfig& a, InputOutputConfig_PureDynamicConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_PureDynamicConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputOutputConfig_PureDynamicConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputOutputConfig_PureDynamicConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputOutputConfig_PureDynamicConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputOutputConfig_PureDynamicConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InputOutputConfig_PureDynamicConfig& from) {
    InputOutputConfig_PureDynamicConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputOutputConfig_PureDynamicConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.InputOutputConfig.PureDynamicConfig";
  }
  protected:
  explicit InputOutputConfig_PureDynamicConfig(::google::protobuf::Arena* arena);
  InputOutputConfig_PureDynamicConfig(::google::protobuf::Arena* arena, const InputOutputConfig_PureDynamicConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VectorType = InputOutputConfig_PureDynamicConfig_VectorType;
  static constexpr VectorType UNSPECIFIED_VECTOR_TYPE = InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE;
  static constexpr VectorType SPARSE = InputOutputConfig_PureDynamicConfig_VectorType_SPARSE;
  static constexpr VectorType DENSE = InputOutputConfig_PureDynamicConfig_VectorType_DENSE;
  static inline bool VectorType_IsValid(int value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_IsValid(value);
  }
  static constexpr VectorType VectorType_MIN = InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MIN;
  static constexpr VectorType VectorType_MAX = InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX;
  static constexpr int VectorType_ARRAYSIZE = InputOutputConfig_PureDynamicConfig_VectorType_VectorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VectorType_descriptor() {
    return InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
  }
  template <typename T>
  static inline const std::string& VectorType_Name(T value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_Name(value);
  }
  static inline bool VectorType_Parse(absl::string_view name, VectorType* value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionalityFieldNumber = 3,
    kVectorTypeFieldNumber = 2,
    kNumShardsFieldNumber = 1,
  };
  // optional uint64 dimensionality = 3;
  bool has_dimensionality() const;
  void clear_dimensionality() ;
  ::uint64_t dimensionality() const;
  void set_dimensionality(::uint64_t value);

  private:
  ::uint64_t _internal_dimensionality() const;
  void _internal_set_dimensionality(::uint64_t value);

  public:
  // optional .research_scann.InputOutputConfig.PureDynamicConfig.VectorType vector_type = 2 [default = UNSPECIFIED_VECTOR_TYPE];
  bool has_vector_type() const;
  void clear_vector_type() ;
  ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType vector_type() const;
  void set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value);

  private:
  ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType _internal_vector_type() const;
  void _internal_set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value);

  public:
  // optional int32 num_shards = 1 [default = 1];
  bool has_num_shards() const;
  void clear_num_shards() ;
  ::int32_t num_shards() const;
  void set_num_shards(::int32_t value);

  private:
  ::int32_t _internal_num_shards() const;
  void _internal_set_num_shards(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.PureDynamicConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t dimensionality_;
    int vector_type_;
    ::int32_t num_shards_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};// -------------------------------------------------------------------

class InputOutputConfig_PreprocessingFunction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.PreprocessingFunction) */ {
 public:
  inline InputOutputConfig_PreprocessingFunction() : InputOutputConfig_PreprocessingFunction(nullptr) {}
  ~InputOutputConfig_PreprocessingFunction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InputOutputConfig_PreprocessingFunction(::google::protobuf::internal::ConstantInitialized);

  inline InputOutputConfig_PreprocessingFunction(const InputOutputConfig_PreprocessingFunction& from)
      : InputOutputConfig_PreprocessingFunction(nullptr, from) {}
  InputOutputConfig_PreprocessingFunction(InputOutputConfig_PreprocessingFunction&& from) noexcept
    : InputOutputConfig_PreprocessingFunction() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_PreprocessingFunction& operator=(const InputOutputConfig_PreprocessingFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_PreprocessingFunction& operator=(InputOutputConfig_PreprocessingFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputOutputConfig_PreprocessingFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputOutputConfig_PreprocessingFunction* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_PreprocessingFunction*>(
               &_InputOutputConfig_PreprocessingFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InputOutputConfig_PreprocessingFunction& a, InputOutputConfig_PreprocessingFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_PreprocessingFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputOutputConfig_PreprocessingFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputOutputConfig_PreprocessingFunction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputOutputConfig_PreprocessingFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputOutputConfig_PreprocessingFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InputOutputConfig_PreprocessingFunction& from) {
    InputOutputConfig_PreprocessingFunction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputOutputConfig_PreprocessingFunction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.InputOutputConfig.PreprocessingFunction";
  }
  protected:
  explicit InputOutputConfig_PreprocessingFunction(::google::protobuf::Arena* arena);
  InputOutputConfig_PreprocessingFunction(::google::protobuf::Arena* arena, const InputOutputConfig_PreprocessingFunction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConfigAsciiFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string config_ascii = 2;
  bool has_config_ascii() const;
  void clear_config_ascii() ;
  const std::string& config_ascii() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_ascii(Arg_&& arg, Args_... args);
  std::string* mutable_config_ascii();
  PROTOBUF_NODISCARD std::string* release_config_ascii();
  void set_allocated_config_ascii(std::string* value);

  private:
  const std::string& _internal_config_ascii() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_ascii(
      const std::string& value);
  std::string* _internal_mutable_config_ascii();

  public:
  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.PreprocessingFunction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr config_ascii_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};// -------------------------------------------------------------------

class InputOutputConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig) */ {
 public:
  inline InputOutputConfig() : InputOutputConfig(nullptr) {}
  ~InputOutputConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InputOutputConfig(::google::protobuf::internal::ConstantInitialized);

  inline InputOutputConfig(const InputOutputConfig& from)
      : InputOutputConfig(nullptr, from) {}
  InputOutputConfig(InputOutputConfig&& from) noexcept
    : InputOutputConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig& operator=(const InputOutputConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig& operator=(InputOutputConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputOutputConfig& default_instance() {
    return *internal_default_instance();
  }
  enum IncrementalUpdateMetadataOneofCase {
    kIncrementalUpdateMetadataLocation = 19,
    kIncrementalUpdateMetadata = 22,
    INCREMENTALUPDATEMETADATAONEOF_NOT_SET = 0,
  };

  static inline const InputOutputConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig*>(
               &_InputOutputConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InputOutputConfig& a, InputOutputConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputOutputConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputOutputConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputOutputConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputOutputConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InputOutputConfig& from) {
    InputOutputConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputOutputConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "research_scann.InputOutputConfig";
  }
  protected:
  explicit InputOutputConfig(::google::protobuf::Arena* arena);
  InputOutputConfig(::google::protobuf::Arena* arena, const InputOutputConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using PureDynamicConfig = InputOutputConfig_PureDynamicConfig;
  using PreprocessingFunction = InputOutputConfig_PreprocessingFunction;

  using InMemoryTypes = InputOutputConfig_InMemoryTypes;
  static constexpr InMemoryTypes INT8 = InputOutputConfig_InMemoryTypes_INT8;
  static constexpr InMemoryTypes UINT8 = InputOutputConfig_InMemoryTypes_UINT8;
  static constexpr InMemoryTypes INT16 = InputOutputConfig_InMemoryTypes_INT16;
  static constexpr InMemoryTypes INT32 = InputOutputConfig_InMemoryTypes_INT32;
  static constexpr InMemoryTypes UINT32 = InputOutputConfig_InMemoryTypes_UINT32;
  static constexpr InMemoryTypes INT64 = InputOutputConfig_InMemoryTypes_INT64;
  static constexpr InMemoryTypes FLOAT = InputOutputConfig_InMemoryTypes_FLOAT;
  static constexpr InMemoryTypes DOUBLE = InputOutputConfig_InMemoryTypes_DOUBLE;
  static constexpr InMemoryTypes IN_MEMORY_DATA_TYPE_NOT_SPECIFIED = InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED;
  [[deprecated]] static constexpr InMemoryTypes UINT16 = InputOutputConfig_InMemoryTypes_UINT16;
  [[deprecated]] static constexpr InMemoryTypes UINT64 = InputOutputConfig_InMemoryTypes_UINT64;
  static inline bool InMemoryTypes_IsValid(int value) {
    return InputOutputConfig_InMemoryTypes_IsValid(value);
  }
  static constexpr InMemoryTypes InMemoryTypes_MIN = InputOutputConfig_InMemoryTypes_InMemoryTypes_MIN;
  static constexpr InMemoryTypes InMemoryTypes_MAX = InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX;
  static constexpr int InMemoryTypes_ARRAYSIZE = InputOutputConfig_InMemoryTypes_InMemoryTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* InMemoryTypes_descriptor() {
    return InputOutputConfig_InMemoryTypes_descriptor();
  }
  template <typename T>
  static inline const std::string& InMemoryTypes_Name(T value) {
    return InputOutputConfig_InMemoryTypes_Name(value);
  }
  static inline bool InMemoryTypes_Parse(absl::string_view name, InMemoryTypes* value) {
    return InputOutputConfig_InMemoryTypes_Parse(name, value);
  }

  using ArtifactsNamingOption = InputOutputConfig_ArtifactsNamingOption;
  static constexpr ArtifactsNamingOption HASHED = InputOutputConfig_ArtifactsNamingOption_HASHED;
  static constexpr ArtifactsNamingOption NO_HASH = InputOutputConfig_ArtifactsNamingOption_NO_HASH;
  static inline bool ArtifactsNamingOption_IsValid(int value) {
    return InputOutputConfig_ArtifactsNamingOption_IsValid(value);
  }
  static constexpr ArtifactsNamingOption ArtifactsNamingOption_MIN = InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MIN;
  static constexpr ArtifactsNamingOption ArtifactsNamingOption_MAX = InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX;
  static constexpr int ArtifactsNamingOption_ARRAYSIZE = InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ArtifactsNamingOption_descriptor() {
    return InputOutputConfig_ArtifactsNamingOption_descriptor();
  }
  template <typename T>
  static inline const std::string& ArtifactsNamingOption_Name(T value) {
    return InputOutputConfig_ArtifactsNamingOption_Name(value);
  }
  static inline bool ArtifactsNamingOption_Parse(absl::string_view name, ArtifactsNamingOption* value) {
    return InputOutputConfig_ArtifactsNamingOption_Parse(name, value);
  }

  using FeatureNorm = InputOutputConfig_FeatureNorm;
  static constexpr FeatureNorm NONE = InputOutputConfig_FeatureNorm_NONE;
  static constexpr FeatureNorm UNITL2NORM = InputOutputConfig_FeatureNorm_UNITL2NORM;
  static constexpr FeatureNorm STDGAUSSNORM = InputOutputConfig_FeatureNorm_STDGAUSSNORM;
  static constexpr FeatureNorm UNITL1NORM = InputOutputConfig_FeatureNorm_UNITL1NORM;
  static inline bool FeatureNorm_IsValid(int value) {
    return InputOutputConfig_FeatureNorm_IsValid(value);
  }
  static constexpr FeatureNorm FeatureNorm_MIN = InputOutputConfig_FeatureNorm_FeatureNorm_MIN;
  static constexpr FeatureNorm FeatureNorm_MAX = InputOutputConfig_FeatureNorm_FeatureNorm_MAX;
  static constexpr int FeatureNorm_ARRAYSIZE = InputOutputConfig_FeatureNorm_FeatureNorm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FeatureNorm_descriptor() {
    return InputOutputConfig_FeatureNorm_descriptor();
  }
  template <typename T>
  static inline const std::string& FeatureNorm_Name(T value) {
    return InputOutputConfig_FeatureNorm_Name(value);
  }
  static inline bool FeatureNorm_Parse(absl::string_view name, FeatureNorm* value) {
    return InputOutputConfig_FeatureNorm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseWildcardFieldNumber = 3,
    kQueryWildcardFieldNumber = 8,
    kOutputSstableWildcardFieldNumber = 11,
    kHashedDatabaseWildcardFieldNumber = 12,
    kTokenizedDatabaseWildcardFieldNumber = 14,
    kFixedPointDatabaseWildcardFieldNumber = 17,
    kPreprocessedArtifactsDirFieldNumber = 18,
    kMemoryConsumptionEstimateFilenameFieldNumber = 24,
    kQueryPreprocessingFunctionFieldNumber = 16,
    kPureDynamicConfigFieldNumber = 21,
    kDimensionalityFieldNumber = 4,
    kNormTypeFieldNumber = 5,
    kAllowTwoPassReadFieldNumber = 15,
    kNonNegativeFieldNumber = 6,
    kIsDenseFieldNumber = 7,
    kSaturateFieldNumber = 10,
    kArtifactsNamingOptionFieldNumber = 23,
    kInMemoryDataTypeFieldNumber = 2,
    kIncrementalUpdateMetadataLocationFieldNumber = 19,
    kIncrementalUpdateMetadataFieldNumber = 22,
  };
  // optional string database_wildcard = 3;
  bool has_database_wildcard() const;
  void clear_database_wildcard() ;
  const std::string& database_wildcard() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_database_wildcard(Arg_&& arg, Args_... args);
  std::string* mutable_database_wildcard();
  PROTOBUF_NODISCARD std::string* release_database_wildcard();
  void set_allocated_database_wildcard(std::string* value);

  private:
  const std::string& _internal_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_wildcard(
      const std::string& value);
  std::string* _internal_mutable_database_wildcard();

  public:
  // optional string query_wildcard = 8;
  bool has_query_wildcard() const;
  void clear_query_wildcard() ;
  const std::string& query_wildcard() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query_wildcard(Arg_&& arg, Args_... args);
  std::string* mutable_query_wildcard();
  PROTOBUF_NODISCARD std::string* release_query_wildcard();
  void set_allocated_query_wildcard(std::string* value);

  private:
  const std::string& _internal_query_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_wildcard(
      const std::string& value);
  std::string* _internal_mutable_query_wildcard();

  public:
  // optional string output_sstable_wildcard = 11;
  bool has_output_sstable_wildcard() const;
  void clear_output_sstable_wildcard() ;
  const std::string& output_sstable_wildcard() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_output_sstable_wildcard(Arg_&& arg, Args_... args);
  std::string* mutable_output_sstable_wildcard();
  PROTOBUF_NODISCARD std::string* release_output_sstable_wildcard();
  void set_allocated_output_sstable_wildcard(std::string* value);

  private:
  const std::string& _internal_output_sstable_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_sstable_wildcard(
      const std::string& value);
  std::string* _internal_mutable_output_sstable_wildcard();

  public:
  // optional string hashed_database_wildcard = 12;
  bool has_hashed_database_wildcard() const;
  void clear_hashed_database_wildcard() ;
  const std::string& hashed_database_wildcard() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hashed_database_wildcard(Arg_&& arg, Args_... args);
  std::string* mutable_hashed_database_wildcard();
  PROTOBUF_NODISCARD std::string* release_hashed_database_wildcard();
  void set_allocated_hashed_database_wildcard(std::string* value);

  private:
  const std::string& _internal_hashed_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed_database_wildcard(
      const std::string& value);
  std::string* _internal_mutable_hashed_database_wildcard();

  public:
  // optional string tokenized_database_wildcard = 14;
  bool has_tokenized_database_wildcard() const;
  void clear_tokenized_database_wildcard() ;
  const std::string& tokenized_database_wildcard() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tokenized_database_wildcard(Arg_&& arg, Args_... args);
  std::string* mutable_tokenized_database_wildcard();
  PROTOBUF_NODISCARD std::string* release_tokenized_database_wildcard();
  void set_allocated_tokenized_database_wildcard(std::string* value);

  private:
  const std::string& _internal_tokenized_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokenized_database_wildcard(
      const std::string& value);
  std::string* _internal_mutable_tokenized_database_wildcard();

  public:
  // optional string fixed_point_database_wildcard = 17;
  bool has_fixed_point_database_wildcard() const;
  void clear_fixed_point_database_wildcard() ;
  const std::string& fixed_point_database_wildcard() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fixed_point_database_wildcard(Arg_&& arg, Args_... args);
  std::string* mutable_fixed_point_database_wildcard();
  PROTOBUF_NODISCARD std::string* release_fixed_point_database_wildcard();
  void set_allocated_fixed_point_database_wildcard(std::string* value);

  private:
  const std::string& _internal_fixed_point_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_point_database_wildcard(
      const std::string& value);
  std::string* _internal_mutable_fixed_point_database_wildcard();

  public:
  // optional string preprocessed_artifacts_dir = 18;
  bool has_preprocessed_artifacts_dir() const;
  void clear_preprocessed_artifacts_dir() ;
  const std::string& preprocessed_artifacts_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_preprocessed_artifacts_dir(Arg_&& arg, Args_... args);
  std::string* mutable_preprocessed_artifacts_dir();
  PROTOBUF_NODISCARD std::string* release_preprocessed_artifacts_dir();
  void set_allocated_preprocessed_artifacts_dir(std::string* value);

  private:
  const std::string& _internal_preprocessed_artifacts_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preprocessed_artifacts_dir(
      const std::string& value);
  std::string* _internal_mutable_preprocessed_artifacts_dir();

  public:
  // optional string memory_consumption_estimate_filename = 24;
  bool has_memory_consumption_estimate_filename() const;
  void clear_memory_consumption_estimate_filename() ;
  const std::string& memory_consumption_estimate_filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_memory_consumption_estimate_filename(Arg_&& arg, Args_... args);
  std::string* mutable_memory_consumption_estimate_filename();
  PROTOBUF_NODISCARD std::string* release_memory_consumption_estimate_filename();
  void set_allocated_memory_consumption_estimate_filename(std::string* value);

  private:
  const std::string& _internal_memory_consumption_estimate_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_consumption_estimate_filename(
      const std::string& value);
  std::string* _internal_mutable_memory_consumption_estimate_filename();

  public:
  // optional .research_scann.InputOutputConfig.PreprocessingFunction query_preprocessing_function = 16;
  bool has_query_preprocessing_function() const;
  void clear_query_preprocessing_function() ;
  const ::research_scann::InputOutputConfig_PreprocessingFunction& query_preprocessing_function() const;
  PROTOBUF_NODISCARD ::research_scann::InputOutputConfig_PreprocessingFunction* release_query_preprocessing_function();
  ::research_scann::InputOutputConfig_PreprocessingFunction* mutable_query_preprocessing_function();
  void set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* value);
  void unsafe_arena_set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* value);
  ::research_scann::InputOutputConfig_PreprocessingFunction* unsafe_arena_release_query_preprocessing_function();

  private:
  const ::research_scann::InputOutputConfig_PreprocessingFunction& _internal_query_preprocessing_function() const;
  ::research_scann::InputOutputConfig_PreprocessingFunction* _internal_mutable_query_preprocessing_function();

  public:
  // optional .research_scann.InputOutputConfig.PureDynamicConfig pure_dynamic_config = 21;
  bool has_pure_dynamic_config() const;
  void clear_pure_dynamic_config() ;
  const ::research_scann::InputOutputConfig_PureDynamicConfig& pure_dynamic_config() const;
  PROTOBUF_NODISCARD ::research_scann::InputOutputConfig_PureDynamicConfig* release_pure_dynamic_config();
  ::research_scann::InputOutputConfig_PureDynamicConfig* mutable_pure_dynamic_config();
  void set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* value);
  void unsafe_arena_set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* value);
  ::research_scann::InputOutputConfig_PureDynamicConfig* unsafe_arena_release_pure_dynamic_config();

  private:
  const ::research_scann::InputOutputConfig_PureDynamicConfig& _internal_pure_dynamic_config() const;
  ::research_scann::InputOutputConfig_PureDynamicConfig* _internal_mutable_pure_dynamic_config();

  public:
  // optional uint64 dimensionality = 4 [deprecated = true];
  [[deprecated]]  bool has_dimensionality() const;
  [[deprecated]]  void clear_dimensionality() ;
  [[deprecated]] ::uint64_t dimensionality() const;
  [[deprecated]] void set_dimensionality(::uint64_t value);

  private:
  ::uint64_t _internal_dimensionality() const;
  void _internal_set_dimensionality(::uint64_t value);

  public:
  // optional .research_scann.InputOutputConfig.FeatureNorm norm_type = 5 [default = NONE];
  bool has_norm_type() const;
  void clear_norm_type() ;
  ::research_scann::InputOutputConfig_FeatureNorm norm_type() const;
  void set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value);

  private:
  ::research_scann::InputOutputConfig_FeatureNorm _internal_norm_type() const;
  void _internal_set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value);

  public:
  // optional bool allow_two_pass_read = 15 [default = false];
  bool has_allow_two_pass_read() const;
  void clear_allow_two_pass_read() ;
  bool allow_two_pass_read() const;
  void set_allow_two_pass_read(bool value);

  private:
  bool _internal_allow_two_pass_read() const;
  void _internal_set_allow_two_pass_read(bool value);

  public:
  // optional bool non_negative = 6 [default = false];
  bool has_non_negative() const;
  void clear_non_negative() ;
  bool non_negative() const;
  void set_non_negative(bool value);

  private:
  bool _internal_non_negative() const;
  void _internal_set_non_negative(bool value);

  public:
  // optional bool is_dense = 7;
  bool has_is_dense() const;
  void clear_is_dense() ;
  bool is_dense() const;
  void set_is_dense(bool value);

  private:
  bool _internal_is_dense() const;
  void _internal_set_is_dense(bool value);

  public:
  // optional bool saturate = 10 [default = false, deprecated = true];
  [[deprecated]]  bool has_saturate() const;
  [[deprecated]]  void clear_saturate() ;
  [[deprecated]] bool saturate() const;
  [[deprecated]] void set_saturate(bool value);

  private:
  bool _internal_saturate() const;
  void _internal_set_saturate(bool value);

  public:
  // optional .research_scann.InputOutputConfig.ArtifactsNamingOption artifacts_naming_option = 23 [default = HASHED];
  bool has_artifacts_naming_option() const;
  void clear_artifacts_naming_option() ;
  ::research_scann::InputOutputConfig_ArtifactsNamingOption artifacts_naming_option() const;
  void set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value);

  private:
  ::research_scann::InputOutputConfig_ArtifactsNamingOption _internal_artifacts_naming_option() const;
  void _internal_set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value);

  public:
  // optional .research_scann.InputOutputConfig.InMemoryTypes in_memory_data_type = 2 [default = IN_MEMORY_DATA_TYPE_NOT_SPECIFIED];
  bool has_in_memory_data_type() const;
  void clear_in_memory_data_type() ;
  ::research_scann::InputOutputConfig_InMemoryTypes in_memory_data_type() const;
  void set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value);

  private:
  ::research_scann::InputOutputConfig_InMemoryTypes _internal_in_memory_data_type() const;
  void _internal_set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value);

  public:
  // string incremental_update_metadata_location = 19;
  bool has_incremental_update_metadata_location() const;
  void clear_incremental_update_metadata_location() ;
  const std::string& incremental_update_metadata_location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_incremental_update_metadata_location(Arg_&& arg, Args_... args);
  std::string* mutable_incremental_update_metadata_location();
  PROTOBUF_NODISCARD std::string* release_incremental_update_metadata_location();
  void set_allocated_incremental_update_metadata_location(std::string* value);

  private:
  const std::string& _internal_incremental_update_metadata_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_incremental_update_metadata_location(
      const std::string& value);
  std::string* _internal_mutable_incremental_update_metadata_location();

  public:
  // .research_scann.IncrementalUpdateMetadata incremental_update_metadata = 22;
  bool has_incremental_update_metadata() const;
  private:
  bool _internal_has_incremental_update_metadata() const;

  public:
  void clear_incremental_update_metadata() ;
  const ::research_scann::IncrementalUpdateMetadata& incremental_update_metadata() const;
  PROTOBUF_NODISCARD ::research_scann::IncrementalUpdateMetadata* release_incremental_update_metadata();
  ::research_scann::IncrementalUpdateMetadata* mutable_incremental_update_metadata();
  void set_allocated_incremental_update_metadata(::research_scann::IncrementalUpdateMetadata* value);
  void unsafe_arena_set_allocated_incremental_update_metadata(::research_scann::IncrementalUpdateMetadata* value);
  ::research_scann::IncrementalUpdateMetadata* unsafe_arena_release_incremental_update_metadata();

  private:
  const ::research_scann::IncrementalUpdateMetadata& _internal_incremental_update_metadata() const;
  ::research_scann::IncrementalUpdateMetadata* _internal_mutable_incremental_update_metadata();

  public:
  void clear_IncrementalUpdateMetadataOneof();
  IncrementalUpdateMetadataOneofCase IncrementalUpdateMetadataOneof_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig)
 private:
  class _Internal;
  void set_has_incremental_update_metadata_location();
  void set_has_incremental_update_metadata();

  inline bool has_IncrementalUpdateMetadataOneof() const;
  inline void clear_has_IncrementalUpdateMetadataOneof();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 20, 6,
      289, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr database_wildcard_;
    ::google::protobuf::internal::ArenaStringPtr query_wildcard_;
    ::google::protobuf::internal::ArenaStringPtr output_sstable_wildcard_;
    ::google::protobuf::internal::ArenaStringPtr hashed_database_wildcard_;
    ::google::protobuf::internal::ArenaStringPtr tokenized_database_wildcard_;
    ::google::protobuf::internal::ArenaStringPtr fixed_point_database_wildcard_;
    ::google::protobuf::internal::ArenaStringPtr preprocessed_artifacts_dir_;
    ::google::protobuf::internal::ArenaStringPtr memory_consumption_estimate_filename_;
    ::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function_;
    ::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config_;
    ::uint64_t dimensionality_;
    int norm_type_;
    bool allow_two_pass_read_;
    bool non_negative_;
    bool is_dense_;
    bool saturate_;
    int artifacts_naming_option_;
    int in_memory_data_type_;
    union IncrementalUpdateMetadataOneofUnion {
      constexpr IncrementalUpdateMetadataOneofUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr incremental_update_metadata_location_;
      ::research_scann::IncrementalUpdateMetadata* incremental_update_metadata_;
    } IncrementalUpdateMetadataOneof_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InputOutputConfig_PureDynamicConfig

// optional int32 num_shards = 1 [default = 1];
inline bool InputOutputConfig_PureDynamicConfig::has_num_shards() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InputOutputConfig_PureDynamicConfig::clear_num_shards() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_shards_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t InputOutputConfig_PureDynamicConfig::num_shards() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.num_shards)
  return _internal_num_shards();
}
inline void InputOutputConfig_PureDynamicConfig::set_num_shards(::int32_t value) {
  _internal_set_num_shards(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.num_shards)
}
inline ::int32_t InputOutputConfig_PureDynamicConfig::_internal_num_shards() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_shards_;
}
inline void InputOutputConfig_PureDynamicConfig::_internal_set_num_shards(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_shards_ = value;
}

// optional .research_scann.InputOutputConfig.PureDynamicConfig.VectorType vector_type = 2 [default = UNSPECIFIED_VECTOR_TYPE];
inline bool InputOutputConfig_PureDynamicConfig::has_vector_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InputOutputConfig_PureDynamicConfig::clear_vector_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig::vector_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.vector_type)
  return _internal_vector_type();
}
inline void InputOutputConfig_PureDynamicConfig::set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value) {
  _internal_set_vector_type(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.vector_type)
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig::_internal_vector_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::InputOutputConfig_PureDynamicConfig_VectorType>(_impl_.vector_type_);
}
inline void InputOutputConfig_PureDynamicConfig::_internal_set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vector_type_ = value;
}

// optional uint64 dimensionality = 3;
inline bool InputOutputConfig_PureDynamicConfig::has_dimensionality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InputOutputConfig_PureDynamicConfig::clear_dimensionality() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dimensionality_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t InputOutputConfig_PureDynamicConfig::dimensionality() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.dimensionality)
  return _internal_dimensionality();
}
inline void InputOutputConfig_PureDynamicConfig::set_dimensionality(::uint64_t value) {
  _internal_set_dimensionality(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.dimensionality)
}
inline ::uint64_t InputOutputConfig_PureDynamicConfig::_internal_dimensionality() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionality_;
}
inline void InputOutputConfig_PureDynamicConfig::_internal_set_dimensionality(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionality_ = value;
}

// -------------------------------------------------------------------

// InputOutputConfig_PreprocessingFunction

// optional string name = 1;
inline bool InputOutputConfig_PreprocessingFunction::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InputOutputConfig_PreprocessingFunction::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PreprocessingFunction.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig_PreprocessingFunction::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PreprocessingFunction.name)
}
inline std::string* InputOutputConfig_PreprocessingFunction::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.PreprocessingFunction.name)
  return _s;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void InputOutputConfig_PreprocessingFunction::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* InputOutputConfig_PreprocessingFunction::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* InputOutputConfig_PreprocessingFunction::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.PreprocessingFunction.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig_PreprocessingFunction::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.PreprocessingFunction.name)
}

// optional string config_ascii = 2;
inline bool InputOutputConfig_PreprocessingFunction::has_config_ascii() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InputOutputConfig_PreprocessingFunction::clear_config_ascii() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.config_ascii_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::config_ascii() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  return _internal_config_ascii();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig_PreprocessingFunction::set_config_ascii(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.config_ascii_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}
inline std::string* InputOutputConfig_PreprocessingFunction::mutable_config_ascii() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_config_ascii();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  return _s;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::_internal_config_ascii() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.config_ascii_.Get();
}
inline void InputOutputConfig_PreprocessingFunction::_internal_set_config_ascii(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.config_ascii_.Set(value, GetArena());
}
inline std::string* InputOutputConfig_PreprocessingFunction::_internal_mutable_config_ascii() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.config_ascii_.Mutable( GetArena());
}
inline std::string* InputOutputConfig_PreprocessingFunction::release_config_ascii() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.config_ascii_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.config_ascii_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig_PreprocessingFunction::set_allocated_config_ascii(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.config_ascii_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_ascii_.IsDefault()) {
          _impl_.config_ascii_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}

// -------------------------------------------------------------------

// InputOutputConfig

// optional .research_scann.InputOutputConfig.InMemoryTypes in_memory_data_type = 2 [default = IN_MEMORY_DATA_TYPE_NOT_SPECIFIED];
inline bool InputOutputConfig::has_in_memory_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void InputOutputConfig::clear_in_memory_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_memory_data_type_ = 255;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::research_scann::InputOutputConfig_InMemoryTypes InputOutputConfig::in_memory_data_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.in_memory_data_type)
  return _internal_in_memory_data_type();
}
inline void InputOutputConfig::set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value) {
  _internal_set_in_memory_data_type(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.in_memory_data_type)
}
inline ::research_scann::InputOutputConfig_InMemoryTypes InputOutputConfig::_internal_in_memory_data_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::InputOutputConfig_InMemoryTypes>(_impl_.in_memory_data_type_);
}
inline void InputOutputConfig::_internal_set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::InputOutputConfig_InMemoryTypes_IsValid(value));
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.in_memory_data_type_ = value;
}

// optional string database_wildcard = 3;
inline bool InputOutputConfig::has_database_wildcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InputOutputConfig::clear_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_wildcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig::database_wildcard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.database_wildcard)
  return _internal_database_wildcard();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_database_wildcard(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.database_wildcard_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.database_wildcard)
}
inline std::string* InputOutputConfig::mutable_database_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_database_wildcard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_database_wildcard(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.database_wildcard_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.database_wildcard_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.database_wildcard)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.database_wildcard_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.database_wildcard_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_database_wildcard(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.database_wildcard_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.database_wildcard_.IsDefault()) {
          _impl_.database_wildcard_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.database_wildcard)
}

// optional bool allow_two_pass_read = 15 [default = false];
inline bool InputOutputConfig::has_allow_two_pass_read() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void InputOutputConfig::clear_allow_two_pass_read() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_two_pass_read_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool InputOutputConfig::allow_two_pass_read() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.allow_two_pass_read)
  return _internal_allow_two_pass_read();
}
inline void InputOutputConfig::set_allow_two_pass_read(bool value) {
  _internal_set_allow_two_pass_read(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.allow_two_pass_read)
}
inline bool InputOutputConfig::_internal_allow_two_pass_read() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_two_pass_read_;
}
inline void InputOutputConfig::_internal_set_allow_two_pass_read(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.allow_two_pass_read_ = value;
}

// optional string query_wildcard = 8;
inline bool InputOutputConfig::has_query_wildcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InputOutputConfig::clear_query_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_wildcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig::query_wildcard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.query_wildcard)
  return _internal_query_wildcard();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_query_wildcard(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.query_wildcard_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.query_wildcard)
}
inline std::string* InputOutputConfig::mutable_query_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.query_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_query_wildcard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.query_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_query_wildcard(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.query_wildcard_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_query_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.query_wildcard_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_query_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.query_wildcard)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.query_wildcard_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.query_wildcard_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_query_wildcard(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.query_wildcard_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_wildcard_.IsDefault()) {
          _impl_.query_wildcard_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.query_wildcard)
}

// string incremental_update_metadata_location = 19;
inline bool InputOutputConfig::has_incremental_update_metadata_location() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadataLocation;
}
inline void InputOutputConfig::set_has_incremental_update_metadata_location() {
  _impl_._oneof_case_[0] = kIncrementalUpdateMetadataLocation;
}
inline void InputOutputConfig::clear_incremental_update_metadata_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadataLocation) {
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Destroy();
    clear_has_IncrementalUpdateMetadataOneof();
  }
}
inline const std::string& InputOutputConfig::incremental_update_metadata_location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.incremental_update_metadata_location)
  return _internal_incremental_update_metadata_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_incremental_update_metadata_location(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (IncrementalUpdateMetadataOneof_case() != kIncrementalUpdateMetadataLocation) {
    clear_IncrementalUpdateMetadataOneof();

    set_has_incremental_update_metadata_location();
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.InitDefault();
  }
  _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.incremental_update_metadata_location)
}
inline std::string* InputOutputConfig::mutable_incremental_update_metadata_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_incremental_update_metadata_location();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.incremental_update_metadata_location)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_incremental_update_metadata_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (IncrementalUpdateMetadataOneof_case() != kIncrementalUpdateMetadataLocation) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Get();
}
inline void InputOutputConfig::_internal_set_incremental_update_metadata_location(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (IncrementalUpdateMetadataOneof_case() != kIncrementalUpdateMetadataLocation) {
    clear_IncrementalUpdateMetadataOneof();

    set_has_incremental_update_metadata_location();
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.InitDefault();
  }
  _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_incremental_update_metadata_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (IncrementalUpdateMetadataOneof_case() != kIncrementalUpdateMetadataLocation) {
    clear_IncrementalUpdateMetadataOneof();

    set_has_incremental_update_metadata_location();
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.InitDefault();
  }
  return _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_incremental_update_metadata_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.incremental_update_metadata_location)
  if (IncrementalUpdateMetadataOneof_case() != kIncrementalUpdateMetadataLocation) {
    return nullptr;
  }
  clear_has_IncrementalUpdateMetadataOneof();
  return _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Release();
}
inline void InputOutputConfig::set_allocated_incremental_update_metadata_location(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_IncrementalUpdateMetadataOneof()) {
    clear_IncrementalUpdateMetadataOneof();
  }
  if (value != nullptr) {
    set_has_incremental_update_metadata_location();
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.incremental_update_metadata_location)
}

// .research_scann.IncrementalUpdateMetadata incremental_update_metadata = 22;
inline bool InputOutputConfig::has_incremental_update_metadata() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata;
}
inline bool InputOutputConfig::_internal_has_incremental_update_metadata() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata;
}
inline void InputOutputConfig::set_has_incremental_update_metadata() {
  _impl_._oneof_case_[0] = kIncrementalUpdateMetadata;
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::release_incremental_update_metadata() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.incremental_update_metadata)
  if (IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata) {
    clear_has_IncrementalUpdateMetadataOneof();
    auto* temp = _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::research_scann::IncrementalUpdateMetadata& InputOutputConfig::_internal_incremental_update_metadata() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata ? *_impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_ : reinterpret_cast<::research_scann::IncrementalUpdateMetadata&>(::research_scann::_IncrementalUpdateMetadata_default_instance_);
}
inline const ::research_scann::IncrementalUpdateMetadata& InputOutputConfig::incremental_update_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.incremental_update_metadata)
  return _internal_incremental_update_metadata();
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::unsafe_arena_release_incremental_update_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:research_scann.InputOutputConfig.incremental_update_metadata)
  if (IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata) {
    clear_has_IncrementalUpdateMetadataOneof();
    auto* temp = _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputOutputConfig::unsafe_arena_set_allocated_incremental_update_metadata(::research_scann::IncrementalUpdateMetadata* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_IncrementalUpdateMetadataOneof();
  if (value) {
    set_has_incremental_update_metadata();
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.InputOutputConfig.incremental_update_metadata)
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::_internal_mutable_incremental_update_metadata() {
  if (IncrementalUpdateMetadataOneof_case() != kIncrementalUpdateMetadata) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata();
    _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = CreateMaybeMessage<::research_scann::IncrementalUpdateMetadata>(GetArena());
  }
  return _impl_.IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::mutable_incremental_update_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::IncrementalUpdateMetadata* _msg = _internal_mutable_incremental_update_metadata();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.incremental_update_metadata)
  return _msg;
}

// optional string output_sstable_wildcard = 11;
inline bool InputOutputConfig::has_output_sstable_wildcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InputOutputConfig::clear_output_sstable_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.output_sstable_wildcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InputOutputConfig::output_sstable_wildcard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.output_sstable_wildcard)
  return _internal_output_sstable_wildcard();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_output_sstable_wildcard(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.output_sstable_wildcard_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.output_sstable_wildcard)
}
inline std::string* InputOutputConfig::mutable_output_sstable_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_output_sstable_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.output_sstable_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_output_sstable_wildcard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.output_sstable_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_output_sstable_wildcard(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.output_sstable_wildcard_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_output_sstable_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.output_sstable_wildcard_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_output_sstable_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.output_sstable_wildcard)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.output_sstable_wildcard_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.output_sstable_wildcard_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_output_sstable_wildcard(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.output_sstable_wildcard_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.output_sstable_wildcard_.IsDefault()) {
          _impl_.output_sstable_wildcard_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.output_sstable_wildcard)
}

// optional string preprocessed_artifacts_dir = 18;
inline bool InputOutputConfig::has_preprocessed_artifacts_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void InputOutputConfig::clear_preprocessed_artifacts_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.preprocessed_artifacts_dir_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InputOutputConfig::preprocessed_artifacts_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  return _internal_preprocessed_artifacts_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_preprocessed_artifacts_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.preprocessed_artifacts_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}
inline std::string* InputOutputConfig::mutable_preprocessed_artifacts_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_preprocessed_artifacts_dir();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_preprocessed_artifacts_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.preprocessed_artifacts_dir_.Get();
}
inline void InputOutputConfig::_internal_set_preprocessed_artifacts_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.preprocessed_artifacts_dir_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_preprocessed_artifacts_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.preprocessed_artifacts_dir_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_preprocessed_artifacts_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.preprocessed_artifacts_dir_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.preprocessed_artifacts_dir_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_preprocessed_artifacts_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.preprocessed_artifacts_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.preprocessed_artifacts_dir_.IsDefault()) {
          _impl_.preprocessed_artifacts_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}

// optional .research_scann.InputOutputConfig.ArtifactsNamingOption artifacts_naming_option = 23 [default = HASHED];
inline bool InputOutputConfig::has_artifacts_naming_option() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void InputOutputConfig::clear_artifacts_naming_option() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.artifacts_naming_option_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::research_scann::InputOutputConfig_ArtifactsNamingOption InputOutputConfig::artifacts_naming_option() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.artifacts_naming_option)
  return _internal_artifacts_naming_option();
}
inline void InputOutputConfig::set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value) {
  _internal_set_artifacts_naming_option(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.artifacts_naming_option)
}
inline ::research_scann::InputOutputConfig_ArtifactsNamingOption InputOutputConfig::_internal_artifacts_naming_option() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::InputOutputConfig_ArtifactsNamingOption>(_impl_.artifacts_naming_option_);
}
inline void InputOutputConfig::_internal_set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::InputOutputConfig_ArtifactsNamingOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.artifacts_naming_option_ = value;
}

// optional .research_scann.InputOutputConfig.PureDynamicConfig pure_dynamic_config = 21;
inline bool InputOutputConfig::has_pure_dynamic_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pure_dynamic_config_ != nullptr);
  return value;
}
inline void InputOutputConfig::clear_pure_dynamic_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pure_dynamic_config_ != nullptr) _impl_.pure_dynamic_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::research_scann::InputOutputConfig_PureDynamicConfig& InputOutputConfig::_internal_pure_dynamic_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::InputOutputConfig_PureDynamicConfig* p = _impl_.pure_dynamic_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::InputOutputConfig_PureDynamicConfig&>(::research_scann::_InputOutputConfig_PureDynamicConfig_default_instance_);
}
inline const ::research_scann::InputOutputConfig_PureDynamicConfig& InputOutputConfig::pure_dynamic_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.pure_dynamic_config)
  return _internal_pure_dynamic_config();
}
inline void InputOutputConfig::unsafe_arena_set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pure_dynamic_config_);
  }
  _impl_.pure_dynamic_config_ = reinterpret_cast<::research_scann::InputOutputConfig_PureDynamicConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.InputOutputConfig.pure_dynamic_config)
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::release_pure_dynamic_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::research_scann::InputOutputConfig_PureDynamicConfig* released = _impl_.pure_dynamic_config_;
  _impl_.pure_dynamic_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::unsafe_arena_release_pure_dynamic_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.pure_dynamic_config)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::research_scann::InputOutputConfig_PureDynamicConfig* temp = _impl_.pure_dynamic_config_;
  _impl_.pure_dynamic_config_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::_internal_mutable_pure_dynamic_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.pure_dynamic_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_PureDynamicConfig>(GetArena());
    _impl_.pure_dynamic_config_ = reinterpret_cast<::research_scann::InputOutputConfig_PureDynamicConfig*>(p);
  }
  return _impl_.pure_dynamic_config_;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::mutable_pure_dynamic_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::InputOutputConfig_PureDynamicConfig* _msg = _internal_mutable_pure_dynamic_config();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.pure_dynamic_config)
  return _msg;
}
inline void InputOutputConfig::set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::InputOutputConfig_PureDynamicConfig*>(_impl_.pure_dynamic_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::InputOutputConfig_PureDynamicConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.pure_dynamic_config_ = reinterpret_cast<::research_scann::InputOutputConfig_PureDynamicConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.pure_dynamic_config)
}

// optional .research_scann.InputOutputConfig.FeatureNorm norm_type = 5 [default = NONE];
inline bool InputOutputConfig::has_norm_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void InputOutputConfig::clear_norm_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norm_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::research_scann::InputOutputConfig_FeatureNorm InputOutputConfig::norm_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.norm_type)
  return _internal_norm_type();
}
inline void InputOutputConfig::set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value) {
  _internal_set_norm_type(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.norm_type)
}
inline ::research_scann::InputOutputConfig_FeatureNorm InputOutputConfig::_internal_norm_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::research_scann::InputOutputConfig_FeatureNorm>(_impl_.norm_type_);
}
inline void InputOutputConfig::_internal_set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::research_scann::InputOutputConfig_FeatureNorm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.norm_type_ = value;
}

// optional bool non_negative = 6 [default = false];
inline bool InputOutputConfig::has_non_negative() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void InputOutputConfig::clear_non_negative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.non_negative_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool InputOutputConfig::non_negative() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.non_negative)
  return _internal_non_negative();
}
inline void InputOutputConfig::set_non_negative(bool value) {
  _internal_set_non_negative(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.non_negative)
}
inline bool InputOutputConfig::_internal_non_negative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.non_negative_;
}
inline void InputOutputConfig::_internal_set_non_negative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.non_negative_ = value;
}

// optional bool is_dense = 7;
inline bool InputOutputConfig::has_is_dense() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void InputOutputConfig::clear_is_dense() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_dense_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool InputOutputConfig::is_dense() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.is_dense)
  return _internal_is_dense();
}
inline void InputOutputConfig::set_is_dense(bool value) {
  _internal_set_is_dense(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.is_dense)
}
inline bool InputOutputConfig::_internal_is_dense() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_dense_;
}
inline void InputOutputConfig::_internal_set_is_dense(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.is_dense_ = value;
}

// optional .research_scann.InputOutputConfig.PreprocessingFunction query_preprocessing_function = 16;
inline bool InputOutputConfig::has_query_preprocessing_function() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_preprocessing_function_ != nullptr);
  return value;
}
inline void InputOutputConfig::clear_query_preprocessing_function() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.query_preprocessing_function_ != nullptr) _impl_.query_preprocessing_function_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::research_scann::InputOutputConfig_PreprocessingFunction& InputOutputConfig::_internal_query_preprocessing_function() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::research_scann::InputOutputConfig_PreprocessingFunction* p = _impl_.query_preprocessing_function_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::InputOutputConfig_PreprocessingFunction&>(::research_scann::_InputOutputConfig_PreprocessingFunction_default_instance_);
}
inline const ::research_scann::InputOutputConfig_PreprocessingFunction& InputOutputConfig::query_preprocessing_function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.query_preprocessing_function)
  return _internal_query_preprocessing_function();
}
inline void InputOutputConfig::unsafe_arena_set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_preprocessing_function_);
  }
  _impl_.query_preprocessing_function_ = reinterpret_cast<::research_scann::InputOutputConfig_PreprocessingFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.InputOutputConfig.query_preprocessing_function)
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::release_query_preprocessing_function() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::research_scann::InputOutputConfig_PreprocessingFunction* released = _impl_.query_preprocessing_function_;
  _impl_.query_preprocessing_function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::unsafe_arena_release_query_preprocessing_function() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.query_preprocessing_function)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::research_scann::InputOutputConfig_PreprocessingFunction* temp = _impl_.query_preprocessing_function_;
  _impl_.query_preprocessing_function_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::_internal_mutable_query_preprocessing_function() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.query_preprocessing_function_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_PreprocessingFunction>(GetArena());
    _impl_.query_preprocessing_function_ = reinterpret_cast<::research_scann::InputOutputConfig_PreprocessingFunction*>(p);
  }
  return _impl_.query_preprocessing_function_;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::mutable_query_preprocessing_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::research_scann::InputOutputConfig_PreprocessingFunction* _msg = _internal_mutable_query_preprocessing_function();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.query_preprocessing_function)
  return _msg;
}
inline void InputOutputConfig::set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::research_scann::InputOutputConfig_PreprocessingFunction*>(_impl_.query_preprocessing_function_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::research_scann::InputOutputConfig_PreprocessingFunction*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.query_preprocessing_function_ = reinterpret_cast<::research_scann::InputOutputConfig_PreprocessingFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.query_preprocessing_function)
}

// optional string hashed_database_wildcard = 12;
inline bool InputOutputConfig::has_hashed_database_wildcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InputOutputConfig::clear_hashed_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hashed_database_wildcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InputOutputConfig::hashed_database_wildcard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.hashed_database_wildcard)
  return _internal_hashed_database_wildcard();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_hashed_database_wildcard(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hashed_database_wildcard_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.hashed_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_hashed_database_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hashed_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.hashed_database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_hashed_database_wildcard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hashed_database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_hashed_database_wildcard(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hashed_database_wildcard_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_hashed_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.hashed_database_wildcard_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_hashed_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.hashed_database_wildcard)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.hashed_database_wildcard_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hashed_database_wildcard_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_hashed_database_wildcard(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.hashed_database_wildcard_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hashed_database_wildcard_.IsDefault()) {
          _impl_.hashed_database_wildcard_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.hashed_database_wildcard)
}

// optional string fixed_point_database_wildcard = 17;
inline bool InputOutputConfig::has_fixed_point_database_wildcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InputOutputConfig::clear_fixed_point_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_point_database_wildcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InputOutputConfig::fixed_point_database_wildcard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  return _internal_fixed_point_database_wildcard();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_fixed_point_database_wildcard(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fixed_point_database_wildcard_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_fixed_point_database_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fixed_point_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_fixed_point_database_wildcard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_point_database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_fixed_point_database_wildcard(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fixed_point_database_wildcard_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_fixed_point_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.fixed_point_database_wildcard_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_fixed_point_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.fixed_point_database_wildcard_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fixed_point_database_wildcard_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_fixed_point_database_wildcard(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.fixed_point_database_wildcard_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fixed_point_database_wildcard_.IsDefault()) {
          _impl_.fixed_point_database_wildcard_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}

// optional string tokenized_database_wildcard = 14;
inline bool InputOutputConfig::has_tokenized_database_wildcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InputOutputConfig::clear_tokenized_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tokenized_database_wildcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InputOutputConfig::tokenized_database_wildcard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.tokenized_database_wildcard)
  return _internal_tokenized_database_wildcard();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_tokenized_database_wildcard(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.tokenized_database_wildcard_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.tokenized_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_tokenized_database_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tokenized_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.tokenized_database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_tokenized_database_wildcard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tokenized_database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_tokenized_database_wildcard(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.tokenized_database_wildcard_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_tokenized_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.tokenized_database_wildcard_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_tokenized_database_wildcard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.tokenized_database_wildcard)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.tokenized_database_wildcard_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tokenized_database_wildcard_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_tokenized_database_wildcard(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.tokenized_database_wildcard_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tokenized_database_wildcard_.IsDefault()) {
          _impl_.tokenized_database_wildcard_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.tokenized_database_wildcard)
}

// optional string memory_consumption_estimate_filename = 24;
inline bool InputOutputConfig::has_memory_consumption_estimate_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void InputOutputConfig::clear_memory_consumption_estimate_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.memory_consumption_estimate_filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InputOutputConfig::memory_consumption_estimate_filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  return _internal_memory_consumption_estimate_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputOutputConfig::set_memory_consumption_estimate_filename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.memory_consumption_estimate_filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}
inline std::string* InputOutputConfig::mutable_memory_consumption_estimate_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_memory_consumption_estimate_filename();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_memory_consumption_estimate_filename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.memory_consumption_estimate_filename_.Get();
}
inline void InputOutputConfig::_internal_set_memory_consumption_estimate_filename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.memory_consumption_estimate_filename_.Set(value, GetArena());
}
inline std::string* InputOutputConfig::_internal_mutable_memory_consumption_estimate_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.memory_consumption_estimate_filename_.Mutable( GetArena());
}
inline std::string* InputOutputConfig::release_memory_consumption_estimate_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.memory_consumption_estimate_filename_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.memory_consumption_estimate_filename_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InputOutputConfig::set_allocated_memory_consumption_estimate_filename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.memory_consumption_estimate_filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.memory_consumption_estimate_filename_.IsDefault()) {
          _impl_.memory_consumption_estimate_filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}

// optional bool saturate = 10 [default = false, deprecated = true];
inline bool InputOutputConfig::has_saturate() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void InputOutputConfig::clear_saturate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.saturate_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool InputOutputConfig::saturate() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.saturate)
  return _internal_saturate();
}
inline void InputOutputConfig::set_saturate(bool value) {
  _internal_set_saturate(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.saturate)
}
inline bool InputOutputConfig::_internal_saturate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.saturate_;
}
inline void InputOutputConfig::_internal_set_saturate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.saturate_ = value;
}

// optional uint64 dimensionality = 4 [deprecated = true];
inline bool InputOutputConfig::has_dimensionality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void InputOutputConfig::clear_dimensionality() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dimensionality_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint64_t InputOutputConfig::dimensionality() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.dimensionality)
  return _internal_dimensionality();
}
inline void InputOutputConfig::set_dimensionality(::uint64_t value) {
  _internal_set_dimensionality(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.dimensionality)
}
inline ::uint64_t InputOutputConfig::_internal_dimensionality() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionality_;
}
inline void InputOutputConfig::_internal_set_dimensionality(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.dimensionality_ = value;
}

inline bool InputOutputConfig::has_IncrementalUpdateMetadataOneof() const {
  return IncrementalUpdateMetadataOneof_case() != INCREMENTALUPDATEMETADATAONEOF_NOT_SET;
}
inline void InputOutputConfig::clear_has_IncrementalUpdateMetadataOneof() {
  _impl_._oneof_case_[0] = INCREMENTALUPDATEMETADATAONEOF_NOT_SET;
}
inline InputOutputConfig::IncrementalUpdateMetadataOneofCase InputOutputConfig::IncrementalUpdateMetadataOneof_case() const {
  return InputOutputConfig::IncrementalUpdateMetadataOneofCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace research_scann


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::research_scann::InputOutputConfig_PureDynamicConfig_VectorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::InputOutputConfig_PureDynamicConfig_VectorType>() {
  return ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
}
template <>
struct is_proto_enum<::research_scann::InputOutputConfig_InMemoryTypes> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::InputOutputConfig_InMemoryTypes>() {
  return ::research_scann::InputOutputConfig_InMemoryTypes_descriptor();
}
template <>
struct is_proto_enum<::research_scann::InputOutputConfig_ArtifactsNamingOption> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::InputOutputConfig_ArtifactsNamingOption>() {
  return ::research_scann::InputOutputConfig_ArtifactsNamingOption_descriptor();
}
template <>
struct is_proto_enum<::research_scann::InputOutputConfig_FeatureNorm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::research_scann::InputOutputConfig_FeatureNorm>() {
  return ::research_scann::InputOutputConfig_FeatureNorm_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto_2epb_2eh
